{
  "Widgetbook": {
    "Addons": {
      "AccessibilityAddon": {
        "accessibility_addon": "import 'package:accessibility_tools/accessibility_tools.dart';\n\nimport '../builder_addon/builder_addon.dart';\n\n/// @nodoc\n@Deprecated(\n  'Please use the `accessibility_tools` package directly with a `BuilderAddon`. '\n  'For more information, see https://docs.widgetbook.io/addons/accessibility-addon.',\n)\nclass AccessibilityAddon extends BuilderAddon {\n  /// @nodoc\n  AccessibilityAddon()\n    : super(\n        name: 'Accessibility',\n        builder: (context, child) => AccessibilityTools(\n          child: child,\n        ),\n      );\n}\n",
        "addon": "export 'accessibility_addon.dart';\n"
      },
      "Addons": {
        "addons": "export 'accessibility_addon/addon.dart';\nexport 'alignment_addon/addon.dart';\nexport 'builder_addon/addon.dart';\nexport 'common/common.dart';\nexport 'device_frame_addon/addon.dart';\nexport 'grid_addon/addon.dart';\nexport 'inspector_addon/addon.dart';\nexport 'localization_addon/addon.dart';\nexport 'semantics_addon/addon.dart';\nexport 'text_scale_addon/addon.dart';\nexport 'theme_addon/addon.dart';\nexport 'time_dilation_addon/addon.dart';\nexport 'viewport_addon/addon.dart';\nexport 'zoom_addon/addon.dart';\n"
      },
      "AlignmentAddon": {
        "addon": "export 'alignment_addon.dart';\n",
        "alignment_addon": "import 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for testing widget alignment within its container.\n///\n/// The alignment addon wraps use cases with an [Align] widget, allowing\n/// developers to test how their widgets behave when positioned at different\n/// locations within their parent container.\n///\n/// Learn more: https://docs.widgetbook.io/addons/alignment-addon\nclass AlignmentAddon extends WidgetbookAddon<Alignment> {\n  /// Creates a new instance of [AlignmentAddon].\n  AlignmentAddon({\n    this.initialAlignment = Alignment.center,\n  }) : super(\n         name: 'Alignment',\n       );\n\n  /// The default alignment applied when the addon first loads.\n  ///\n  /// This value is used as the initial selection in the alignment dropdown\n  /// and determines the starting position of the wrapped widget.\n  ///\n  /// Defaults to [Alignment.center] for centered positioning.\n  final Alignment initialAlignment;\n\n  /// Maps [Alignment] values to their human-readable string representations.\n  ///\n  /// Used for both URL query parameters and dropdown labels in the UI.\n  /// Contains all nine standard alignment positions in a 3x3 grid layout.\n  static final alignments = {\n    Alignment.topLeft: 'Top Left',\n    Alignment.topCenter: 'Top Center',\n    Alignment.topRight: 'Top Right',\n    Alignment.centerLeft: 'Center Left',\n    Alignment.center: 'Center',\n    Alignment.centerRight: 'Center Right',\n    Alignment.bottomLeft: 'Bottom Left',\n    Alignment.bottomCenter: 'Bottom Center',\n    Alignment.bottomRight: 'Bottom Right',\n  };\n\n  @override\n  List<Field<Alignment>> get fields {\n    return [\n      ObjectDropdownField<Alignment>(\n        name: 'alignment',\n        initialValue: initialAlignment,\n        values: alignments.keys.toList(),\n        labelBuilder: (value) => alignments[value]!,\n      ),\n    ];\n  }\n\n  @override\n  Alignment valueFromQueryGroup(Map<String, String> group) {\n    return valueOf<Alignment>('alignment', group)!;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    Alignment setting,\n  ) {\n    return Align(\n      alignment: setting,\n      child: child,\n    );\n  }\n}\n"
      },
      "BuilderAddon": {
        "addon": "export 'builder_addon.dart';\n",
        "builder_addon": "import 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for applying custom widget transformations to use cases.\n///\n/// The builder addon provides a flexible way to wrap use cases with custom\n/// widget builders, enabling developers to apply consistent transformations,\n/// decorations, or context modifications across multiple use cases.\n///\n/// Learn more: https://docs.widgetbook.io/addons/builder-addon\nclass BuilderAddon extends WidgetbookAddon<void> {\n  /// Creates a new instance of [BuilderAddon].\n  BuilderAddon({\n    required super.name,\n    required this.builder,\n  });\n\n  /// Custom widget builder function that transforms use case content.\n  final Widget Function(BuildContext context, Widget child) builder;\n\n  @override\n  List<Field> get fields => [];\n\n  @override\n  void valueFromQueryGroup(Map<String, String> group) {}\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    void setting,\n  ) {\n    return builder(context, child);\n  }\n}\n"
      },
      "Common": {
        "common": "export 'multi_addon_builder.dart';\nexport 'widgetbook_addon.dart';\n",
        "multi_addon_builder": "import 'package:flutter/widgets.dart';\nimport 'package:meta/meta.dart';\nimport 'package:nested/nested.dart';\n\nimport 'widgetbook_addon.dart';\n\n/// @nodoc\n@internal\ntypedef AddonBuilder =\n    Widget Function(\n      BuildContext context,\n      WidgetbookAddon addon,\n      Widget child,\n    );\n\n/// Nests [WidgetbookAddon] builders inside each other, using [Nested] widget.\n@internal\nclass MultiAddonBuilder extends StatelessWidget {\n  MultiAddonBuilder({\n    super.key,\n    required this.addons,\n    required this.builder,\n    required this.child,\n  });\n\n  final List<WidgetbookAddon>? addons;\n  final AddonBuilder builder;\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    if (addons == null || addons!.isEmpty) {\n      return child;\n    }\n\n    return Nested(\n      children: addons!\n          .map(\n            (addon) => SingleChildBuilder(\n              builder: (context, child) => builder(\n                context,\n                addon,\n                child!,\n              ),\n            ),\n          )\n          .toList(),\n      child: child,\n    );\n  }\n}\n",
        "widgetbook_addon": "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../../knobs/knobs.dart';\nimport '../../navigation/navigation.dart';\n\n/// Base class for all Widgetbook addons.\n///\n/// [WidgetbookAddon]s are global configuration tools that affect all\n/// [WidgetbookUseCase]s in your Widgetbook. Unlike [Knob]s, which operate\n/// at the individual use case level, addons provide cross-cutting functionality\n/// such as theming, localization, viewport simulation, and more.\n///\n/// Learn more:\n/// * https://docs.widgetbook.io/addons/overview\n/// * https://docs.widgetbook.io/addons/custom-addon\n@optionalTypeArgs\nabstract class WidgetbookAddon<T> extends FieldsComposable<T> {\n  /// Creates a [WidgetbookAddon] with the given [name].\n  WidgetbookAddon({\n    required super.name,\n    @Deprecated('Use local field instead') this.initialSetting,\n  });\n\n  /// @nodoc\n  @Deprecated('Use local field instead')\n  final T? initialSetting;\n\n  @override\n  String get groupName => slugify(name);\n\n  /// Builds the wrapper widget for use cases based on the current [setting].\n  ///\n  /// This method is called for every use case and allows the addon to wrap\n  /// the use case widget with additional functionality. The [setting] parameter\n  /// contains the current value selected by the user in the addon's UI.\n  ///\n  /// By default, this method returns the [child] widget unchanged. Override\n  /// this method to implement the addon's functionality.\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    T setting,\n  ) {\n    return child;\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'name': name,\n      'group': groupName,\n      'fields': fields.map((field) => field.toFullJson()).toList(),\n    };\n  }\n}\n"
      },
      "DeviceFrameAddon": {
        "addon": "export 'package:device_frame_plus/device_frame_plus.dart'\n    show DeviceInfo, Devices;\n\nexport 'device_frame_addon.dart';\nexport 'device_frame_setting.dart';\nexport 'none_device.dart';\n",
        "device_frame_addon": "import 'package:device_frame_plus/device_frame_plus.dart';\nimport 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../../widgetbook_theme.dart';\nimport '../common/common.dart';\nimport 'device_frame_setting.dart';\nimport 'none_device.dart';\n\n/// @nodoc\n@Deprecated(\n  'The [DeviceFrameAddon] is deprecated and will be removed in a future version. '\n  'Please use the [ViewportAddon] instead. '\n  'More info: https://docs.widgetbook.io/addons/viewport-addon',\n)\nclass DeviceFrameAddon extends WidgetbookAddon<DeviceFrameSetting> {\n  /// @nodoc\n  DeviceFrameAddon({\n    required List<DeviceInfo> devices,\n    this.initialDevice = NoneDevice.instance,\n  }) : assert(\n         devices.isNotEmpty,\n         'devices cannot be empty',\n       ),\n       assert(\n         initialDevice == NoneDevice.instance ||\n             devices.contains(initialDevice),\n         'initialDevice must be in devices',\n       ),\n       this.devices = [NoneDevice.instance, ...devices],\n       super(\n         name: 'Device',\n       );\n\n  /// @nodoc\n  final DeviceInfo initialDevice;\n\n  /// @nodoc\n  final List<DeviceInfo> devices;\n\n  @override\n  List<Field> get fields {\n    return [\n      ObjectDropdownField<DeviceInfo>(\n        name: 'name',\n        values: devices,\n        initialValue: initialDevice,\n        labelBuilder: (device) => device.name,\n      ),\n      ObjectDropdownField<Orientation>(\n        name: 'orientation',\n        values: Orientation.values,\n        initialValue: Orientation.portrait,\n        labelBuilder: (orientation) =>\n            orientation.name.substring(0, 1).toUpperCase() +\n            orientation.name.substring(1),\n      ),\n      ObjectDropdownField<bool>(\n        name: 'frame',\n        values: [false, true],\n        initialValue: true,\n        labelBuilder: (hasFrame) => hasFrame ? 'Device Frame' : 'None',\n      ),\n    ];\n  }\n\n  @override\n  DeviceFrameSetting valueFromQueryGroup(Map<String, String> group) {\n    return DeviceFrameSetting(\n      device: valueOf('name', group)!,\n      orientation: valueOf('orientation', group)!,\n      hasFrame: valueOf('frame', group)!,\n    );\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    DeviceFrameSetting setting,\n  ) {\n    if (setting.device is NoneDevice) {\n      return child;\n    }\n\n    return Padding(\n      padding: const EdgeInsets.all(32),\n      child: Center(\n        child: DeviceFrame(\n          orientation: setting.orientation,\n          device: setting.device,\n          isFrameVisible: setting.hasFrame,\n          screen: ColoredBox(\n            color: WidgetbookTheme.of(context).scaffoldBackgroundColor,\n            child: Navigator(\n              // A navigator below the device frame is necessary to make the\n              // popup routes (e.g. dialogs and bottom sheets) work within the\n              // device frame, otherwise they would use the navigator from the\n              // app builder, causing these routes to fill the whole workbench\n              // and not just the device frame.\n              onGenerateRoute: (_) => PageRouteBuilder(\n                pageBuilder: (context, _, __) => setting.hasFrame\n                    ? child\n                    : SafeArea(\n                        child: child,\n                      ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
        "device_frame_setting": "import 'package:device_frame_plus/device_frame_plus.dart';\nimport 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass DeviceFrameSetting {\n  DeviceFrameSetting({\n    required this.device,\n    this.orientation = Orientation.portrait,\n    this.hasFrame = true,\n  });\n\n  final DeviceInfo device;\n  final Orientation orientation;\n  final bool hasFrame;\n}\n",
        "none_device": "import 'package:device_frame_plus/device_frame_plus.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n// ignore: unnecessary_import flutter(<3.35)\nimport 'package:meta/meta.dart';\n\n@internal\nclass NoneDevice with DiagnosticableTreeMixin implements DeviceInfo {\n  const NoneDevice._();\n\n  static const NoneDevice instance = NoneDevice._();\n\n  @override\n  String get name => 'None';\n\n  @override\n  DeviceIdentifier get identifier => throw UnimplementedError();\n\n  @override\n  Size get frameSize => throw UnimplementedError();\n\n  @override\n  Size get screenSize => throw UnimplementedError();\n\n  @override\n  double get pixelRatio => throw UnimplementedError();\n\n  @override\n  EdgeInsets? get rotatedSafeAreas => throw UnimplementedError();\n\n  @override\n  EdgeInsets get safeAreas => throw UnimplementedError();\n\n  @override\n  Path get screenPath => throw UnimplementedError();\n\n  @override\n  CustomPainter get framePainter => throw UnimplementedError();\n\n  @override\n  DeviceInfo copyWith({\n    DeviceIdentifier? identifier,\n    String? name,\n    EdgeInsets? rotatedSafeAreas,\n    EdgeInsets? safeAreas,\n    Path? screenPath,\n    double? pixelRatio,\n    CustomPainter? framePainter,\n    Size? frameSize,\n    Size? screenSize,\n  }) {\n    return instance;\n  }\n}\n"
      },
      "GridAddon": {
        "addon": "export 'grid_addon.dart';\n",
        "grid_addon": "import 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for overlaying alignment grids on use cases.\n///\n/// The grid addon provides visual alignment assistance by overlaying\n/// a customizable grid pattern over use cases. This helps developers\n/// ensure proper spacing, alignment, and layout consistency during\n/// component development and testing.\n///\n/// Learn more: https://docs.widgetbook.io/addons/grid-addon\nclass GridAddon extends WidgetbookAddon<int> {\n  /// Creates a new instance of [GridAddon].\n  GridAddon([\n    this.dimension = 50,\n  ]) : assert(dimension > 0),\n       super(\n         name: 'Grid',\n       );\n\n  /// The spacing between grid lines in pixels.\n  final int dimension;\n\n  @override\n  List<Field> get fields => [];\n\n  @override\n  int valueFromQueryGroup(Map<String, String> group) => dimension;\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    int setting,\n  ) {\n    return Stack(\n      children: [\n        GridPaper(\n          color: Colors.grey.withAlpha(255 ~/ 2),\n          interval: setting.toDouble(),\n          subdivisions: 2,\n          child: Container(),\n        ),\n        child,\n      ],\n    );\n  }\n}\n"
      },
      "InspectorAddon": {
        "addon": "export 'inspector_addon.dart';\n",
        "inspector_addon": "import 'package:flutter/material.dart';\nimport 'package:inspector/inspector.dart';\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for enabling widget inspection and debugging tools.\n///\n/// The addon integrates the [inspector](https://pub.dev/packages/inspector)\n/// package to provide advanced debugging capabilities directly within\n/// Widgetbook. When enabled, it overlays interactive inspection tools that\n/// help developers analyze widget structure, properties, and layout behavior.\n///\n/// Learn more: https://docs.widgetbook.io/addons/inspector-addon\nclass InspectorAddon extends WidgetbookAddon<bool> {\n  /// Creates a new instance of [InspectorAddon].\n  InspectorAddon({\n    this.enabled = false,\n  }) : super(\n         name: 'Inspector',\n       );\n\n  /// The default enabled state for the inspector when the addon loads.\n  ///\n  /// When true, the inspector starts active and immediately provides\n  /// debugging overlays. When false, users must manually enable it\n  /// through the Widgetbook interface.\n  ///\n  /// This setting is useful for different development scenarios:\n  /// - `true`: When actively debugging layout issues\n  /// - `false`: For normal development to reduce visual clutter\n  final bool enabled;\n\n  /// Generates the inspector toggle control field.\n  ///\n  /// Creates a [BooleanField] that allows users to enable or disable\n  /// the widget inspector overlay. The toggle provides immediate\n  /// feedback, showing or hiding inspection tools in real-time.\n  ///\n  /// The field appears as a checkbox labeled \"Inspector\" in the\n  /// Widgetbook interface, allowing quick toggling during development.\n  @override\n  List<Field> get fields => [\n    BooleanField(\n      name: 'isEnabled',\n      initialValue: enabled,\n    ),\n  ];\n\n  /// Extracts the inspector enabled state from URL query parameters.\n  ///\n  /// Parses the 'isEnabled' parameter from the query group to restore\n  /// the inspector state when loading from URLs or sharing links.\n  /// Defaults to false if no parameter is found.\n  ///\n  /// This enables consistent inspector state when reproducing specific\n  /// debugging scenarios or sharing use case configurations with\n  /// team members who need the same inspection setup.\n  @override\n  bool valueFromQueryGroup(Map<String, String> group) {\n    return valueOf('isEnabled', group) ?? false;\n  }\n\n  /// Conditionally wraps the use case with inspector functionality.\n  ///\n  /// When [setting] is true, wraps the child widget with the [Inspector]\n  /// widget that provides interactive debugging tools. When false,\n  /// returns the child unchanged for normal rendering.\n  ///\n  /// Parameters:\n  ///   * [context] - The build context for the widget\n  ///   * [child] - The use case widget to optionally wrap with inspection\n  ///   * [setting] - Whether the inspector should be enabled\n  ///\n  /// ## Inspector Behavior\n  ///\n  /// When enabled, the inspector overlays provide:\n  /// - Interactive widget selection by tapping\n  /// - Real-time property display\n  /// - Visual layout bounds and constraints\n  /// - Widget hierarchy navigation\n  /// - Performance debugging information\n  ///\n  /// The inspector is forced to enabled state (`isEnabled: true`) to\n  /// bypass automatic disabling in release builds, ensuring it works\n  /// consistently in Widgetbook regardless of build configuration.\n  ///\n  /// Returns either the original child widget or the child wrapped\n  /// with inspector debugging capabilities.\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    bool setting,\n  ) {\n    if (!setting) return child;\n\n    return Inspector(\n      isEnabled: true, // To bypass disabling on release builds\n      child: child,\n    );\n  }\n}\n"
      },
      "LocalizationAddon": {
        "addon": "export 'localization_addon.dart';\n",
        "localization_addon": "import 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for switching between different locales.\n///\n/// [LocalizationAddon] enables users to test their widgets with different locales\n/// and localizations. This is essential for apps that support multiple languages\n/// or regions, allowing developers to verify that text, formatting, and layout\n/// work correctly across different locales.\n///\n/// Learn more: https://docs.widgetbook.io/addons/localization-addon\nclass LocalizationAddon extends WidgetbookAddon<Locale> {\n  /// Creates a new instance of [LocalizationAddon].\n  LocalizationAddon({\n    required this.locales,\n    required this.localizationsDelegates,\n    this.initialLocale,\n  }) : assert(\n         locales.isNotEmpty,\n         'locales cannot be empty',\n       ),\n       assert(\n         initialLocale == null || locales.contains(initialLocale),\n         'initialLocale must be in locales',\n       ),\n       super(\n         name: 'Locale',\n       );\n\n  /// The default locale selection when the addon is first loaded.\n  ///\n  /// If null, the first locale in [locales] will be used as the default.\n  final Locale? initialLocale;\n\n  /// The list of supported locales available for selection.\n  ///\n  /// These locales will appear in the dropdown menu in the settings panel.\n  /// The list cannot be empty.\n  final List<Locale> locales;\n\n  /// The localization delegates that provide localized content.\n  ///\n  /// These delegates are responsible for loading and providing localized\n  /// strings, date/number formatting, and other locale-specific content.\n  /// Typically includes Material, Widgets, and Cupertino delegates.\n  final List<LocalizationsDelegate<dynamic>> localizationsDelegates;\n\n  @override\n  List<Field> get fields {\n    return [\n      ObjectDropdownField<Locale>(\n        name: 'name',\n        values: locales,\n        initialValue: initialLocale ?? locales.first,\n        labelBuilder: (locale) => locale.toLanguageTag(),\n      ),\n    ];\n  }\n\n  @override\n  Locale valueFromQueryGroup(Map<String, String> group) {\n    return valueOf('name', group)!;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    Locale setting,\n  ) {\n    return Localizations(\n      locale: setting,\n      delegates: localizationsDelegates,\n      child: child,\n    );\n  }\n}\n"
      },
      "SemanticsAddon": {
        "addon": "export 'semantics_addon.dart';\n",
        "minimal_semantics_debugger": "import 'dart:math' as math;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/widgets.dart';\n// ignore: unnecessary_import flutter(<3.35.0)\nimport 'package:meta/meta.dart';\n\nextension on SemanticsNode {\n  /// Finds the first child [SemanticsNode] that matches the given [predicate].\n  SemanticsNode? find(bool Function(SemanticsNode) predicate) {\n    if (predicate(this)) {\n      return this;\n    }\n\n    SemanticsNode? foundNode;\n\n    visitChildren((child) {\n      foundNode = child.find(predicate);\n      return foundNode == null; // Stop visiting if found\n    });\n\n    return foundNode;\n  }\n}\n\n/// A minimal copy of the [SemanticsDebugger] widget that is optimized\n/// for Widgetbook and does not have the pointer functionality.\n///\n/// The major difference is that the root semantics node is not\n/// the root node of the semantics tree, but a node that is\n/// identified by the [rootIdentifier].\n@internal\nclass MinimalSemanticsDebugger extends StatefulWidget {\n  /// Creates a widget that visualizes the semantics for the child.\n  ///\n  /// [labelStyle] dictates the [TextStyle] used for the semantics labels.\n  const MinimalSemanticsDebugger({\n    super.key,\n    required this.child,\n    required this.rootIdentifier,\n    this.labelStyle = const TextStyle(\n      color: Color(0xFF000000),\n      fontSize: 10.0,\n      height: 0.8,\n    ),\n  });\n\n  final Widget child;\n  final TextStyle labelStyle;\n  final String rootIdentifier;\n\n  @override\n  State<MinimalSemanticsDebugger> createState() =>\n      _MinimalSemanticsDebuggerState();\n}\n\nclass _MinimalSemanticsDebuggerState extends State<MinimalSemanticsDebugger>\n    with WidgetsBindingObserver {\n  PipelineOwner? _pipelineOwner;\n  SemanticsHandle? _semanticsHandle;\n  int _generation = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _semanticsHandle = SemanticsBinding.instance.ensureSemantics();\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final newOwner = View.pipelineOwnerOf(context);\n    assert(newOwner.semanticsOwner != null);\n    if (newOwner != _pipelineOwner) {\n      _pipelineOwner?.semanticsOwner?.removeListener(_update);\n      newOwner.semanticsOwner!.addListener(_update);\n      _pipelineOwner = newOwner;\n    }\n  }\n\n  @override\n  void dispose() {\n    _pipelineOwner?.semanticsOwner?.removeListener(_update);\n    _semanticsHandle?.dispose();\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  @override\n  void didChangeMetrics() {\n    setState(() {\n      // The root transform may have changed, we have to repaint.\n    });\n  }\n\n  void _update() {\n    _generation++;\n    SchedulerBinding.instance.addPostFrameCallback(\n      (timeStamp) {\n        // Semantic information are only available at the end of a frame and our\n        // only chance to paint them on the screen is the next frame. To achieve\n        // this, we call setState() in a post-frame callback.\n        if (mounted) {\n          // If we got disposed this frame, we will still get an update,\n          // because the inactive list is flushed after the semantics updates\n          // are transmitted to the semantics clients.\n          setState(() {\n            // The generation of the _SemanticsDebuggerListener has changed.\n          });\n        }\n      },\n      debugLabel: 'SemanticsDebugger.update',\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      foregroundPainter: SemanticsDebuggerPainter(\n        _pipelineOwner!,\n        _generation,\n        View.of(context).devicePixelRatio,\n        widget.labelStyle,\n        widget.rootIdentifier,\n      ),\n      // NOTE: this is different from the original SemanticsDebugger, which uses\n      // a GestureDetector to handle pointer events. We don't need that here.\n      child: widget.child,\n    );\n  }\n}\n\n@internal\nclass SemanticsDebuggerPainter extends CustomPainter {\n  const SemanticsDebuggerPainter(\n    this.owner,\n    this.generation,\n    this.devicePixelRatio,\n    this.labelStyle,\n    this.rootIdentifier,\n  );\n\n  final PipelineOwner owner;\n  final int generation;\n  final double devicePixelRatio;\n  final TextStyle labelStyle;\n  final String rootIdentifier;\n\n  // NOTE: this is different from the original SemanticsDebugger, which uses\n  // the root semantics node. Here we use the boundaries of the addon as a\n  // root, to prevent layout shifting.\n  // https://github.com/widgetbook/widgetbook/issues/1140\n  SemanticsNode? get _rootSemanticsNode {\n    final rootNode = owner.semanticsOwner?.rootSemanticsNode?.find(\n      (node) => node.identifier == rootIdentifier,\n    );\n\n    return rootNode;\n  }\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rootNode = _rootSemanticsNode;\n\n    canvas.save();\n\n    if (rootNode != null) {\n      _paint(canvas, rootNode, _findDepth(rootNode), 0, 0);\n    }\n\n    canvas.restore();\n  }\n\n  @override\n  bool shouldRepaint(SemanticsDebuggerPainter oldDelegate) {\n    return owner != oldDelegate.owner || generation != oldDelegate.generation;\n  }\n\n  @visibleForTesting\n  String getMessage(SemanticsNode node) {\n    final data = node.getSemanticsData();\n    final annotations = <String>[];\n\n    var wantsTap = false;\n\n    // ignore: deprecated_member_use flutter(<3.35.0)\n    if (data.hasFlag(SemanticsFlag.hasCheckedState)) {\n      annotations.add(\n        // ignore: deprecated_member_use flutter(<3.35.0)\n        data.hasFlag(SemanticsFlag.isChecked) ? 'checked' : 'unchecked',\n      );\n      wantsTap = true;\n    }\n\n    // ignore: deprecated_member_use flutter(<3.35.0)\n    if (data.hasFlag(SemanticsFlag.hasSelectedState)) {\n      annotations.add(\n        // ignore: deprecated_member_use flutter(<3.35.0)\n        data.hasFlag(SemanticsFlag.isSelected) ? 'selected' : 'unselected',\n      );\n      wantsTap = true;\n    }\n\n    // ignore: deprecated_member_use flutter(<3.35.0)\n    if (data.hasFlag(SemanticsFlag.isTextField)) {\n      annotations.add('textfield');\n      wantsTap = true;\n    }\n\n    if (data.hasAction(SemanticsAction.tap)) {\n      if (!wantsTap) {\n        annotations.add('button');\n      }\n    } else {\n      if (wantsTap) {\n        annotations.add('disabled');\n      }\n    }\n\n    if (data.hasAction(SemanticsAction.longPress)) {\n      annotations.add('long-pressable');\n    }\n\n    final isScrollable =\n        data.hasAction(SemanticsAction.scrollLeft) ||\n        data.hasAction(SemanticsAction.scrollRight) ||\n        data.hasAction(SemanticsAction.scrollUp) ||\n        data.hasAction(SemanticsAction.scrollDown);\n\n    final isAdjustable =\n        data.hasAction(SemanticsAction.increase) ||\n        data.hasAction(SemanticsAction.decrease);\n\n    if (isScrollable) {\n      annotations.add('scrollable');\n    }\n\n    if (isAdjustable) {\n      annotations.add('adjustable');\n    }\n\n    final String message;\n    // Android will avoid pronouncing duplicating tooltip and label.\n    // Therefore, having two identical strings is the same as having a single\n    // string.\n    final shouldIgnoreDuplicatedLabel =\n        defaultTargetPlatform == TargetPlatform.android &&\n        data.attributedLabel.string == data.tooltip;\n    final tooltipAndLabel = <String>[\n      if (data.tooltip.isNotEmpty) data.tooltip,\n      if (data.attributedLabel.string.isNotEmpty &&\n          !shouldIgnoreDuplicatedLabel)\n        data.attributedLabel.string,\n    ].join('\\n');\n    if (tooltipAndLabel.isEmpty) {\n      message = annotations.join('; ');\n    } else {\n      final String effectiveLabel;\n      if (data.textDirection == null) {\n        effectiveLabel = '${Unicode.FSI}$tooltipAndLabel${Unicode.PDI}';\n        annotations.insert(0, 'MISSING TEXT DIRECTION');\n      } else {\n        effectiveLabel = switch (data.textDirection!) {\n          TextDirection.rtl => '${Unicode.RLI}$tooltipAndLabel${Unicode.PDI}',\n          TextDirection.ltr => tooltipAndLabel,\n        };\n      }\n      if (annotations.isEmpty) {\n        message = effectiveLabel;\n      } else {\n        message = '$effectiveLabel (${annotations.join('; ')})';\n      }\n    }\n\n    return message.trim();\n  }\n\n  void _paintMessage(Canvas canvas, SemanticsNode node) {\n    final message = getMessage(node);\n    if (message.isEmpty) {\n      return;\n    }\n    final rect = node.rect;\n    canvas.save();\n    canvas.clipRect(rect);\n    final textPainter = TextPainter()\n      ..text = TextSpan(style: labelStyle, text: message)\n      ..textDirection = TextDirection\n          .ltr // _getMessage always returns LTR text, even if node.label is RTL\n      ..textAlign = TextAlign.center\n      ..layout(maxWidth: rect.width);\n\n    textPainter.paint(\n      canvas,\n      Alignment.center.inscribe(textPainter.size, rect).topLeft,\n    );\n\n    textPainter.dispose();\n    canvas.restore();\n  }\n\n  int _findDepth(SemanticsNode node) {\n    if (!node.hasChildren || node.mergeAllDescendantsIntoThisNode) {\n      return 1;\n    }\n    var childrenDepth = 0;\n    node.visitChildren((child) {\n      childrenDepth = math.max(childrenDepth, _findDepth(child));\n      return true;\n    });\n    return childrenDepth + 1;\n  }\n\n  void _paint(\n    Canvas canvas,\n    SemanticsNode node,\n    int rank,\n    int indexInParent,\n    int level,\n  ) {\n    canvas.save();\n    if (node.transform != null) {\n      canvas.transform(node.transform!.storage);\n    }\n    final rect = node.rect;\n    if (!rect.isEmpty) {\n      final lineColor = _colorForNode(indexInParent, level);\n      final innerRect = rect.deflate(rank * 1.0);\n      if (innerRect.isEmpty) {\n        final fill = Paint()\n          ..color = lineColor\n          ..style = PaintingStyle.fill;\n        canvas.drawRect(rect, fill);\n      } else {\n        final fill = Paint()\n          ..color = const Color(0xFFFFFFFF)\n          ..style = PaintingStyle.fill;\n        canvas.drawRect(rect, fill);\n        final line = Paint()\n          ..strokeWidth = rank * 2.0\n          ..color = lineColor\n          ..style = PaintingStyle.stroke;\n        canvas.drawRect(innerRect, line);\n      }\n      _paintMessage(canvas, node);\n    }\n    if (!node.mergeAllDescendantsIntoThisNode) {\n      final childRank = rank - 1;\n      final childLevel = level + 1;\n      var childIndex = 0;\n      node.visitChildren((child) {\n        _paint(canvas, child, childRank, childIndex, childLevel);\n        childIndex += 1;\n        return true;\n      });\n    }\n    canvas.restore();\n  }\n\n  static Color _colorForNode(int index, int level) {\n    return HSLColor.fromAHSL(\n      1.0,\n      // Use custom hash to ensure stable value regardless of Dart changes\n      360.0 * math.Random(_getColorSeed(index, level)).nextDouble(),\n      1.0,\n      0.7,\n    ).toColor();\n  }\n\n  static int _getColorSeed(int level, int index) {\n    // Should be no collision as long as children number < 10000.\n    return level * 10000 + index;\n  }\n}\n",
        "semantics_addon": "import 'package:flutter/widgets.dart';\nimport 'package:meta/meta.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\nimport 'minimal_semantics_debugger.dart';\n\n/// A [WidgetbookAddon] that provides a minimal semantics debugger.\n///\n/// This addon wraps the widget in a [Semantics] widget with a custom\n/// [MinimalSemanticsDebugger]. It allows you to visualize the semantics\n/// tree of the widget being debugged.\n///\n/// Learn more: https://docs.widgetbook.io/addons/semantics-addon\n@experimental\nclass SemanticsAddon extends WidgetbookAddon<bool> {\n  /// Creates a new instance of [SemanticsAddon].\n  SemanticsAddon({\n    this.enabled = false,\n  }) : super(\n         name: 'Semantics',\n       );\n\n  /// Whether the semantics debugger is enabled.\n  final bool enabled;\n\n  @override\n  List<Field> get fields => [\n    BooleanField(\n      name: 'enabled',\n      initialValue: enabled,\n    ),\n  ];\n\n  @override\n  bool valueFromQueryGroup(Map<String, String> group) {\n    return valueOf('enabled', group) ?? false;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    bool setting,\n  ) {\n    if (!setting) return child;\n\n    const identifier = 'SemanticsAddon.Root';\n\n    return Semantics(\n      // This semantics node will be used as the root of the semantics tree\n      // for the widget being debugged.\n      identifier: identifier,\n      container: true, // prevent node from getting merged\n      explicitChildNodes: true, // prevent children from altering the root node\n      child: MinimalSemanticsDebugger(\n        rootIdentifier: identifier,\n        child: child,\n      ),\n    );\n  }\n}\n"
      },
      "TextScaleAddon": {
        "addon": "export 'text_scale_addon.dart';\n",
        "text_scale_addon": "// ignore_for_file: deprecated_member_use_from_same_package\n\nimport 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for scaling text content to test accessibility\n/// and responsive typography.\n///\n/// The text scale addon allows developers to test their UI components\n/// with different text scale factors, which is essential for ensuring\n/// accessibility compliance and proper layout behavior at various text sizes.\n///\n/// Learn more: https://docs.widgetbook.io/addons/text-scale-addon\nclass TextScaleAddon extends WidgetbookAddon<double> {\n  /// Creates a new instance of [TextScaleAddon].\n  TextScaleAddon({\n    @Deprecated('Use TextScaleAddon.min and TextScaleAddon.max instead')\n    this.scales,\n    this.initialScale,\n    this.min = 0.5,\n    this.max = 2.0,\n    this.divisions = 6,\n  }) : assert(\n         scales == null || scales.isNotEmpty,\n         'scales must not be empty, if set',\n       ),\n       assert(\n         scales == null ||\n             initialScale == null ||\n             scales.contains(initialScale),\n         'initialScale must be in scales',\n       ),\n       super(\n         name: 'Text scale',\n       );\n\n  /// @nodoc\n  @Deprecated('Use TextScaleAddon.min and TextScaleAddon.max instead')\n  final List<double>? scales;\n\n  /// Initial text scale factor to display when the addon loads.\n  ///\n  /// Defaults to 1.0 (normal scale) if not specified.\n  /// Must be within the [min] to [max] range in slider mode,\n  /// or contained in [scales] list in discrete mode.\n  final double? initialScale;\n\n  /// Minimum text scale factor for slider mode.\n  ///\n  /// Defaults to 0.5, which represents 50% of normal text size.\n  /// Should be a positive value less than [max].\n  final double min;\n\n  /// Maximum text scale factor for slider mode.\n  ///\n  /// Defaults to 2.0, which represents 200% of normal text size.\n  /// Should be greater than [min] to provide a meaningful range.\n  final double max;\n\n  /// Number of discrete steps in the slider control.\n  ///\n  /// Defaults to 6, providing smooth scaling transitions.\n  /// Higher values offer finer control but may be less practical for testing.\n  final int divisions;\n\n  @override\n  List<Field> get fields {\n    // Fallback to old implementation if scales are provided\n    if (scales != null) {\n      return [\n        ObjectDropdownField<double>(\n          name: 'factor',\n          values: scales!,\n          initialValue: initialScale ?? scales!.first,\n          labelBuilder: (scale) => scale.toStringAsFixed(2),\n        ),\n      ];\n    }\n\n    return [\n      DoubleSliderField(\n        name: 'factor',\n        initialValue: initialScale ?? 1.0,\n        min: min,\n        max: max,\n        divisions: divisions,\n        precision: 2,\n      ),\n    ];\n  }\n\n  @override\n  double valueFromQueryGroup(Map<String, String> group) {\n    return valueOf('factor', group)!;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    double setting,\n  ) {\n    return MediaQuery(\n      data: MediaQuery.of(context).copyWith(\n        textScaler: TextScaler.linear(setting),\n      ),\n      child: child,\n    );\n  }\n}\n"
      },
      "ThemeAddon": {
        "addon": "export 'cupertino_theme_addon.dart';\nexport 'material_theme_addon.dart';\nexport 'theme_addon.dart';\nexport 'widgetbook_theme.dart';\n",
        "cupertino_theme_addon": "import 'package:flutter/cupertino.dart';\n\nimport 'theme_addon.dart';\n\n/// A [ThemeAddon] for changing the active [CupertinoThemeData] via\n/// [CupertinoTheme].\n///\n/// Learn more: https://docs.widgetbook.io/addons/theme-addon#cupertino-theme\nclass CupertinoThemeAddon extends ThemeAddon<CupertinoThemeData> {\n  /// Creates a new instance of [CupertinoThemeAddon].\n  CupertinoThemeAddon({\n    required super.themes,\n    super.initialTheme,\n  }) : super(\n         themeBuilder: (context, theme, child) {\n           return CupertinoTheme(\n             data: theme,\n             child: ColoredBox(\n               color: theme.scaffoldBackgroundColor,\n               child: DefaultTextStyle(\n                 style: theme.textTheme.textStyle,\n                 child: child,\n               ),\n             ),\n           );\n         },\n       );\n}\n",
        "material_theme_addon": "import 'package:flutter/material.dart';\n\nimport 'addon.dart';\n\n/// A [ThemeAddon] for changing the active [ThemeData] via [Theme].\n///\n/// Learn more: https://docs.widgetbook.io/addons/theme-addon#material-theme\nclass MaterialThemeAddon extends ThemeAddon<ThemeData> {\n  /// Creates a new instance of [MaterialThemeAddon].\n  MaterialThemeAddon({\n    required super.themes,\n    super.initialTheme,\n  }) : super(\n         themeBuilder: (context, theme, child) {\n           return Theme(\n             data: theme,\n             child: ColoredBox(\n               color: theme.scaffoldBackgroundColor,\n               child: DefaultTextStyle(\n                 style: theme.textTheme.bodyMedium!,\n                 child: child,\n               ),\n             ),\n           );\n         },\n       );\n}\n",
        "theme_addon": "import 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\nimport 'addon.dart';\n\n/// Function signature for building themed widgets.\ntypedef ThemeBuilder<T> =\n    Widget Function(\n      BuildContext context,\n      T theme,\n      Widget child,\n    );\n\n/// A [WidgetbookAddon] for switching between different custom theme\n/// configurations.\n///\n/// [ThemeAddon] allows users to switch between predefined theme configurations\n/// in the Widgetbook interface. This is useful for testing widgets with different\n/// design system themes, custom branding, or any themed configuration.\n///\n/// Unlike [MaterialThemeAddon] and [CupertinoThemeAddon] which work with\n/// framework-specific themes, [ThemeAddon] is generic and can work with any\n/// custom theme system.\n///\n/// Learn more: https://docs.widgetbook.io/addons/theme-addon#custom-theme\nclass ThemeAddon<T> extends WidgetbookAddon<WidgetbookTheme<T>> {\n  /// Creates a new instance of [ThemeAddon].\n  ThemeAddon({\n    required this.themes,\n    this.initialTheme,\n    required this.themeBuilder,\n  }) : assert(\n         themes.isNotEmpty,\n         'themes cannot be empty',\n       ),\n       assert(\n         initialTheme == null || themes.contains(initialTheme),\n         'initialTheme must be in themes',\n       ),\n       super(\n         name: 'Theme',\n       );\n\n  /// Initial theme to display when the addon loads.\n  final WidgetbookTheme<T>? initialTheme;\n\n  /// A list of available themes.\n  final List<WidgetbookTheme<T>> themes;\n\n  /// A function that builds the themed widget.\n  final ThemeBuilder<T> themeBuilder;\n\n  @override\n  List<Field> get fields {\n    return [\n      ObjectDropdownField<WidgetbookTheme<T>>(\n        name: 'name',\n        values: themes,\n        initialValue: initialTheme ?? themes.first,\n        labelBuilder: (theme) => theme.name,\n      ),\n    ];\n  }\n\n  @override\n  WidgetbookTheme<T> valueFromQueryGroup(Map<String, String> group) {\n    return valueOf('name', group)!;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    WidgetbookTheme<T> setting,\n  ) {\n    return themeBuilder(\n      context,\n      setting.data,\n      child,\n    );\n  }\n}\n",
        "widgetbook_theme": "/// A class representing a theme in Widgetbook.\nclass WidgetbookTheme<T> {\n  /// Creates a new instance of [WidgetbookTheme].\n  const WidgetbookTheme({\n    required this.name,\n    required this.data,\n  });\n\n  /// The name of the theme.\n  final String name;\n\n  /// The theme data associated with this theme.\n  final T data;\n\n  @override\n  bool operator ==(covariant WidgetbookTheme<T> other) {\n    if (identical(this, other)) return true;\n\n    return other.name == name && other.data == data;\n  }\n\n  @override\n  int get hashCode => name.hashCode ^ data.hashCode;\n}\n"
      },
      "TimeDilationAddon": {
        "addon": "export 'time_dilation_addon.dart';\n",
        "time_dilation_addon": "import 'package:flutter/scheduler.dart';\nimport 'package:flutter/widgets.dart';\nimport 'package:meta/meta.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for controlling Flutter animation timing and speed.\n///\n/// The time dilation addon allows developers to slow down or speed up\n/// Flutter animations globally by modifying the [timeDilation] value.\n/// This is invaluable for debugging animations, testing transition timing,\n/// and creating detailed animation recordings.\n///\n/// Learn more: https://docs.widgetbook.io/addons/time-dilation-addon\n@experimental\nclass TimeDilationAddon extends WidgetbookAddon<double> {\n  /// Creates a new instance of [TimeDilationAddon].\n  TimeDilationAddon()\n    : super(\n        name: 'Time Dilation',\n      );\n\n  /// Predefined time dilation values for animation speed control.\n  static const values = <double>[0.25, 0.5, 1, 2, 4, 8, 16];\n\n  @override\n  List<Field> get fields {\n    return [\n      ObjectDropdownField<double>(\n        name: 'value',\n        values: values,\n        initialValue: 1,\n        labelBuilder: (scale) => scale.toStringAsFixed(2),\n      ),\n    ];\n  }\n\n  @override\n  double valueFromQueryGroup(Map<String, String> group) {\n    return valueOf('value', group)!;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    double setting,\n  ) {\n    timeDilation = setting;\n\n    return child;\n  }\n}\n"
      },
      "ViewportAddon": {
        "addon": "export 'viewport_addon.dart';\nexport 'viewport_data.dart';\nexport 'viewports/android_viewports.dart';\nexport 'viewports/ios_viewports.dart';\nexport 'viewports/linux_viewports.dart';\nexport 'viewports/macos_viewports.dart';\nexport 'viewports/viewports.dart';\nexport 'viewports/windows_viewports.dart';\n",
        "viewport": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\nimport 'package:nested/nested.dart';\n\nimport '../../widgetbook_theme.dart';\nimport 'viewport_data.dart';\n\n@internal\nclass Viewport extends StatelessWidget {\n  const Viewport({\n    super.key,\n    required this.data,\n    required this.frameless,\n    required this.child,\n  });\n\n  final ViewportData data;\n  final bool frameless;\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final mediaQuery = MediaQuery.of(context).copyWith(\n      size: data.size,\n      devicePixelRatio: data.pixelRatio,\n      padding: data.safeAreas,\n      viewPadding: data.safeAreas,\n    );\n\n    final theme = Theme.of(context).copyWith(\n      platform: data.platform,\n    );\n\n    return FittedBox(\n      child: Nested(\n        children: [\n          SingleChildBuilder(\n            builder: (context, child) {\n              // Exclude frame if frameless mode is enabled\n              return frameless\n                  ? child!\n                  : Padding(\n                      // Padding is needed to make sure that the frame's edge\n                      // is not on directly on the workbench's edge, but\n                      // we don't want that in the frameless mode\n                      padding: const EdgeInsets.all(16),\n                      child: _ViewportFrame(\n                        title: data.name,\n                        child: child!,\n                      ),\n                    );\n            },\n          ),\n        ],\n        child: SizedBox(\n          width: data.width,\n          height: data.height,\n          child: Theme(\n            data: theme,\n            child: MediaQuery(\n              data: mediaQuery,\n              child: Navigator(\n                // A navigator below the device frame is necessary to make\n                // the popup routes (e.g. dialogs and bottom sheets) work within\n                // the device frame, otherwise they would use the navigator from\n                // the app builder, causing these routes to fill the whole\n                // workbench and not just the device frame.\n                onGenerateRoute: (_) => PageRouteBuilder(\n                  pageBuilder: (context, _, __) => child,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A frame around the viewport that displays the viewport's title\n/// and a border around the viewport.\nclass _ViewportFrame extends StatelessWidget {\n  const _ViewportFrame({\n    required this.title,\n    required this.child,\n  });\n\n  final String title;\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final color = Colors.green;\n    final borderWidth = 2.0;\n\n    return Column(\n      mainAxisSize: MainAxisSize.min,\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Transform.translate(\n          offset: Offset(-borderWidth, 0),\n          child: Container(\n            color: color,\n            padding: const EdgeInsets.symmetric(\n              vertical: 4,\n              horizontal: 12,\n            ),\n            child: Text(\n              title,\n              style: WidgetbookTheme.of(context).textTheme.bodyMedium?.copyWith(\n                color: Colors.black87,\n              ),\n            ),\n          ),\n        ),\n        Container(\n          decoration: BoxDecoration(\n            border: Border.all(\n              color: color,\n              width: borderWidth,\n              strokeAlign: BorderSide.strokeAlignOutside,\n            ),\n          ),\n          child: child,\n        ),\n      ],\n    );\n  }\n}\n",
        "viewport_addon": "import 'package:flutter/material.dart' hide Viewport;\nimport 'package:widgetbook_annotation/widgetbook_annotation.dart';\n\nimport '../../fields/fields.dart';\nimport '../../state/state.dart';\nimport '../common/common.dart';\nimport 'viewport.dart';\nimport 'viewport_data.dart';\nimport 'viewports/viewports.dart';\n\n/// [AddonConfig] for the [ViewportAddon].\nclass ViewportAddonConfig extends AddonConfig<ViewportData> {\n  // NOTE: this cannot be defined in widgetbook_annotation because it depends on\n  // the ViewportData class which is defined in this file.\n  // If we add `widgetbook` as a dependency to `widgetbook_annotation`, then the\n  // `widgetbook_generator` will also depend on `widgetbook` which causes\n  // it to not work, as `widgetbook` has flutter as a dependency.\n\n  /// Creates a configuration for the [ViewportAddon] with the specified [data].\n  const ViewportAddonConfig(\n    ViewportData data,\n  ) : assert(\n        data is! NoneViewport,\n        '`NoneViewport` cannot be used in addon config',\n      ),\n      super(\n        'viewport',\n        // It would have been easier to parse the `data` to the string format\n        // that is required by the Cloud (i.e. \"id:${data.id},$meta{...}\")\n        // but we cannot do this here, because it's a constant class that\n        // is used as an annotation, so the parsing is done in the generator.\n        // For that reason, we have the generic parameter on AddonConfig.\n        data,\n      );\n}\n\n/// A [WidgetbookAddon] that allows switching between different viewports.\n///\n/// The [ViewportAddon] enables users to test their widgets on different screen\n/// sizes, from mobile phones to tablets and desktops. This is essential for\n/// responsive design testing.\n///\n/// Learn more: https://docs.widgetbook.io/addons/viewport-addon\nclass ViewportAddon extends WidgetbookAddon<ViewportData> {\n  /// Creates a new instance of [ViewportAddon].\n  ViewportAddon(this.viewports)\n    : super(\n        name: 'Viewport',\n      );\n\n  /// The list of available viewport options.\n  final List<ViewportData> viewports;\n\n  @override\n  List<Field> get fields => [\n    ObjectDropdownField<ViewportData>(\n      name: 'name',\n      initialValue: viewports.first,\n      values: viewports,\n      labelBuilder: (viewport) => viewport.name,\n    ),\n  ];\n\n  @override\n  ViewportData valueFromQueryGroup(Map<String, String> group) {\n    return valueOf<ViewportData>('name', group)!;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    ViewportData setting,\n  ) {\n    if (setting is NoneViewport) return child;\n\n    // Enable frameless mode if the preview mode is enabled\n    final frameless = WidgetbookState.of(context).previewMode;\n\n    return Center(\n      child: Viewport(\n        data: setting,\n        frameless: frameless,\n        child: child,\n      ),\n    );\n  }\n}\n",
        "viewport_data": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Data class representing a viewport configuration.\nclass ViewportData {\n  /// Creates a [ViewportData] instance.\n  const ViewportData({\n    required this.name,\n    required this.width,\n    required this.height,\n    required this.pixelRatio,\n    required this.platform,\n    this.safeAreas = EdgeInsets.zero,\n  });\n\n  /// The name of the viewport.\n  final String name;\n\n  /// The width of the viewport in logical pixels.\n  final double width;\n\n  /// The height of the viewport in logical pixels.\n  final double height;\n\n  /// The pixel ratio of the viewport.\n  final double pixelRatio;\n\n  /// The target platform for the viewport.\n  final TargetPlatform platform;\n\n  /// The safe areas for the viewport.\n  final EdgeInsets safeAreas;\n\n  /// Returns a [Size] object representing the size of the viewport.\n  Size get size => Size(width, height);\n}\n"
      },
      "ZoomAddon": {
        "addon": "export 'zoom_addon.dart';\n",
        "zoom_addon": "import 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../common/common.dart';\n\n/// A [WidgetbookAddon] for zoom/scaling the widget tree.\n///\n/// The zoom addon allows developers to scale the entire widget tree\n/// to test how components behave at different zoom levels.\n///\n/// Learn more: https://docs.widgetbook.io/addons/zoom-addon\nclass ZoomAddon extends WidgetbookAddon<double> {\n  /// Creates a new instance of [ZoomAddon].\n  ZoomAddon({\n    this.initialZoom = 1.0,\n  }) : super(\n         name: 'Zoom',\n       );\n\n  /// Initial zoom level to display when the addon loads.\n  final double initialZoom;\n\n  @override\n  List<Field> get fields => [\n    DoubleSliderField(\n      name: 'zoom',\n      initialValue: initialZoom,\n      min: 0.5,\n      max: 3.0,\n      divisions: 25,\n      precision: 2,\n    ),\n  ];\n\n  @override\n  double valueFromQueryGroup(Map<String, String> group) {\n    return valueOf('zoom', group)!;\n  }\n\n  @override\n  Widget buildUseCase(\n    BuildContext context,\n    Widget child,\n    double setting,\n  ) {\n    return Transform.scale(\n      scale: setting,\n      child: child,\n    );\n  }\n}\n"
      }
    },
    "Fields": {
      "BooleanField": {
        "boolean_field": "import 'package:flutter/material.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\n\n/// [Field] that builds [Switch] for [bool] values.\nclass BooleanField extends Field<bool> {\n  /// Creates a new instance of [BooleanField].\n  BooleanField({\n    required super.name,\n    super.initialValue = true,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         defaultValue: true,\n         type: FieldType.boolean,\n         codec: FieldCodec(\n           toParam: (value) => value.toString(),\n           toValue: (param) => param == null ? null : param == 'true',\n         ),\n       );\n\n  @override\n  Widget toWidget(BuildContext context, String group, bool? value) {\n    return Switch(\n      value: value ?? initialValue ?? true,\n      onChanged: (value) => updateField(context, group, value),\n    );\n  }\n}\n"
      },
      "ColorField": {
        "color_field": "import 'package:flutter/material.dart';\n\nimport '../field.dart';\nimport '../field_codec.dart';\nimport '../field_type.dart';\nimport 'color_picker.dart';\nimport 'color_space.dart';\n\nexport 'color_space.dart';\n\n/// [Field] that builds [ColorPicker] for [Color] values using the [ColorSpace]\n/// to determine which format the [Color] is.\nclass ColorField extends Field<Color> {\n  /// Creates a new instance of [ColorField].\n  ColorField({\n    required super.name,\n    super.initialValue = defaultColor,\n    this.initialColorSpace = ColorSpace.hex,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         defaultValue: defaultColor,\n         type: FieldType.color,\n         codec: FieldCodec(\n           toParam: (color) => color.toARGB32().toRadixString(16),\n           toValue: (param) {\n             if (param == null) return null;\n             if (param == '0') return Colors.transparent;\n             return Color(\n               int.parse(\n                 param.length == 6 ? '00$param' : param,\n                 radix: 16,\n               ),\n             );\n           },\n         ),\n       );\n\n  /// The initial color space to use for the color picker.\n  final ColorSpace initialColorSpace;\n\n  /// The default color used when no value is provided.\n  static const defaultColor = Colors.white;\n\n  @override\n  Widget toWidget(BuildContext context, String group, Color? value) {\n    return ColorPicker(\n      colorSpace: initialColorSpace,\n      value: value ?? defaultColor,\n      onChanged: (value) {\n        updateField(\n          context,\n          group,\n          value,\n        );\n      },\n    );\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'space': initialColorSpace.name,\n    };\n  }\n}\n",
        "color_picker": "import 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport 'color_picker_dialog.dart';\nimport 'color_space.dart';\nimport 'number_text_field.dart';\nimport 'opaque_color.dart';\nimport 'opaque_color_picker.dart';\n\n@internal\nclass ColorPicker extends StatefulWidget {\n  const ColorPicker({\n    required this.value,\n    super.key,\n    required this.colorSpace,\n    required this.onChanged,\n  });\n\n  final Color value;\n  final ColorSpace colorSpace;\n  final ValueChanged<Color> onChanged;\n\n  @override\n  State<ColorPicker> createState() => _ColorPickerState();\n}\n\nclass _ColorPickerState extends State<ColorPicker> {\n  Timer? _debounce;\n  late int alpha;\n  late ColorSpace colorSpace;\n  late OpaqueColor opaqueColor;\n\n  /// Key used to reset the state of the color space pickers when the color changes.\n  late Key pickerKey = ObjectKey(widget.value);\n\n  @override\n  void initState() {\n    super.initState();\n    alpha = (widget.value.a * 255).toInt();\n    colorSpace = widget.colorSpace;\n    opaqueColor = OpaqueColor.fromColor(widget.value);\n  }\n\n  @override\n  void dispose() {\n    _debounce?.cancel();\n    super.dispose();\n  }\n\n  void onChange(int newAlpha, OpaqueColor newColor, {bool debounce = false}) {\n    setState(() {\n      alpha = newAlpha;\n      opaqueColor = newColor;\n    });\n\n    _debounce?.cancel();\n    if (!debounce) {\n      widget.onChanged.call(newColor.toColor().withAlpha(newAlpha));\n    }\n    _debounce = Timer(const Duration(milliseconds: 100), () {\n      widget.onChanged.call(newColor.toColor().withAlpha(newAlpha));\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisSize: MainAxisSize.min,\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: [\n        Wrap(\n          spacing: 8,\n          runSpacing: 8,\n          children: [\n            Builder(\n              builder: (context) {\n                return InkWell(\n                  onTap: () {\n                    final box = context.findRenderObject() as RenderBox?;\n                    final position = box!.localToGlobal(Offset.zero) & box.size;\n\n                    showDialog<Color>(\n                      context: context,\n                      barrierColor: Colors.transparent,\n                      builder: (context) {\n                        return Stack(\n                          children: [\n                            PositionedPopUp(\n                              anchor: Offset(position.left - 28, position.top),\n                              child: ColorPickerDialog(\n                                initialColor: opaqueColor.toColor().withAlpha(\n                                  alpha,\n                                ),\n                                onChanged: (color) {\n                                  pickerKey = ObjectKey(color);\n                                  opaqueColor = OpaqueColor.fromColor(color);\n                                  alpha = color.a * 255 ~/ 1;\n                                  onChange(alpha, opaqueColor, debounce: true);\n                                },\n                              ),\n                            ),\n                          ],\n                        );\n                      },\n                    );\n                  },\n                  child: Container(\n                    padding: const EdgeInsets.all(12),\n                    decoration: BoxDecoration(\n                      color: Colors.white.withAlpha(46),\n                      borderRadius: BorderRadius.circular(4),\n                    ),\n                    child: Icon(\n                      Icons.square,\n                      color: opaqueColor.toColor().withAlpha(alpha),\n                    ),\n                  ),\n                );\n              },\n            ),\n            DropdownMenu<ColorSpace>(\n              width: 100,\n              initialSelection: colorSpace,\n              onSelected: (value) {\n                setState(() => colorSpace = value!);\n              },\n              dropdownMenuEntries: ColorSpace.values\n                  .map(\n                    (value) => DropdownMenuEntry(\n                      value: value,\n                      label: value.name.toUpperCase(),\n                    ),\n                  )\n                  .toList(),\n            ),\n            SizedBox(\n              width: 80,\n              child: NumberTextField.percentage(\n                key: pickerKey,\n                value: ((alpha / 255) * 100).toInt(),\n                onChanged: (value) {\n                  final newValue = (value / 100 * 255).round();\n                  setState(() => this.alpha = newValue);\n                  onChange(newValue, opaqueColor);\n                },\n              ),\n            ),\n          ],\n        ),\n        const SizedBox(height: 8),\n        OpaqueColorPicker.fromColorSpace(\n          colorSpace,\n          key: pickerKey,\n          value: opaqueColor,\n          onChanged: (value) {\n            setState(() => this.opaqueColor = value);\n            onChange(alpha, value);\n          },\n        ),\n      ],\n    );\n  }\n}\n\n@internal\nclass PositionedPopUp extends StatefulWidget {\n  const PositionedPopUp({\n    super.key,\n    required this.anchor,\n    required this.child,\n  });\n\n  final Offset anchor;\n  final Widget child;\n\n  @override\n  State<PositionedPopUp> createState() => _PositionedPopUpState();\n}\n\nclass _PositionedPopUpState extends State<PositionedPopUp> {\n  final key = GlobalKey();\n  Offset? offset;\n  Size? popupSize;\n\n  @override\n  void initState() {\n    super.initState();\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      final renderBox = key.currentContext?.findRenderObject() as RenderBox?;\n      if (renderBox != null) {\n        final size = renderBox.size;\n        final screen = MediaQuery.sizeOf(context);\n\n        var dx = widget.anchor.dx - size.width;\n        if (dx < 0) dx = 0.0;\n\n        var dy = widget.anchor.dy;\n        if (dy + size.height > screen.height) {\n          dy = screen.height - size.height;\n        }\n\n        setState(() {\n          offset = Offset(dx, dy);\n          popupSize = size;\n        });\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (offset == null) {\n      // Initial offscreen position for measuring\n      return Positioned(\n        key: key,\n        left: -1000,\n        top: -1000,\n        child: widget.child,\n      );\n    }\n\n    return Positioned(\n      left: offset!.dx,\n      top: offset!.dy,\n      child: widget.child,\n    );\n  }\n}\n",
        "color_picker_dialog": "import 'dart:ui' as ui;\n\nimport 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass ColorPickerDialog extends StatefulWidget {\n  const ColorPickerDialog({\n    super.key,\n    required this.initialColor,\n    this.onChanged,\n  });\n\n  final Color initialColor;\n  final void Function(Color)? onChanged;\n\n  @override\n  _ColorPickerDialogState createState() => _ColorPickerDialogState();\n}\n\nclass _ColorPickerDialogState extends State<ColorPickerDialog> {\n  double hue = 0.0;\n  double saturation = 1.0;\n  double value = 1.0;\n  double alpha = 1.0;\n\n  @override\n  void initState() {\n    super.initState();\n    final hsv = HSVColor.fromColor(widget.initialColor);\n    hue = hsv.hue;\n    saturation = hsv.saturation;\n    value = hsv.value;\n    alpha = widget.initialColor.a;\n  }\n\n  Color get currentColor {\n    return HSVColor.fromAHSV(alpha, hue, saturation, value).toColor();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Dialog(\n      insetPadding: EdgeInsets.zero,\n      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: LayoutBuilder(\n          builder: (context, constraints) {\n            return Column(\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                SizedBox.square(\n                  dimension: constraints.minWidth,\n                  child: Builder(\n                    builder: (context) {\n                      return GestureDetector(\n                        onPanDown: (e) => _handleSVGesture(\n                          e.localPosition,\n                          context,\n                        ),\n                        onPanUpdate: (e) => _handleSVGesture(\n                          e.localPosition,\n                          context,\n                        ),\n                        child: CustomPaint(\n                          painter: _SVPainter(hue, saturation, value),\n                        ),\n                      );\n                    },\n                  ),\n                ),\n                const SizedBox(height: 8),\n                SizedBox(\n                  width: constraints.minWidth,\n                  child: SizedBox(\n                    height: 16,\n                    child: LayoutBuilder(\n                      builder: (context, constraints) {\n                        return GestureDetector(\n                          onPanDown: (e) => _handleHueGesture(\n                            e.localPosition,\n                            constraints.minWidth,\n                          ),\n                          onPanUpdate: (e) => _handleHueGesture(\n                            e.localPosition,\n                            constraints.minWidth,\n                          ),\n                          child: CustomPaint(painter: _HuePainter(hue: hue)),\n                        );\n                      },\n                    ),\n                  ),\n                ),\n                const SizedBox(height: 16),\n                SizedBox(\n                  width: constraints.minWidth,\n                  child: SizedBox(\n                    height: 16,\n                    child: LayoutBuilder(\n                      builder: (context, constraints) {\n                        return GestureDetector(\n                          onPanDown: (e) => _handleAlphaGesture(\n                            e.localPosition,\n                            constraints.minWidth,\n                          ),\n                          onPanUpdate: (e) => _handleAlphaGesture(\n                            e.localPosition,\n                            constraints.minWidth,\n                          ),\n                          child: CustomPaint(\n                            painter: _OpacityPainter(\n                              opacity: alpha,\n                              color: currentColor,\n                            ),\n                          ),\n                        );\n                      },\n                    ),\n                  ),\n                ),\n                const SizedBox(height: 16),\n                Align(\n                  alignment: Alignment.centerLeft,\n                  child: Text(\n                    '#${currentColor.toARGB32().toRadixString(16).padLeft(8, '0').toUpperCase()}',\n                    style: Theme.of(context).textTheme.labelMedium?.copyWith(\n                      color: Colors.white,\n                      fontWeight: FontWeight.w600,\n                    ),\n                  ),\n                ),\n              ],\n            );\n          },\n        ),\n      ),\n    );\n  }\n\n  void _handleHueGesture(Offset localPos, double width) {\n    final x = localPos.dx.clamp(0.0, width);\n    final newHue = (360 * (x / width)).clamp(0.0, 360.0);\n    setState(() => hue = newHue);\n    widget.onChanged?.call(currentColor);\n  }\n\n  void _handleAlphaGesture(Offset localPos, double width) {\n    final x = localPos.dx.clamp(0.0, width);\n    final newOpacity = (x / width).clamp(0.0, 1.0);\n    setState(() => alpha = newOpacity);\n    widget.onChanged?.call(currentColor);\n  }\n\n  void _handleSVGesture(Offset localPos, BuildContext context) {\n    final renderBox = context.findRenderObject() as RenderBox?;\n    if (renderBox == null) return;\n    final size = renderBox.size;\n\n    final dx = localPos.dx.clamp(0.0, size.width);\n    final dy = localPos.dy.clamp(0.0, size.height);\n\n    final newS = (dx / size.width).clamp(0.0, 1.0);\n    final newV = (1 - (dy / size.height)).clamp(0.0, 1.0);\n\n    setState(() {\n      saturation = newS;\n      value = newV;\n    });\n    widget.onChanged?.call(currentColor);\n  }\n}\n\nclass _SVPainter extends CustomPainter {\n  _SVPainter(this.hue, this.saturation, this.value);\n\n  final double hue;\n  final double saturation;\n  final double value;\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    const radius = Radius.circular(8);\n    final rrect = RRect.fromRectAndRadius(rect, radius);\n\n    final color = HSVColor.fromAHSV(1.0, hue, 1.0, 1.0).toColor();\n    final paint = Paint()\n      ..shader = ui.Gradient.linear(rect.topLeft, rect.topRight, [\n        Colors.white,\n        color,\n      ]);\n    canvas.drawRRect(rrect, paint);\n\n    final paint2 = Paint()\n      ..shader = ui.Gradient.linear(rect.topLeft, rect.bottomLeft, [\n        Colors.transparent,\n        Colors.black,\n      ]);\n    canvas.drawRRect(rrect, paint2);\n\n    final selX = saturation * size.width;\n    final selY = (1 - value) * size.height;\n    final selectedColor = HSVColor.fromAHSV(\n      1.0,\n      hue,\n      saturation,\n      value,\n    ).toColor();\n\n    canvas.drawCircle(Offset(selX, selY), 8, Paint()..color = selectedColor);\n\n    canvas.drawCircle(\n      Offset(selX, selY),\n      6,\n      Paint()\n        ..style = PaintingStyle.stroke\n        ..strokeWidth = 4\n        ..color = Colors.white,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant _SVPainter old) =>\n      old.hue != hue || old.saturation != saturation || old.value != value;\n}\n\nclass _HuePainter extends CustomPainter {\n  _HuePainter({required this.hue});\n\n  final double hue;\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    const radius = Radius.circular(8);\n    final rrect = RRect.fromRectAndRadius(rect, radius);\n\n    final colors = List<Color>.generate(\n      361,\n      (i) => HSVColor.fromAHSV(1.0, i.toDouble(), 1.0, 1.0).toColor(),\n    );\n    final paint = Paint()\n      ..shader = ui.Gradient.linear(\n        rect.centerLeft,\n        rect.centerRight,\n        colors,\n        List.generate(colors.length, (i) => i / (colors.length - 1)),\n      );\n    canvas.drawRRect(rrect, paint);\n\n    final selX = (hue / 360) * size.width;\n    final selY = size.height / 2;\n    final selectedColor = HSVColor.fromAHSV(1.0, hue, 1.0, 1.0).toColor();\n\n    canvas.drawCircle(Offset(selX, selY), 6, Paint()..color = selectedColor);\n    canvas.drawCircle(\n      Offset(selX, selY),\n      6,\n      Paint()\n        ..style = PaintingStyle.stroke\n        ..strokeWidth = 4\n        ..color = Colors.white,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant _HuePainter old) => old.hue != hue;\n}\n\nclass _OpacityPainter extends CustomPainter {\n  _OpacityPainter({required this.color, required this.opacity});\n\n  final Color color;\n  final double opacity;\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final rect = Offset.zero & size;\n    const radius = Radius.circular(8);\n    final rrect = RRect.fromRectAndRadius(rect, radius);\n\n    // Clip only for background\n    canvas.save();\n    canvas.clipRRect(rrect);\n\n    const checkerSize = 8.0;\n    final paintChecker = Paint()..color = Colors.grey.shade300;\n    final paintCheckerDark = Paint()..color = Colors.grey.shade400;\n\n    for (double y = 0; y < size.height; y += checkerSize) {\n      for (double x = 0; x < size.width; x += checkerSize) {\n        final isDark =\n            ((x / checkerSize).floor() + (y / checkerSize).floor()) % 2 == 0;\n        final cellRect = Rect.fromLTWH(x, y, checkerSize, checkerSize);\n        final cellRRect = RRect.fromRectAndRadius(\n          cellRect,\n          const Radius.circular(2),\n        );\n        canvas.drawRRect(cellRRect, isDark ? paintCheckerDark : paintChecker);\n      }\n    }\n\n    final gradient = LinearGradient(\n      colors: [color.withAlpha(0), color.withAlpha(255)],\n    );\n    final paintGradient = Paint()..shader = gradient.createShader(rect);\n    canvas.drawRRect(rrect, paintGradient);\n\n    canvas.restore(); // Remove the clip\n\n    // Draw selector on top without clipping\n    final selX = opacity * size.width;\n    final selY = size.height / 2;\n    final selectedColor = color.withValues(alpha: opacity);\n\n    canvas.drawCircle(Offset(selX, selY), 6, Paint()..color = selectedColor);\n    canvas.drawCircle(\n      Offset(selX, selY),\n      6,\n      Paint()\n        ..style = PaintingStyle.stroke\n        ..strokeWidth = 4\n        ..color = Colors.white,\n    );\n  }\n\n  @override\n  bool shouldRepaint(covariant _OpacityPainter old) =>\n      old.opacity != opacity || old.color != color;\n}\n",
        "color_space": "/// Represents the different color space formats that can be used\n/// for color representation and conversion.\n///\n/// This enum defines the supported color spaces for color fields,\n/// allowing users to work with colors in their preferred format.\nenum ColorSpace {\n  /// Hexadecimal color representation (e.g., #FF0000 for red).\n  /// Uses base-16 notation with optional alpha channel.\n  hex,\n\n  /// Red, Green, Blue color space representation.\n  /// Values typically range from 0-255 for each component.\n  rgb,\n\n  /// Hue, Saturation, Lightness color space representation.\n  /// Hue ranges from 0-360 degrees, while saturation and lightness\n  /// range from 0-100 percent.\n  hsl,\n}\n",
        "hex_color_picker": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:meta/meta.dart';\n\nimport 'opaque_color.dart';\nimport 'opaque_color_picker.dart';\n\n@internal\nclass HexColorPicker extends StatelessWidget implements OpaqueColorPicker {\n  const HexColorPicker({\n    super.key,\n    required this.value,\n    required this.onChanged,\n  });\n\n  final OpaqueColor value;\n  final ValueChanged<OpaqueColor> onChanged;\n\n  String get hexValue =>\n      '${value.red.toRadixString(16).padLeft(2, '0')}'\n      '${value.green.toRadixString(16).padLeft(2, '0')}'\n      '${value.blue.toRadixString(16).padLeft(2, '0')}';\n\n  @override\n  Widget build(BuildContext context) {\n    return TextFormField(\n      initialValue: hexValue,\n      maxLength: 6,\n      decoration: const InputDecoration(\n        hintText: 'Enter a hex color',\n        counterText: '',\n        prefixText: '#',\n      ),\n      inputFormatters: [\n        FilteringTextInputFormatter.allow(\n          RegExp(r'[0-9a-fA-F]'),\n          replacementString: hexValue,\n        ),\n      ],\n      onChanged: (value) {\n        final source = int.tryParse(\n          value,\n          radix: 16,\n        );\n\n        if (value.length != 6 || source == null) return;\n        onChanged.call(OpaqueColor(source));\n      },\n    );\n  }\n}\n",
        "hsl_color_picker": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:meta/meta.dart';\n\nimport 'number_text_field.dart';\nimport 'opaque_color.dart';\nimport 'opaque_color_picker.dart';\n\n@internal\nclass HslColorPicker extends StatefulWidget implements OpaqueColorPicker {\n  const HslColorPicker({\n    super.key,\n    required this.value,\n    required this.onChanged,\n  });\n\n  final OpaqueColor value;\n  final ValueChanged<OpaqueColor> onChanged;\n\n  @override\n  State<HslColorPicker> createState() => _HslColorPickerState();\n}\n\nclass _HslColorPickerState extends State<HslColorPicker> {\n  late int hue;\n  late int saturation;\n  late int lightness;\n\n  @override\n  void initState() {\n    super.initState();\n\n    final hslColor = HSLColor.fromColor(\n      widget.value.toColor(),\n    );\n\n    hue = hslColor.hue.toInt();\n    saturation = (hslColor.saturation * 100).toInt();\n    lightness = (hslColor.lightness * 100).toInt();\n  }\n\n  void onValueChanged(\n    int newHue,\n    int newSaturation,\n    int newLightness,\n  ) {\n    setState(() {\n      hue = newHue;\n      saturation = newSaturation;\n      lightness = newLightness;\n    });\n\n    final newColor = HSLColor.fromAHSL(\n      1,\n      newHue.toDouble(),\n      newSaturation / 100,\n      newLightness / 100,\n    ).toColor();\n\n    widget.onChanged.call(\n      OpaqueColor.fromColor(newColor),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Expanded(\n          child: NumberTextField(\n            labelText: 'H',\n            value: hue,\n            maxLength: 3,\n            inputFormatters: [\n              FilteringTextInputFormatter.digitsOnly,\n              FilteringTextInputFormatter.allow(\n                RegExp(r'^(?:[0-9]\\d?|[12]\\d{2}|3[0-5]\\d)$'),\n                replacementString: '$hue',\n              ),\n            ],\n            onChanged: (value) {\n              onValueChanged(\n                value,\n                saturation,\n                lightness,\n              );\n            },\n          ),\n        ),\n        const SizedBox(\n          width: 8,\n        ),\n        Expanded(\n          child: NumberTextField.percentage(\n            labelText: 'S',\n            value: saturation,\n            onChanged: (value) {\n              onValueChanged(hue, value, lightness);\n            },\n          ),\n        ),\n        const SizedBox(\n          width: 8,\n        ),\n        Expanded(\n          child: NumberTextField.percentage(\n            labelText: 'L',\n            value: lightness,\n            onChanged: (value) {\n              onValueChanged(hue, saturation, value);\n            },\n          ),\n        ),\n      ],\n    );\n  }\n}\n",
        "number_text_field": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass NumberTextField extends StatelessWidget {\n  const NumberTextField({\n    super.key,\n    required this.value,\n    required this.maxLength,\n    this.inputFormatters,\n    this.suffixText,\n    this.labelText,\n    required this.onChanged,\n  });\n\n  NumberTextField.percentage({\n    super.key,\n    required this.value,\n    this.labelText,\n    required this.onChanged,\n  }) : maxLength = 3,\n       suffixText = '%',\n       inputFormatters = [\n         FilteringTextInputFormatter.digitsOnly,\n         FilteringTextInputFormatter.allow(\n           RegExp(r'^(0|[1-9][0-9]?|100)$'),\n           replacementString: '$value',\n         ),\n       ];\n\n  final int value;\n  final int maxLength;\n  final List<TextInputFormatter>? inputFormatters;\n  final String? suffixText;\n  final String? labelText;\n  final ValueChanged<int> onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return TextFormField(\n      initialValue: '$value',\n      inputFormatters: inputFormatters,\n      maxLength: maxLength,\n      onChanged: (value) {\n        final newValue = int.tryParse(value);\n        if (newValue == null) return;\n        onChanged(newValue);\n      },\n      decoration: InputDecoration(\n        hintText: 'Enter a number',\n        counterText: '',\n        labelText: labelText,\n        suffixText: suffixText,\n        suffixStyle: const TextStyle(\n          fontSize: 13,\n          fontWeight: FontWeight.w500,\n        ),\n      ),\n    );\n  }\n}\n",
        "opaque_color": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n/// Same as [Color] but without alpha channel.\n@internal\nclass OpaqueColor {\n  OpaqueColor(this.value) : assert(value >= 0 && value <= 0xffffff);\n\n  OpaqueColor.fromChannels({\n    required int red,\n    required int green,\n    required int blue,\n  }) : value = (red << 16) | (green << 8) | blue;\n\n  OpaqueColor.fromColor(\n    Color color,\n  ) : value = color.toARGB32() & 0xffffff;\n\n  final int value;\n\n  /// The red channel of this color in an 8 bit value.\n  int get red => (0xff0000 & value) >> 16;\n\n  /// The green channel of this color in an 8 bit value.\n  int get green => (0x00ff00 & value) >> 8;\n\n  /// The blue channel of this color in an 8 bit value.\n  int get blue => (0x0000ff & value) >> 0;\n\n  Color toColor() {\n    return Color(value | 0xff000000);\n  }\n}\n",
        "opaque_color_picker": "import 'package:flutter/widgets.dart';\nimport 'package:meta/meta.dart';\n\nimport 'color_space.dart';\nimport 'hex_color_picker.dart';\nimport 'hsl_color_picker.dart';\nimport 'opaque_color.dart';\nimport 'rgb_color_picker.dart';\n\n@internal\nabstract class OpaqueColorPicker extends Widget {\n  OpaqueColorPicker({\n    super.key,\n    required this.value,\n    required this.onChanged,\n  });\n\n  factory OpaqueColorPicker.fromColorSpace(\n    ColorSpace colorSpace, {\n    Key? key,\n    required OpaqueColor value,\n    required ValueChanged<OpaqueColor> onChanged,\n  }) {\n    switch (colorSpace) {\n      case ColorSpace.rgb:\n        return RgbColorPicker(\n          key: key,\n          value: value,\n          onChanged: onChanged,\n        );\n      case ColorSpace.hsl:\n        return HslColorPicker(\n          key: key,\n          value: value,\n          onChanged: onChanged,\n        );\n      case ColorSpace.hex:\n        return HexColorPicker(\n          key: key,\n          value: value,\n          onChanged: onChanged,\n        );\n    }\n  }\n\n  final OpaqueColor value;\n  final ValueChanged<OpaqueColor> onChanged;\n}\n",
        "rgb_color_picker": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:meta/meta.dart';\n\nimport 'number_text_field.dart';\nimport 'opaque_color.dart';\nimport 'opaque_color_picker.dart';\n\n@internal\nclass RgbColorPicker extends StatefulWidget implements OpaqueColorPicker {\n  const RgbColorPicker({\n    super.key,\n    required this.value,\n    required this.onChanged,\n  });\n\n  final OpaqueColor value;\n  final ValueChanged<OpaqueColor> onChanged;\n\n  @override\n  State<RgbColorPicker> createState() => _RgbColorPickerState();\n}\n\nclass _RgbColorPickerState extends State<RgbColorPicker> {\n  late int red;\n  late int green;\n  late int blue;\n\n  @override\n  void initState() {\n    super.initState();\n    red = widget.value.red;\n    green = widget.value.green;\n    blue = widget.value.blue;\n  }\n\n  void onValuesChanged(int newRed, int newGreen, int newBlue) {\n    setState(() {\n      red = newRed;\n      green = newGreen;\n      blue = newBlue;\n    });\n\n    widget.onChanged.call(\n      OpaqueColor.fromChannels(\n        red: newRed,\n        green: newGreen,\n        blue: newBlue,\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Expanded(\n          child: NumberTextField(\n            value: red,\n            maxLength: 3,\n            inputFormatters: [\n              FilteringTextInputFormatter.digitsOnly,\n              FilteringTextInputFormatter.allow(\n                RegExp(r'^(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$'),\n                replacementString: '$red',\n              ),\n            ],\n            labelText: 'R',\n            onChanged: (value) {\n              onValuesChanged(value, green, blue);\n            },\n          ),\n        ),\n        const SizedBox(\n          width: 8,\n        ),\n        Expanded(\n          child: NumberTextField(\n            value: green,\n            maxLength: 3,\n            inputFormatters: [\n              FilteringTextInputFormatter.digitsOnly,\n              FilteringTextInputFormatter.allow(\n                RegExp(r'^(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$'),\n                replacementString: '$green',\n              ),\n            ],\n            labelText: 'G',\n            onChanged: (value) {\n              onValuesChanged(red, value, blue);\n            },\n          ),\n        ),\n        const SizedBox(\n          width: 8,\n        ),\n        Expanded(\n          child: NumberTextField(\n            value: blue,\n            maxLength: 3,\n            inputFormatters: [\n              FilteringTextInputFormatter.digitsOnly,\n              FilteringTextInputFormatter.allow(\n                RegExp(r'^(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$'),\n                replacementString: '$blue',\n              ),\n            ],\n            labelText: 'B',\n            onChanged: (value) {\n              onValuesChanged(red, green, value);\n            },\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
      },
      "DateTimeField": {
        "date_time_field": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\n\n@internal\nextension DateTimeExtension on DateTime {\n  /// Converts the [DateTime] to a string object supported by the field\n  String toSimpleFormat() {\n    String pad(int value) {\n      return value.toString().padLeft(2, '0');\n    }\n\n    return '$year-${pad(month)}-${pad(day)} ${pad(hour)}:${pad(minute)}';\n  }\n}\n\n/// A [Field] that builds a [TextFormField] for [DateTime] values,\n/// allowing users to select a date and time using a date and time picker.\nclass DateTimeField extends Field<DateTime> {\n  /// Creates a new instance of [DateTimeField].\n  DateTimeField({\n    required super.name,\n    required super.initialValue,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n    required this.start,\n    required this.end,\n  }) : super(\n         defaultValue: start,\n         type: FieldType.dateTime,\n         codec: FieldCodec<DateTime>(\n           toParam: (value) => value.toSimpleFormat(),\n           toValue: (param) {\n             return param == null ? null : DateTime.tryParse(param);\n           },\n         ),\n       );\n\n  /// The starting [DateTime] value used for the date and time pickers.\n  final DateTime start;\n\n  /// The ending [DateTime] value used for the date and time pickers.\n  final DateTime end;\n\n  @override\n  Widget toWidget(BuildContext context, String group, DateTime? value) {\n    return TextFormField(\n      // The \"value\" used in the key ensures that the TextFormField is rebuilt\n      // when the value is changed via the DateTime picker. Without this\n      // unique key, the TextFormField will only react to value changes\n      // triggered by the user typing in the field.\n      key: ValueKey('$group-$name-$value'),\n      initialValue: (value ?? initialValue)?.toSimpleFormat(),\n      keyboardType: TextInputType.datetime,\n      decoration: InputDecoration(\n        hintText: 'Enter a DateTime',\n        suffixIcon: IconButton(\n          icon: const Icon(Icons.calendar_today_rounded),\n          onPressed: () async {\n            final dateTime = await showDateTimePicker(\n              context,\n              value ?? initialValue,\n            );\n\n            if (dateTime == null) return;\n\n            updateField(context, group, dateTime);\n          },\n        ),\n      ),\n      onChanged: (value) {\n        final dateTime = codec.toValue(value);\n        if (dateTime == null) return;\n\n        updateField(context, group, dateTime);\n      },\n    );\n  }\n\n  /// Shows a date and time picker dialog and returns the selected date and time\n  Future<DateTime?> showDateTimePicker(\n    BuildContext context, [\n    DateTime? value,\n  ]) async {\n    final initialDate = value ?? DateTime.now();\n\n    final date = await showDatePicker(\n      context: context,\n      initialDate: initialDate,\n      firstDate: start,\n      lastDate: end,\n    );\n    if (date == null) return null;\n\n    final time = await showTimePicker(\n      context: context,\n      initialTime: TimeOfDay.fromDateTime(initialDate),\n    );\n    if (time == null) return null;\n\n    return DateTime(\n      date.year,\n      date.month,\n      date.day,\n      time.hour,\n      time.minute,\n    );\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'start': codec.toParam(start),\n      'end': codec.toParam(end),\n    };\n  }\n}\n"
      },
      "DoubleInputField": {
        "double_input_field": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nimport 'field.dart';\nimport 'field_type.dart';\nimport 'num_input_field.dart';\n\n/// A [Field] that builds [TextFormField] for [double] values.\nclass DoubleInputField extends NumInputField<double> {\n  /// Creates a new instance of [DoubleInputField].\n  DoubleInputField({\n    required super.name,\n    super.initialValue = 0,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         type: FieldType.doubleInput,\n         formatters: [\n           FilteringTextInputFormatter.allow(\n             RegExp(r'^-?\\d*\\.?\\d*'),\n           ),\n         ],\n       );\n}\n"
      },
      "DoubleSliderField": {
        "double_slider_field": "import 'package:flutter/material.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\nimport 'num_slider_field.dart';\n\n/// A [Field] that builds [Slider] for [double] values.\nclass DoubleSliderField extends NumSliderField<double> {\n  /// Creates a new instance of [DoubleSliderField].\n  DoubleSliderField({\n    required super.name,\n    super.initialValue = 0,\n    required super.min,\n    required super.max,\n    this.divisions,\n    this.precision = 1,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         type: FieldType.doubleSlider,\n         codec: FieldCodec(\n           toParam: (value) {\n             if (precision != null) return value.toStringAsFixed(precision);\n             return value.toString();\n           },\n           toValue: (param) => double.tryParse(param ?? ''),\n         ),\n       );\n\n  final int? divisions;\n\n  /// The number of decimal places to display and return.\n  final int? precision;\n}\n"
      },
      "DurationField": {
        "duration_field": "import 'package:flutter/material.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\n\n/// A [Field] that represents a [Duration] value.\nclass DurationField extends Field<Duration> {\n  /// Creates a new instance of [DurationField].\n  DurationField({\n    required super.name,\n    super.initialValue = defaultDuration,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         defaultValue: defaultDuration,\n         type: FieldType.duration,\n         codec: FieldCodec(\n           toParam: (value) => value.inMilliseconds.toString(),\n           toValue: (param) {\n             return param == null\n                 ? null\n                 : Duration(\n                     milliseconds: int.tryParse(param) ?? 0,\n                   );\n           },\n         ),\n       );\n\n  /// The default duration value used when no initial value is provided.\n  static const defaultDuration = Duration.zero;\n\n  @override\n  Widget toWidget(\n    BuildContext context,\n    String group,\n    Duration? value,\n  ) {\n    return TextFormField(\n      initialValue: codec.toParam(value ?? initialValue ?? defaultDuration),\n      keyboardType: TextInputType.number,\n      decoration: const InputDecoration(\n        hintText: 'Enter a duration',\n        suffix: Text('ms'),\n      ),\n      onChanged: (value) {\n        final duration = codec.toValue(value);\n        if (duration == null) return;\n\n        updateField(context, group, duration);\n      },\n    );\n  }\n}\n"
      },
      "Field": {
        "field": "import 'package:flutter/material.dart';\n\nimport '../state/state.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\n\n/// Base class for all input fields in Widgetbook.\n///\n/// [Field]s represent configurable inputs that appear in the settings panel\n/// and allow users to customize addon behavior or knob values. Each field\n/// can be serialized to JSON and synchronized with URL query parameters,\n/// making the state shareable and persistent.\n///\n/// Fields are converted to:\n/// 1. [Widget] through [toWidget] - used to display the input control in the settings panel\n/// 2. [Map] through [toJson] - used to serialize the field configuration\n///\n/// Fields sync their changes with [WidgetbookState], which keeps them\n/// synchronized with URL query parameters. A [Field] is encoded into query\n/// parameters using a JSON-like format (e.g. `/?foo={bar:qux}`):\n///\n/// | Part   | Value |\n/// | :----  | :---- |\n/// | group  | `foo` |\n/// | [name] | `bar` |\n/// | value  | `qux` |\n@optionalTypeArgs\nabstract class Field<T> {\n  /// Creates a [Field] with the specified configuration.\n  const Field({\n    required this.name,\n    required this.type,\n    required this.initialValue,\n    required this.defaultValue,\n    required this.codec,\n    @Deprecated('Fields should not be aware of their context') this.onChanged,\n  });\n\n  /// Symbol used to represent nullable values in query parameters.\n  static const nullabilitySymbol = '??';\n\n  /// The unique identifier for this field within its group.\n  final String name;\n\n  /// Metadata about the field type.\n  ///\n  /// This helps external tools (like Widgetbook Cloud) understand what kind\n  /// of input control to render for this field.\n  final FieldType type;\n\n  /// The default value when no value is specified.\n  ///\n  /// This value is used when the field is first created or when the\n  /// query parameters don't contain a value for this field.\n  final T? initialValue;\n\n  /// The default value when the field has a null initialValue.\n  ///\n  /// This is useful for fields that are nullable and are toggled to non-null.\n  final T defaultValue;\n\n  /// Handles encoding and decoding field values to/from strings.\n  final FieldCodec<T> codec;\n\n  /// Converts the [defaultValue] to a string using the [codec].\n  String get defaultValueStringified => codec.toParam(defaultValue);\n\n  /// Converts the [initialValue] to a string using the [codec].\n  String? get initialValueStringified =>\n      initialValue == null ? null : codec.toParam(initialValue! as T);\n\n  /// @nodoc\n  @Deprecated('Fields should not be aware of their context')\n  final void Function(BuildContext context, T? value)? onChanged;\n\n  /// A field is considered nullable if the param's value starts\n  /// with [nullabilitySymbol].\n  bool isNull(Map<String, String> groupMap) {\n    final param = groupMap[name];\n    return param?.startsWith(nullabilitySymbol) ?? false;\n  }\n\n  /// Extracts the value from [groupMap],\n  /// fallback to [initialValue] if not found.\n  /// If the field value starts with [nullabilitySymbol], it will be\n  /// interpreted as null.\n  T? valueFrom(Map<String, String> groupMap) {\n    if (isNull(groupMap)) return null;\n    return codec.toValue(groupMap[name]) ?? initialValue;\n  }\n\n  /// Builds the current field into a [Widget] using [toWidget].\n  Widget build(BuildContext context, String group) {\n    final state = WidgetbookState.of(context);\n    final groupMap = FieldCodec.decodeQueryGroup(state.queryParams[group]);\n    final value = valueFrom(groupMap);\n\n    return toWidget(context, group, value);\n  }\n\n  /// Converts this field into a [Widget] that can be used in the\n  /// settings panel.\n  Widget toWidget(BuildContext context, String group, T? value);\n\n  /// Updates the field value in the [WidgetbookState] and synchronizes it\n  /// with the URL query parameters.\n  void updateField(BuildContext context, String group, T value) {\n    final state = WidgetbookState.of(context);\n    final stringifiedValue = codec.toParam(value);\n\n    state.updateQueryField(\n      group: group,\n      field: name,\n      value: stringifiedValue,\n    );\n  }\n\n  /// Same as [toJson] put prepends some metadata like [name], [type] and value.\n  Map<String, dynamic> toFullJson() {\n    final _value = initialValue; // local variable promotion\n\n    return {\n      'name': name,\n      'type': type.name,\n      'value': _value == null ? null : codec.toParam(_value),\n      ...toJson(),\n    };\n  }\n\n  /// Converts this into JSON representation share information about the\n  /// available fields. Mostly used to support [Field]s on Widgetbook Cloud.\n  Map<String, dynamic> toJson() => {};\n}\n"
      },
      "Fields": {
        "fields": "export 'boolean_field.dart';\nexport 'color_field/color_field.dart';\nexport 'date_time_field.dart';\nexport 'double_input_field.dart';\nexport 'double_slider_field.dart';\nexport 'duration_field.dart';\nexport 'field.dart';\nexport 'field_codec.dart';\nexport 'field_type.dart';\nexport 'fields_composable.dart';\nexport 'int_input_field.dart';\nexport 'int_slider_field.dart';\nexport 'iterable_segmented_field.dart';\nexport 'object_dropdown_field.dart';\nexport 'object_segmented_field.dart';\nexport 'string_field.dart';\n"
      },
      "FieldsComposable": {
        "fields_composable": "import 'package:flutter/widgets.dart';\n\nimport '../settings/settings.dart';\nimport '../state/state.dart';\nimport 'field.dart';\nimport 'field_codec.dart';\n\n/// A [FieldsComposable] is a collection or a group of [Field]s that can be used\n/// to create a settings panel in Widgetbook. Each field in the group should have\n/// a unique [name] and can be used to configure addons or knobs.\nabstract class FieldsComposable<T> {\n  /// Creates a [FieldsComposable] with the specified configuration.\n  const FieldsComposable({\n    required this.name,\n    this.description,\n    this.isNullable = false,\n  });\n\n  /// The display name of the composable group.\n  final String name;\n\n  /// The description of the composable group.\n  final String? description;\n\n  /// Whether this composable group is nullable.\n  final bool isNullable;\n\n  /// The name of the query group param.\n  String get groupName;\n\n  /// A list of [Field]s that belong to this composable group.\n  List<Field> get fields;\n\n  /// Converts the [name] to a slugified version that can be used in query\n  /// parameters.\n  String slugify(String name) {\n    return name.trim().toLowerCase().replaceAll(RegExp(' '), '-');\n  }\n\n  /// Converts a query group to a value of type [T].\n  T valueFromQueryGroup(Map<String, String> group);\n\n  /// Converts the [fields] into a [Widget] that will be rendered in the\n  /// settings side panel.\n  Widget buildFields(BuildContext context) {\n    final child = Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: fields\n          .map(\n            (field) => Padding(\n              padding: const EdgeInsets.symmetric(\n                vertical: 4.0,\n              ),\n              child: field.build(context, groupName),\n            ),\n          )\n          .toList(),\n    );\n\n    return !isNullable\n        ? Setting(\n            name: name,\n            description: description,\n            child: child,\n          )\n        : NullableSetting(\n            name: name,\n            description: description,\n            isNullified: isNullified(context),\n            onNullified: (isNullified) => toggleNullification(\n              context,\n              nullify: isNullified,\n            ),\n            child: child,\n          );\n  }\n\n  /// Decodes the value of the [Field] with [name] from the query [group]\n  /// using the [FieldCodec.toValue] from [Field.codec].\n  TField? valueOf<TField>(String name, Map<String, String> group) {\n    final field =\n        fields.firstWhere(\n              (field) => field.name == name,\n            )\n            as Field<TField>;\n\n    return field.valueFrom(group);\n  }\n\n  /// Whether the group has been nullified by [toggleNullification].\n  bool isNullified(BuildContext context) {\n    final state = WidgetbookState.of(context);\n    final groupMap = FieldCodec.decodeQueryGroup(\n      state.queryParams[groupName],\n    );\n\n    return fields.every(\n      (field) => field.valueFrom(groupMap) == null,\n    );\n  }\n\n  /// Adds/removes [Field.nullabilitySymbol] to/from all [fields] depending on\n  /// the [nullify] state.\n  /// If [nullify] is `true`, the [Field.nullabilitySymbol] is added.\n  /// If [nullify] is `false`, the [Field.nullabilitySymbol] is removed.\n  @protected\n  void toggleNullification(\n    BuildContext context, {\n    required bool nullify,\n  }) {\n    assert(\n      isNullable,\n      'toggleNullification is only available for nullable composables',\n    );\n\n    // NOTE:\n    // Currently, we are nullifying the [FieldsComposable] by nullifying all\n    // the fields in the group. A better approach would be by nullifying the\n    // group itself only (for example: `group={...}` > `group=?{...}).\n    // This approach is not currently feasible as all knobs are located under\n    // the same group. This is a limitation of the current implementation.\n    // We can revisit in future major releases.\n\n    final state = WidgetbookState.of(context);\n    final groupMap = FieldCodec.decodeQueryGroup(\n      state.queryParams[groupName],\n    );\n\n    fields.forEach((field) {\n      // If the field is not present in the `groupMap`, we set it to its\n      // initial value or default value.\n      //\n      // This is used when user first interacts with a nullable field.\n      if (!groupMap.containsKey(field.name)) {\n        final value =\n            field.initialValueStringified ?? field.defaultValueStringified;\n        state.updateQueryField(\n          group: groupName,\n          field: field.name,\n          value: nullify ? '${Field.nullabilitySymbol}${value}' : value,\n        );\n        return;\n      }\n\n      final value = groupMap[field.name];\n      if (value == null) return;\n\n      final rawValue = value.replaceFirst(Field.nullabilitySymbol, '');\n      final nullishValue = '${Field.nullabilitySymbol}$rawValue';\n\n      state.updateQueryField(\n        group: groupName,\n        field: field.name,\n        value: nullify ? nullishValue : rawValue,\n      );\n    });\n  }\n\n  /// Converts this composable group to a JSON representation.\n  Map<String, dynamic> toJson();\n}\n"
      },
      "FieldCodec": {
        "field_codec": "/// A codec for encoding and decoding field values to and from query parameters.\nclass FieldCodec<T> {\n  /// Creates a [FieldCodec] with the specified encoding and decoding functions.\n  const FieldCodec({\n    required this.toParam,\n    required this.toValue,\n  });\n\n  /// Encoder for converting value of type [T] to a query parameter.\n  final String Function(T value) toParam;\n\n  /// Decoders for converting a query parameter to a value of type [T].\n  final T? Function(String? param) toValue;\n\n  /// Encodes a query group into a JSON-like representation.\n  ///\n  /// Example:\n  ///\n  /// ```\n  /// final queryGroup = {\n  ///   'foo': 'bar',\n  ///   'baz': 'qux',\n  /// };\n  ///\n  /// final encoded = FieldCodec.encodeQueryGroup(queryGroup);\n  ///\n  /// print(encoded); // {foo:bar,baz:qux}\n  /// ```\n  static String encodeQueryGroup(Map<String, String> group) {\n    final pairs = group.entries.map((entry) {\n      // Both key and value are encoded to ensure that reserved\n      // characters (e.g. `:`, `{`, `}` and `,`) are not misinterpreted.\n      // For example, using a comma in a string value or a colon\n      // in a date value would break the decoding process.\n      final encodedKey = Uri.encodeComponent(entry.key);\n      final encodedValue = Uri.encodeComponent(entry.value);\n\n      return '$encodedKey:$encodedValue';\n    });\n\n    return '{${pairs.join(',')}}';\n  }\n\n  /// Decodes [component] using [Uri.decodeComponent],\n  /// but returns null if the decoding fails due to non-ASCII characters.\n  static String? tryDecodeComponent(String component) {\n    try {\n      return Uri.decodeComponent(component);\n    } on ArgumentError {\n      return null;\n    }\n  }\n\n  /// Decodes a query group encoded value back to a [Map].\n  static Map<String, String> decodeQueryGroup(String? group) {\n    if (group == null || group == '{}') return {};\n\n    final params = group\n        .substring(1, group.length - 1)\n        .split(RegExp(r',(?![^\\[]*\\])'));\n\n    return Map<String, String>.fromEntries(\n      params.map(\n        (param) {\n          final parts = param.split(':');\n          final decodedKey = tryDecodeComponent(parts[0]);\n          final decodedValue = tryDecodeComponent(parts[1]);\n\n          return MapEntry(decodedKey ?? parts[0], decodedValue ?? parts[1]);\n        },\n      ),\n    );\n  }\n}\n"
      },
      "FieldType": {
        "field_type": "import 'dart:ui';\n\n/// Defines the available field types that can be used in Widgetbook for\n/// creating interactive controls in the UI.\nenum FieldType {\n  /// For fields that have a [boolean] value.\n  boolean,\n\n  /// For fields that have a [Color] value.\n  color,\n\n  /// For fields that have a [double] value, represented as a slider.\n  doubleSlider,\n\n  /// For fields that have a [double] value, represented as an input field.\n  doubleInput,\n\n  /// For fields that have a [String] value.\n  string,\n\n  /// For fields that have a [Duration] value.\n  duration,\n\n  /// For fields that have a [DateTime] value.\n  dateTime,\n\n  /// For fields that have a [int] value, represented as a slider.\n  intInput,\n\n  /// For fields that have a [int] value, represented as an input field.\n  intSlider,\n\n  /// @nodoc\n  @Deprecated('Use `objectDropdown` instead.')\n  list,\n\n  /// For fields that have a [Object] value, represented as a dropdown.\n  objectDropdown,\n\n  /// For fields that have a [Object] value, represented as a segmented button.\n  objectSegmented,\n\n  /// For fields that have a [Iterable] value, represented as a segmented button.\n  iterableSegmented,\n}\n"
      },
      "IntInputField": {
        "int_input_field": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nimport 'field.dart';\nimport 'field_type.dart';\nimport 'num_input_field.dart';\n\n/// A [Field] that builds [TextFormField] for [int] values.\nclass IntInputField extends NumInputField<int> {\n  /// Creates a new instance of [IntInputField].\n  IntInputField({\n    required super.name,\n    super.initialValue = 0,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         type: FieldType.intInput,\n         formatters: [\n           FilteringTextInputFormatter.allow(\n             RegExp(r'^-?\\d*'),\n           ),\n         ],\n       );\n}\n"
      },
      "IntSliderField": {
        "int_slider_field": "import 'package:flutter/material.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\nimport 'num_slider_field.dart';\n\n/// A [Field] that builds [Slider] for [int] values.\nclass IntSliderField extends NumSliderField<int> {\n  /// Creates a new instance of [IntSliderField].\n  IntSliderField({\n    required super.name,\n    super.initialValue = 0,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n    required super.min,\n    required super.max,\n    this.divisions,\n  }) : super(\n         type: FieldType.intSlider,\n         codec: FieldCodec<int>(\n           toParam: (value) => value.toString(),\n           toValue: (param) => double.tryParse(param ?? '')?.round(),\n         ),\n       );\n\n  final int? divisions;\n}\n"
      },
      "IterableSegmentedField": {
        "iterable_segmented_field": "import 'package:collection/collection.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fields.dart';\n\n/// A [Field] that builds [SegmentedButton]<[Iterable<T>]> for [Iterable] values.\nclass IterableSegmentedField<T> extends Field<Iterable<T>> {\n  /// Creates a new instance of [IterableSegmentedField].\n  IterableSegmentedField({\n    required super.name,\n    required this.values,\n    required super.initialValue,\n    this.labelBuilder = defaultLabelBuilder,\n    this.emptySelectionAllowed = true,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         defaultValue: values,\n         type: FieldType.iterableSegmented,\n         codec: FieldCodec(\n           toParam: (value) => \"[${value.map(labelBuilder).join(',')}]\",\n           toValue: (param) {\n             if (param == null) return null;\n             if (!param.startsWith('[') || !param.endsWith(']')) {\n               throw Exception(\n                 'Invalid parameter format: $param. Expected format: [item1,item2,...]',\n               );\n             }\n\n             final parsedParam = param.substring(1, param.length - 1);\n             if (parsedParam.isEmpty) return [];\n\n             return parsedParam\n                 .split(',')\n                 .map(\n                   (item) => values.firstWhereOrNull(\n                     (value) => labelBuilder(value) == item,\n                   ),\n                 )\n                 .whereType<T>();\n           },\n         ),\n       );\n\n  /// The list of values to display in the segmented button.\n  final Iterable<T> values;\n\n  /// The function to build the label for each value in the segmented button.\n  final LabelBuilder<T> labelBuilder;\n\n  /// The default label builder that converts the value to a string.\n  static String defaultLabelBuilder(dynamic value) {\n    return value.toString();\n  }\n\n  /// Whether empty selection is allowed. InitialOption must not be empty if this is false.\n  final bool emptySelectionAllowed;\n\n  @override\n  Widget toWidget(BuildContext context, String group, Iterable<T>? value) {\n    return SegmentedButton<T>(\n      selected: value?.toSet() ?? {},\n      multiSelectionEnabled: true,\n      emptySelectionAllowed: emptySelectionAllowed,\n      onSelectionChanged: (newValue) {\n        updateField(context, group, newValue);\n      },\n      segments: values\n          .map(\n            (value) => ButtonSegment<T>(\n              value: value,\n              label: Text(labelBuilder(value)),\n            ),\n          )\n          .toList(),\n    );\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {'values': codec.toParam(values)};\n  }\n}\n"
      },
      "NumInputField": {
        "num_input_field": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\n\n/// A base class for [Field]s that represent [num] values using a [TextField].\nclass NumInputField<T extends num> extends Field<T> {\n  /// Creates a new instance of [NumInputField].\n  NumInputField({\n    required super.name,\n    super.initialValue,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n    required super.type,\n    required this.formatters,\n  }) : super(\n         defaultValue: (T == int ? 0 : 0.0) as T,\n         codec: FieldCodec<T>(\n           toParam: (value) => value.toString(),\n           toValue: (param) =>\n               (T == int\n                       ? int.tryParse(param ?? '')\n                       : double.tryParse(param ?? ''))\n                   as T?,\n         ),\n       );\n\n  /// The list of input formatters to apply to the text input.\n  final List<TextInputFormatter> formatters;\n\n  @override\n  Widget toWidget(BuildContext context, String group, T? value) {\n    final defaultValue = (T == int ? 0 : 0.0) as T;\n\n    return TextFormField(\n      initialValue: codec.toParam(value ?? initialValue ?? defaultValue),\n      keyboardType: TextInputType.number,\n      inputFormatters: formatters,\n      decoration: const InputDecoration(\n        hintText: 'Enter a number',\n      ),\n      onChanged: (value) {\n        final number = codec.toValue(value);\n        if (number == null) return;\n\n        updateField(context, group, number);\n      },\n    );\n  }\n}\n"
      },
      "NumSliderField": {
        "num_slider_field": "import 'package:flutter/material.dart';\n\nimport 'field.dart';\n\n/// A base class for [Field]s that represent [num] values using a slider.\nclass NumSliderField<T extends num> extends Field<T> {\n  /// Creates a new instance of [NumSliderField].\n  NumSliderField({\n    required super.name,\n    this.divisions,\n    super.initialValue,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n    required this.min,\n    required this.max,\n    required super.codec,\n    required super.type,\n  }) : assert(\n         initialValue == null || (initialValue >= min && initialValue <= max),\n       ),\n       super(defaultValue: min);\n\n  /// The minimum value of the slider.\n  final T min;\n\n  /// The maximum value of the slider.\n  final T max;\n\n  /// The number of discrete divisions in the slider.\n  final int? divisions;\n\n  Size _getTextSize(String text, TextStyle style) {\n    final textPainter = TextPainter(\n      text: TextSpan(text: text, style: style),\n      maxLines: 1,\n      textDirection: TextDirection.ltr,\n    )..layout();\n    return textPainter.size;\n  }\n\n  @override\n  Widget toWidget(BuildContext context, String group, T? value) {\n    final defaultValue = (T == int ? 0 : 0.0) as T;\n    final label = codec.toParam(value ?? initialValue ?? defaultValue);\n    final maxLabel = codec.toParam(max);\n\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceBetween,\n      spacing:\n          SliderTheme.of(context).overlayShape == SliderComponentShape.noThumb\n          ? 16\n          : 0,\n      children: [\n        Expanded(\n          child: Slider(\n            value: ((value ?? initialValue)?.toDouble() ?? 0).clamp(\n              min.toDouble(),\n              max.toDouble(),\n            ),\n            min: min.toDouble(),\n            max: max.toDouble(),\n            label: label,\n            divisions: divisions,\n            onChanged: (value) {\n              return updateField(\n                context,\n                group,\n                codec.toValue(value.toString())!,\n              );\n            },\n          ),\n        ),\n        SizedBox(\n          width: _getTextSize(\n            maxLabel,\n            DefaultTextStyle.of(context).style,\n          ).width,\n          child: Text(\n            label,\n            textAlign: TextAlign.end,\n            maxLines: 1,\n          ),\n        ),\n      ],\n    );\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'min': min,\n      'max': max,\n      'divisions': divisions,\n    };\n  }\n}\n"
      },
      "ObjectDropdownField": {
        "object_dropdown_field": "import 'package:collection/collection.dart';\nimport 'package:flutter/material.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\n\n/// @nodoc\ntypedef LabelBuilder<T> = String Function(T value);\n\n// For backward compatibility, a type alias is used to maintain the old name.\n/// @nodoc\n@Deprecated('ListField is deprecated, use ObjectDropdownField instead.')\ntypedef ListField<T> = ObjectDropdownField<T>;\n\n/// A [Field] that builds [DropdownMenu]<[T]> for [Object] values.\nclass ObjectDropdownField<T> extends Field<T> {\n  /// Creates a new instance of [ObjectDropdownField].\n  ObjectDropdownField({\n    required super.name,\n    required this.values,\n    required super.initialValue,\n    this.labelBuilder = defaultLabelBuilder,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         defaultValue: values.first,\n         type: FieldType.objectDropdown,\n         codec: FieldCodec(\n           toParam: labelBuilder,\n           toValue: (param) => values.firstWhereOrNull(\n             (value) => labelBuilder(value) == param,\n           ),\n         ),\n       );\n\n  /// The list of values to display in the dropdown.\n  final List<T> values;\n\n  /// The function to build the label for each value in the dropdown.\n  final LabelBuilder<T> labelBuilder;\n\n  /// The default label builder that converts the value to a string.\n  static String defaultLabelBuilder(dynamic value) {\n    return value.toString();\n  }\n\n  @override\n  Widget toWidget(BuildContext context, String group, T? value) {\n    return DropdownMenu<T>(\n      expandedInsets: EdgeInsets.zero,\n      trailingIcon: const Icon(Icons.keyboard_arrow_down_rounded),\n      selectedTrailingIcon: const Icon(Icons.keyboard_arrow_up_rounded),\n      initialSelection: value,\n      onSelected: (value) {\n        if (value != null) {\n          updateField(context, group, value);\n        }\n      },\n      dropdownMenuEntries: values\n          .map(\n            (value) => DropdownMenuEntry(\n              value: value,\n              label: labelBuilder(value),\n            ),\n          )\n          .toList(),\n    );\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'values': values.map((codec.toParam)).toList(),\n    };\n  }\n}\n"
      },
      "ObjectSegmentedField": {
        "object_segmented_field": "import 'package:collection/collection.dart';\nimport 'package:flutter/material.dart';\n\nimport '../../widgetbook.dart';\n\n/// A [Field] that builds [SegmentedButton]<[T]> for [Object] values.\nclass ObjectSegmentedField<T> extends Field<T> {\n  /// Creates a new instance of [ObjectSegmentedField].\n  ObjectSegmentedField({\n    required super.name,\n    required this.values,\n    required super.initialValue,\n    this.labelBuilder = defaultLabelBuilder,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         defaultValue: values.first,\n         type: FieldType.objectSegmented,\n         codec: FieldCodec(\n           toParam: labelBuilder,\n           toValue: (param) => values.firstWhereOrNull(\n             (value) => labelBuilder(value) == param,\n           ),\n         ),\n       );\n\n  /// The list of values to display in the segmented button.\n  final List<T> values;\n\n  /// The function to build the label for each value in the segmented button.\n  final LabelBuilder<T> labelBuilder;\n\n  /// The default label builder that converts the value to a string.\n  static String defaultLabelBuilder(dynamic value) {\n    return value.toString();\n  }\n\n  @override\n  Widget toWidget(BuildContext context, String group, T? value) {\n    return SegmentedButton<T>(\n      selected: value != null ? {value} : {},\n      emptySelectionAllowed: value == null,\n      onSelectionChanged: (newValue) {\n        if (newValue.isNotEmpty) {\n          updateField(context, group, newValue.first);\n        }\n      },\n      segments: values\n          .map(\n            (value) => ButtonSegment<T>(\n              value: value,\n              label: Text(labelBuilder(value)),\n            ),\n          )\n          .toList(),\n    );\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'values': values.map((codec.toParam)).toList(),\n    };\n  }\n}\n"
      },
      "StringField": {
        "string_field": "import 'package:flutter/material.dart';\n\nimport 'field.dart';\nimport 'field_codec.dart';\nimport 'field_type.dart';\n\n/// A [Field] that builds [TextFormField] for [String] values.\nclass StringField extends Field<String> {\n  /// Creates a new instance of [StringField].\n  StringField({\n    required super.name,\n    super.initialValue = '',\n    this.maxLines,\n    @Deprecated('Fields should not be aware of their context') super.onChanged,\n  }) : super(\n         defaultValue: '',\n         type: FieldType.string,\n         codec: FieldCodec(\n           toParam: (value) => value,\n           toValue: (param) => param,\n         ),\n       );\n\n  /// The maximum number of lines for the text field.\n  final int? maxLines;\n\n  @override\n  Widget toWidget(BuildContext context, String group, String? value) {\n    return TextFormField(\n      maxLines: maxLines,\n      initialValue: value ?? initialValue,\n      decoration: const InputDecoration(\n        hintText: 'Enter a value',\n      ),\n      onChanged: (value) => updateField(context, group, value),\n    );\n  }\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'maxLines': maxLines,\n    };\n  }\n}\n"
      }
    },
    "Integrations": {
      "Integrations": {
        "integrations": "export 'widgetbook_cloud_integration/widgetbook_cloud_integration.dart';\nexport 'widgetbook_integration.dart';\n"
      },
      "WidgetbookCloudIntegration": {
        "widgetbook_cloud_integration": "import '../widgetbook_integration.dart';\n\n/// Integration for Widgetbook Cloud, that is used to sync addons and knobs\n/// information with the host.\n@Deprecated(\n  'This integration is not used anymore, '\n  'you can safely remove it from your integrations list. '\n  'It will be removed in the future.',\n)\nclass WidgetbookCloudIntegration extends WidgetbookIntegration {}\n"
      },
      "WidgetbookIntegration": {
        "widgetbook_integration": "import '../state/state.dart';\nimport '../widgetbook.dart';\n\n/// Integrations are like lifecycle hooks that notifies implementer\n/// about [WidgetbookState] changes.\nabstract class WidgetbookIntegration {\n  /// Gets called on first launch of [Widgetbook] with the initial [state].\n  void onInit(WidgetbookState state) {}\n\n  /// Gets called when all knobs are registered after.\n  void onKnobsRegistered(WidgetbookState state) {}\n\n  /// Gets called on every [WidgetbookState] change.\n  void onChange(WidgetbookState state) {}\n}\n"
      }
    },
    "Knobs": {
      "BooleanKnob": {
        "boolean_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass BooleanKnob extends Knob<bool?> {\n  BooleanKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  });\n\n  BooleanKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  }) : super(isNullable: true);\n\n  @override\n  List<Field> get fields {\n    return [\n      BooleanField(\n        name: label,\n        initialValue: initialValue,\n      ),\n    ];\n  }\n\n  @override\n  bool? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "Builders": {
        "double_knobs_builder": "import '../double_input_knob.dart';\nimport '../double_slider_knob.dart';\nimport '../knob.dart';\nimport 'knobs_builder.dart';\n\n/// A [KnobsBuilder] for double knobs.\nclass DoubleKnobsBuilder {\n  /// Creates a [DoubleKnobsBuilder] with the provided [onKnobAdded] callback.\n  DoubleKnobsBuilder(this.onKnobAdded);\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [double] value with a slider.\n  /// Learn more: https://docs.widgetbook.io/knobs/double/slider\n  double slider({\n    required String label,\n    String? description,\n    double initialValue = 0,\n    double min = 0,\n    double max = 20,\n    int? divisions,\n    int? precision = 1,\n  }) {\n    return onKnobAdded(\n      DoubleSliderKnob(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        min: min,\n        max: max,\n        divisions: divisions,\n        precision: precision,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds an [double] value with an input field.\n  /// Learn more: https://docs.widgetbook.io/knobs/double/input\n  double input({\n    required String label,\n    String? description,\n    double initialValue = 0,\n  }) {\n    return onKnobAdded(\n      DoubleInputKnob(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n      ),\n    )!;\n  }\n}\n\n/// Same as [DoubleKnobsBuilder] but allows the knob to hold a null value.\nclass DoubleOrNullKnobsBuilder {\n  /// Creates a [DoubleOrNullKnobsBuilder] with the provided\n  /// [onKnobAdded] callback.\n  DoubleOrNullKnobsBuilder(\n    KnobAdded onKnobAdded,\n  ) : this.onKnobAdded = onKnobAdded;\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [double] value with a slider that can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/double/slider\n  double? slider({\n    required String label,\n    String? description,\n    double? initialValue,\n    double min = 0,\n    double max = 20,\n    int? divisions,\n    int? precision = 1,\n  }) {\n    return onKnobAdded(\n      DoubleSliderKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        min: min,\n        max: max,\n        divisions: divisions,\n        precision: precision,\n      ),\n    );\n  }\n\n  /// A [Knob] that holds an [double] value with an input field that can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/double/input\n  double? input({\n    required String label,\n    String? description,\n    double? initialValue,\n  }) {\n    return onKnobAdded(\n      DoubleInputKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n      ),\n    );\n  }\n}\n",
        "int_knobs_builder": "import '../int_input_knob.dart';\nimport '../int_slider_knob.dart';\nimport '../knob.dart';\nimport 'knobs_builder.dart';\n\n/// A [KnobsBuilder] for integer knobs.\nclass IntKnobsBuilder {\n  /// Creates a [IntKnobsBuilder] with the provided [onKnobAdded] callback.\n  IntKnobsBuilder(this.onKnobAdded);\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [int] value with an input field.\n  /// Learn more: https://docs.widgetbook.io/knobs/integer/input\n  int input({\n    required String label,\n    String? description,\n    int initialValue = 0,\n  }) {\n    return onKnobAdded(\n      IntInputKnob(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds an [int] value with a slider.\n  /// Learn more: https://docs.widgetbook.io/knobs/integer/slider\n  int slider({\n    required String label,\n    String? description,\n    int initialValue = 0,\n    int min = 0,\n    int max = 20,\n    int? divisions,\n  }) {\n    return onKnobAdded(\n      IntSliderKnob(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        min: min,\n        max: max,\n        divisions: divisions,\n      ),\n    )!;\n  }\n}\n\n/// Same as [IntKnobsBuilder] but allows the knob to hold a null value.\nclass IntOrNullKnobsBuilder {\n  /// Creates a [IntOrNullKnobsBuilder] with the provided [onKnobAdded] callback.\n  IntOrNullKnobsBuilder(\n    KnobAdded onKnobAdded,\n  ) : this.onKnobAdded = onKnobAdded;\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [int] value with an input field that can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/integer/input\n  int? input({\n    required String label,\n    String? description,\n    int? initialValue,\n  }) {\n    return onKnobAdded(\n      IntInputKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n      ),\n    );\n  }\n\n  /// A [Knob] that holds an [int] value with a slider that can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/integer/slider\n  int? slider({\n    required String label,\n    String? description,\n    int? initialValue,\n    int min = 0,\n    int max = 20,\n    int? divisions,\n  }) {\n    return onKnobAdded(\n      IntSliderKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        min: min,\n        max: max,\n        divisions: divisions,\n      ),\n    );\n  }\n}\n",
        "iterable_knobs_builder": "import '../../fields/fields.dart';\nimport '../iterable_segmented_knob.dart';\nimport '../knob.dart';\nimport 'knobs_builder.dart';\n\n/// A [KnobsBuilder] for iterable knobs.\nclass IterableKnobsBuilder {\n  /// Creates a [IterableKnobsBuilder] with the provided [onKnobAdded] callback.\n  IterableKnobsBuilder(this.onKnobAdded);\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [Iterable<T>] value with a segmented control.\n  /// Learn more: https://docs.widgetbook.io/knobs/iterable/segmented\n  Iterable<T> segmented<T>({\n    required String label,\n    required Iterable<T> options,\n    Iterable<T>? initialOption,\n    String? description,\n    LabelBuilder<T>? labelBuilder,\n    bool emptySelectionAllowed = true,\n  }) {\n    assert(options.isNotEmpty, 'Must specify at least one option');\n    return onKnobAdded(\n      IterableSegmentedKnob<T>(\n        label: label,\n        initialValue:\n            initialOption ?? {if (!emptySelectionAllowed) options.first},\n        description: description,\n        options: options,\n        labelBuilder: labelBuilder,\n        emptySelectionAllowed: emptySelectionAllowed,\n      ),\n    )!;\n  }\n}\n\n/// Same as [IterableKnobsBuilder] but allows the knob to hold a null value.\nclass IterableOrNullKnobsBuilder {\n  /// Creates a [IterableOrNullKnobsBuilder] with the provided [onKnobAdded] callback.\n  IterableOrNullKnobsBuilder(\n    KnobAdded onKnobAdded,\n  ) : this.onKnobAdded = onKnobAdded;\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [Iterable<T>] value with a segmented control that can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/iterable/segmented\n  Iterable<T>? segmented<T>({\n    required String label,\n    required Iterable<T> options,\n    Iterable<T>? initialOption,\n    String? description,\n    LabelBuilder<T>? labelBuilder,\n    bool emptySelectionAllowed = true,\n  }) {\n    assert(options.isNotEmpty, 'Must specify at least one option');\n    return onKnobAdded(\n      IterableSegmentedKnob<T>.nullable(\n        label: label,\n        initialValue: initialOption,\n        description: description,\n        options: options,\n        labelBuilder: labelBuilder,\n        emptySelectionAllowed: emptySelectionAllowed,\n      ),\n    );\n  }\n}\n",
        "knobs_builder": "import 'package:flutter/material.dart';\n\nimport '../../fields/fields.dart';\nimport '../boolean_knob.dart';\nimport '../color_knob.dart';\nimport '../date_time_knob.dart';\nimport '../duration_knob.dart';\nimport '../knob.dart';\nimport '../object_dropdown_knob.dart';\nimport '../string_knob.dart';\nimport 'double_knobs_builder.dart';\nimport 'int_knobs_builder.dart';\nimport 'iterable_knobs_builder.dart';\nimport 'object_knobs_builder.dart';\n\n/// @nodoc\ntypedef $int = int; // Allows us to use `int` as a knob name without conflict.\n\n/// @nodoc\ntypedef KnobAdded = T? Function<T>(Knob<T?> knob);\n\n/// The builder is used to create and register a variety of knobs that can be\n/// used in your use-cases.\n///\n/// This builder is provided to `context` in the use-case functions.\nclass KnobsBuilder {\n  /// Creates a [KnobsBuilder] with the provided [onKnobAdded] callback.\n  KnobsBuilder(\n    this.onKnobAdded,\n  ) : this.double = DoubleKnobsBuilder(onKnobAdded),\n      this.doubleOrNull = DoubleOrNullKnobsBuilder(onKnobAdded),\n      this.int = IntKnobsBuilder(onKnobAdded),\n      this.intOrNull = IntOrNullKnobsBuilder(onKnobAdded),\n      this.object = ObjectKnobsBuilder(onKnobAdded),\n      this.objectOrNull = ObjectOrNullKnobsBuilder(onKnobAdded),\n      this.iterable = IterableKnobsBuilder(onKnobAdded),\n      this.iterableOrNull = IterableOrNullKnobsBuilder(onKnobAdded);\n\n  /// The callback that is used to add a knob.\n  /// Used to register the knob in the use-case.\n  final KnobAdded onKnobAdded;\n\n  /// A builder for double knobs.\n  final DoubleKnobsBuilder double;\n\n  /// A builder for double knobs that can hold a null value.\n  final DoubleOrNullKnobsBuilder doubleOrNull;\n\n  /// A builder for integer knobs.\n  final IntKnobsBuilder int;\n\n  /// A builder for integer knobs that can hold a null value.\n  final IntOrNullKnobsBuilder intOrNull;\n\n  /// A builder for generic iterable knobs.\n  final IterableKnobsBuilder iterable;\n\n  /// A builder for generic iterable knobs that can hold a null value.\n  final IterableOrNullKnobsBuilder iterableOrNull;\n\n  /// A builder for generic object knobs.\n  final ObjectKnobsBuilder object;\n\n  /// A builder for generic object knobs that can hold a null value.\n  final ObjectOrNullKnobsBuilder objectOrNull;\n\n  /// A [Knob] that holds a [bool] value.\n  /// Learn more: https://docs.widgetbook.io/knobs/boolean\n  bool boolean({\n    required String label,\n    String? description,\n    bool initialValue = false,\n  }) {\n    return onKnobAdded(\n      BooleanKnob(\n        label: label,\n        description: description,\n        initialValue: initialValue,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds a [bool] value and can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/boolean\n  bool? booleanOrNull({\n    required String label,\n    String? description,\n    bool? initialValue,\n  }) {\n    return onKnobAdded(\n      BooleanKnob.nullable(\n        label: label,\n        description: description,\n        initialValue: initialValue,\n      ),\n    );\n  }\n\n  /// A [Knob] that holds a [Color] value.\n  /// Learn more: https://docs.widgetbook.io/knobs/color\n  Color color({\n    required String label,\n    Color initialValue = Colors.white,\n    ColorSpace initialColorSpace = ColorSpace.hex,\n    String? description,\n  }) {\n    return onKnobAdded(\n      ColorKnob(\n        label: label,\n        initialValue: initialValue,\n        initialColorSpace: initialColorSpace,\n        description: description,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds a [Color] value and can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/color\n  Color? colorOrNull({\n    required String label,\n    Color? initialValue,\n    ColorSpace initialColorSpace = ColorSpace.hex,\n    String? description,\n  }) {\n    return onKnobAdded(\n      ColorKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        initialColorSpace: initialColorSpace,\n        description: description,\n      ),\n    );\n  }\n\n  /// A [Knob] that holds a [String] value.\n  /// Learn more: https://docs.widgetbook.io/knobs/string\n  String string({\n    required String label,\n    String? description,\n    String initialValue = '',\n    $int? maxLines = 1,\n  }) {\n    return onKnobAdded(\n      StringKnob(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        maxLines: maxLines,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds a [String] value and can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/string\n  String? stringOrNull({\n    required String label,\n    String? description,\n    String? initialValue,\n    $int? maxLines = 1,\n  }) {\n    return onKnobAdded(\n      StringKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        maxLines: maxLines,\n      ),\n    );\n  }\n\n  /// @nodoc\n  @Deprecated('Use `knobs.object.dropdown` instead.')\n  T list<T>({\n    required String label,\n    required List<T> options,\n    T? initialOption,\n    String? description,\n    LabelBuilder<T>? labelBuilder,\n  }) {\n    assert(options.isNotEmpty, 'Must specify at least one option');\n    return onKnobAdded(\n      ObjectDropdownKnob<T>(\n        label: label,\n        initialValue: initialOption ?? options.first,\n        description: description,\n        options: options,\n        labelBuilder: labelBuilder,\n      ),\n    )!;\n  }\n\n  /// @nodoc\n  @Deprecated('Use `knobs.objectOrNull.dropdown` instead.')\n  T? listOrNull<T>({\n    required String label,\n    required List<T?> options,\n    T? initialOption,\n    String? description,\n    LabelBuilder<T?>? labelBuilder,\n  }) {\n    return onKnobAdded(\n      ObjectDropdownKnob<T?>.nullable(\n        label: label,\n        initialValue: initialOption,\n        description: description,\n        options: options,\n        labelBuilder: labelBuilder,\n      ),\n    );\n  }\n\n  /// A [Knob] that holds a [Duration] value.\n  /// Learn more: https://docs.widgetbook.io/knobs/duration\n  Duration duration({\n    required String label,\n    Duration initialValue = Duration.zero,\n    String? description,\n  }) {\n    return onKnobAdded(\n      DurationKnob(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds a [Duration] value and can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/duration\n  Duration? durationOrNull({\n    required String label,\n    Duration? initialValue,\n    String? description,\n  }) {\n    return onKnobAdded(\n      DurationKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n      ),\n    );\n  }\n\n  /// A [Knob] that holds a [DateTime] value.\n  /// Learn more: https://docs.widgetbook.io/knobs/datetime\n  DateTime dateTime({\n    required String label,\n    required DateTime initialValue,\n    String? description,\n    required DateTime start,\n    required DateTime end,\n  }) {\n    return onKnobAdded(\n      DateTimeKnob(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        start: start,\n        end: end,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds a [DateTime] value and can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/datetime\n  DateTime? dateTimeOrNull({\n    required String label,\n    DateTime? initialValue,\n    String? description,\n    required DateTime start,\n    required DateTime end,\n  }) {\n    return onKnobAdded(\n      DateTimeKnob.nullable(\n        label: label,\n        initialValue: initialValue,\n        description: description,\n        start: start,\n        end: end,\n      ),\n    );\n  }\n}\n",
        "knobs_extension": "/// @docImport '../../navigation/nodes/nodes.dart';\nlibrary;\n\nimport 'package:flutter/widgets.dart';\n\nimport '../../fields/fields.dart';\nimport '../../state/state.dart';\nimport '../knob.dart';\nimport 'knobs_builder.dart';\n\n/// Extension on [BuildContext] that provides access to knobs functionality.\n///\n/// This extension allows use cases to access knobs through the `context.knobs`\n/// property, providing a convenient API for creating interactive controls.\nextension KnobsExtension on BuildContext {\n  /// Creates adjustable parameters for the current [WidgetbookUseCase].\n  ///\n  /// Returns a [KnobsBuilder] that provides methods for creating different\n  /// types of knobs (string, boolean, color, etc.). The knobs are automatically\n  /// registered with the Widgetbook state and their values are synchronized\n  /// with URL query parameters.\n  ///\n  /// Example usage:\n  /// ```dart\n  /// WidgetbookUseCase(\n  ///   name: 'Interactive Example',\n  ///   builder: (context) {\n  ///     final title = context.knobs.string(\n  ///       label: 'Title',\n  ///       initialValue: 'Hello World',\n  ///     );\n  ///     final count = context.knobs.int.slider(\n  ///       label: 'Count',\n  ///       initialValue: 5,\n  ///       min: 0,\n  ///       max: 10,\n  ///     );\n  ///     final isVisible = context.knobs.boolean(\n  ///       label: 'Visible',\n  ///       initialValue: true,\n  ///     );\n  ///\n  ///     return Visibility(\n  ///       visible: isVisible,\n  ///       child: Column(\n  ///         children: [\n  ///           Text(title),\n  ///           for (int i = 0; i < count; i++)\n  ///             Text('Item $i'),\n  ///         ],\n  ///       ),\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  KnobsBuilder get knobs {\n    final state = WidgetbookState.of(this);\n    final queryGroup = FieldCodec.decodeQueryGroup(\n      state.queryParams['knobs'],\n    );\n\n    T? register<T>(Knob<T?> knob) {\n      return state.knobs.register(\n        knob,\n        queryGroup,\n      );\n    }\n\n    return KnobsBuilder(register);\n  }\n}\n",
        "object_knobs_builder": "import '../../fields/object_dropdown_field.dart';\nimport '../knob.dart';\nimport '../object_dropdown_knob.dart';\nimport '../object_segmented_knob.dart';\nimport 'knobs_builder.dart';\n\n/// A [KnobsBuilder] for object knobs.\nclass ObjectKnobsBuilder {\n  /// Creates a [ObjectKnobsBuilder] with the provided [onKnobAdded] callback.\n  ObjectKnobsBuilder(this.onKnobAdded);\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [T] value with a segmented control.\n  /// Learn more: https://docs.widgetbook.io/knobs/object/segmented\n  T segmented<T>({\n    required String label,\n    required List<T> options,\n    T? initialOption,\n    String? description,\n    LabelBuilder<T>? labelBuilder,\n  }) {\n    assert(options.isNotEmpty, 'Must specify at least one option');\n    return onKnobAdded(\n      ObjectSegmentedKnob<T>(\n        label: label,\n        initialValue: initialOption ?? options.first,\n        description: description,\n        options: options,\n        labelBuilder: labelBuilder,\n      ),\n    )!;\n  }\n\n  /// A [Knob] that holds an [T] value with a dropdown menu.\n  /// Learn more: https://docs.widgetbook.io/knobs/object/dropdown\n  T dropdown<T>({\n    required String label,\n    required List<T> options,\n    T? initialOption,\n    String? description,\n    LabelBuilder<T>? labelBuilder,\n  }) {\n    assert(options.isNotEmpty, 'Must specify at least one option');\n    return onKnobAdded(\n      ObjectDropdownKnob<T>(\n        label: label,\n        initialValue: initialOption ?? options.first,\n        options: options,\n        description: description,\n        labelBuilder: labelBuilder,\n      ),\n    )!;\n  }\n}\n\n/// Same as [ObjectKnobsBuilder] but allows the knob to hold a null value.\nclass ObjectOrNullKnobsBuilder {\n  /// Creates a [ObjectOrNullKnobsBuilder] with the provided [onKnobAdded] callback.\n  ObjectOrNullKnobsBuilder(\n    KnobAdded onKnobAdded,\n  ) : this.onKnobAdded = onKnobAdded;\n\n  /// The callback that is used to add a knob.\n  final KnobAdded onKnobAdded;\n\n  /// A [Knob] that holds an [T] value with a segmented control that can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/object/segmented\n  T? segmented<T>({\n    required String label,\n    required List<T> options,\n    T? initialOption,\n    String? description,\n    LabelBuilder<T>? labelBuilder,\n  }) {\n    assert(options.isNotEmpty, 'Must specify at least one option');\n    return onKnobAdded(\n      ObjectSegmentedKnob<T>.nullable(\n        label: label,\n        initialValue: initialOption,\n        description: description,\n        options: options,\n        labelBuilder: labelBuilder,\n      ),\n    );\n  }\n\n  /// A [Knob] that holds an [T] value with a dropdown menu that can be null.\n  /// Learn more: https://docs.widgetbook.io/knobs/object/dropdown\n  T? dropdown<T>({\n    required String label,\n    required List<T> options,\n    T? initialOption,\n    String? description,\n    LabelBuilder<T>? labelBuilder,\n  }) {\n    assert(options.isNotEmpty, 'Must specify at least one option');\n    return onKnobAdded(\n      ObjectDropdownKnob<T>.nullable(\n        label: label,\n        initialValue: initialOption,\n        options: options,\n        description: description,\n        labelBuilder: labelBuilder,\n      ),\n    );\n  }\n}\n"
      },
      "ColorKnob": {
        "color_knob": "import 'dart:ui';\n\nimport 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass ColorKnob extends Knob<Color?> {\n  ColorKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.initialColorSpace = ColorSpace.hex,\n  });\n\n  ColorKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.initialColorSpace = ColorSpace.hex,\n  }) : super(isNullable: true);\n\n  final ColorSpace initialColorSpace;\n\n  @override\n  List<Field> get fields {\n    return [\n      ColorField(\n        name: label,\n        initialValue: initialValue,\n        initialColorSpace: initialColorSpace,\n      ),\n    ];\n  }\n\n  @override\n  Color? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "DateTimeKnob": {
        "date_time_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass DateTimeKnob extends Knob<DateTime?> {\n  DateTimeKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    required this.start,\n    required this.end,\n  });\n\n  DateTimeKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    required this.start,\n    required this.end,\n  }) : super(isNullable: true);\n\n  /// The starting [DateTime] value used for the date and time pickers.\n  final DateTime start;\n\n  /// The ending [DateTime] value used for the date and time pickers.\n  final DateTime end;\n\n  @override\n  List<Field> get fields {\n    return [\n      DateTimeField(\n        name: label,\n        initialValue: initialValue,\n        start: start,\n        end: end,\n      ),\n    ];\n  }\n\n  @override\n  DateTime? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "DoubleInputKnob": {
        "double_input_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass DoubleInputKnob extends Knob<double?> {\n  DoubleInputKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  });\n\n  DoubleInputKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  }) : super(isNullable: true);\n\n  @override\n  List<Field> get fields {\n    return [\n      DoubleInputField(\n        name: label,\n        initialValue: initialValue,\n      ),\n    ];\n  }\n\n  @override\n  double? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "DoubleSliderKnob": {
        "double_slider_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass DoubleSliderKnob extends Knob<double?> {\n  DoubleSliderKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.max = 1,\n    this.min = 0,\n    this.divisions,\n    this.precision = 1,\n  });\n\n  DoubleSliderKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.max = 1,\n    this.min = 0,\n    this.divisions,\n    this.precision = 1,\n  }) : super(isNullable: true);\n\n  final double max;\n  final double min;\n  final int? divisions;\n  final int? precision;\n\n  @override\n  List<Field> get fields {\n    return [\n      DoubleSliderField(\n        name: label,\n        initialValue: initialValue,\n        min: min,\n        max: max,\n        divisions: divisions,\n        precision: precision,\n      ),\n    ];\n  }\n\n  @override\n  double? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "DurationKnob": {
        "duration_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass DurationKnob extends Knob<Duration?> {\n  DurationKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  });\n\n  DurationKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  }) : super(isNullable: true);\n\n  @override\n  List<Field> get fields {\n    return [\n      DurationField(\n        name: label,\n        initialValue: initialValue,\n      ),\n    ];\n  }\n\n  @override\n  Duration? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "IntInputKnob": {
        "int_input_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass IntInputKnob extends Knob<int?> {\n  IntInputKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  });\n\n  IntInputKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n  }) : super(isNullable: true);\n\n  @override\n  List<Field> get fields {\n    return [\n      IntInputField(\n        name: label,\n        initialValue: initialValue,\n      ),\n    ];\n  }\n\n  @override\n  int? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "IntSliderKnob": {
        "int_slider_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass IntSliderKnob extends Knob<int?> {\n  IntSliderKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.max = 1,\n    this.min = 0,\n    this.divisions,\n  });\n\n  IntSliderKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.max = 1,\n    this.min = 0,\n    this.divisions,\n  }) : super(isNullable: true);\n\n  final int max;\n  final int min;\n  final int? divisions;\n\n  @override\n  List<Field> get fields {\n    return [\n      IntSliderField(\n        name: label,\n        initialValue: initialValue,\n        min: min,\n        max: max,\n        divisions: divisions,\n      ),\n    ];\n  }\n\n  @override\n  int? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "IterableSegmentedKnob": {
        "iterable_segmented_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass IterableSegmentedKnob<T> extends Knob<Iterable<T>?> {\n  IterableSegmentedKnob({\n    required super.label,\n    required super.initialValue,\n    required this.options,\n    super.description,\n    this.labelBuilder,\n    this.emptySelectionAllowed = true,\n  });\n\n  IterableSegmentedKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    required this.options,\n    super.description,\n    this.labelBuilder,\n    this.emptySelectionAllowed = true,\n  }) : super(isNullable: true);\n\n  final Iterable<T> options;\n  final LabelBuilder<T>? labelBuilder;\n  final bool emptySelectionAllowed;\n\n  @override\n  List<Field> get fields {\n    return [\n      IterableSegmentedField<T>(\n        name: label,\n        values: options,\n        initialValue: initialValue,\n        emptySelectionAllowed: emptySelectionAllowed,\n        labelBuilder:\n            labelBuilder ?? IterableSegmentedField.defaultLabelBuilder,\n      ),\n    ];\n  }\n\n  @override\n  Iterable<T>? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "Knob": {
        "knob": "import 'package:flutter/widgets.dart';\n\nimport '../addons/addons.dart';\nimport '../fields/fields.dart';\nimport '../navigation/navigation.dart';\n\n/// Base class for interactive controls that allow dynamic parameter adjustment.\n///\n/// [Knob]s provide interactive controls within [WidgetbookUseCase]s that allow\n/// users to dynamically adjust widget parameters at runtime. Unlike [WidgetbookAddon]s\n/// which affect all use cases globally, knobs are specific to individual use cases\n/// and help test different states and configurations of widgets.\n///\n/// Knobs appear in the settings panel when a use case is selected and their\n/// values are synchronized with URL query parameters, making configurations\n/// shareable and persistent.\n///\n/// Learn more:\n/// * https://docs.widgetbook.io/knobs/overview\n/// * https://docs.widgetbook.io/knobs/custom-knob\n@optionalTypeArgs\nabstract class Knob<T> extends FieldsComposable<T> {\n  /// Creates a new [Knob] with the specified configuration.\n  Knob({\n    required String label,\n    super.description,\n    @Deprecated('Use initialValue instead.') T? value,\n    T? initialValue,\n    super.isNullable,\n    @Deprecated(\n      'This parameter is not used anymore. '\n      'It defaults to [value == null] instead of [false]',\n    )\n    bool isNull = false,\n  }) : this.initialValue = (initialValue ?? value) as T,\n       super(name: label);\n\n  /// The default value for this knob.\n  ///\n  /// This value is used when the knob is first displayed or when no value\n  /// has been set by the user.\n  final T initialValue;\n\n  /// The display label for this knob.\n  ///\n  /// This is an alias for [name] to maintain compatibility with older APIs.\n  /// The label appears in the settings panel next to the knob's input control.\n  String get label => name;\n\n  /// @nodoc\n  @Deprecated(\n    'Knobs are stateless. '\n    'They know about their value from [valueFromQueryGroup]. '\n    'You can use [initialValue] if you want to set a default value. ',\n  )\n  T? get value => null; // A workaround to avoid breaking changes\n\n  @override\n  String get groupName => 'knobs';\n\n  @override\n  bool operator ==(Object other) {\n    return other is Knob<T> &&\n        other.initialValue == initialValue &&\n        other.name == name &&\n        other.description == description;\n  }\n\n  @override\n  int get hashCode => name.hashCode;\n\n  @override\n  Map<String, dynamic> toJson() {\n    return {\n      'name': name,\n      'group': groupName,\n      'nullable': isNullable,\n      'fields': fields.map((field) => field.toFullJson()).toList(),\n    };\n  }\n}\n"
      },
      "Knobs": {
        "knobs": "export 'boolean_knob.dart';\nexport 'builders/double_knobs_builder.dart';\nexport 'builders/int_knobs_builder.dart';\nexport 'builders/knobs_builder.dart';\nexport 'builders/knobs_extension.dart';\nexport 'builders/object_knobs_builder.dart';\nexport 'color_knob.dart';\nexport 'date_time_knob.dart';\nexport 'double_input_knob.dart';\nexport 'double_slider_knob.dart';\nexport 'duration_knob.dart';\nexport 'int_input_knob.dart';\nexport 'int_slider_knob.dart';\nexport 'iterable_segmented_knob.dart';\nexport 'knob.dart';\nexport 'knobs_registry.dart';\nexport 'object_dropdown_knob.dart';\nexport 'object_segmented_knob.dart';\nexport 'string_knob.dart';\n"
      },
      "KnobsRegistry": {
        "knobs_registry": "import 'dart:collection';\n\nimport 'package:flutter/foundation.dart';\n// ignore: unnecessary_import flutter(<3.35.0)\nimport 'package:meta/meta.dart';\n\nimport 'knob.dart';\n\n/// The [KnobsRegistry] is a registry for [Knob]s that allows you to register\n/// and retrieve knobs by their label.\n/// After all knobs are registered, the [lock] method should be called,\n/// which will trigger the [onLock] callback.\nclass KnobsRegistry extends ChangeNotifier with MapMixin<String, Knob> {\n  /// Creates a new instance of [KnobsRegistry].\n  KnobsRegistry({\n    required this.onLock,\n  });\n\n  final Map<String, Knob> _registry = {};\n\n  /// Callback that is called when the knobs are locked.\n  /// Used to notify listeners that all use-case's knobs have been registered.\n  final VoidCallback onLock;\n\n  /// Locks the knobs registry and notifies listeners.\n  /// This should be called after all knobs are registered.\n  @internal\n  void lock() {\n    notifyListeners();\n    onLock();\n  }\n\n  /// Registers a [Knob] and retrieves its value based on the [queryGroup].\n  @internal\n  T? register<T>(\n    Knob<T?> knob,\n    Map<String, String> queryGroup,\n  ) {\n    _registry[knob.label] = knob;\n\n    return knob.valueFromQueryGroup(queryGroup);\n  }\n\n  /// No-op method.\n  /// Just present to maintain compatibility with the old API.\n  @Deprecated(\n    'Knobs values can no longer be updated, '\n    'they rely on query groups.',\n  )\n  void updateValue<T>(String label, T value) {}\n\n  @override\n  Knob? operator [](Object? key) => _registry[key as String];\n\n  @override\n  void operator []=(String key, Knob value) => _registry[key] = value;\n\n  @override\n  Iterable<String> get keys => _registry.keys;\n\n  @override\n  void clear() => _registry.clear();\n\n  @override\n  Knob? remove(Object? key) => _registry.remove(key);\n}\n"
      },
      "ObjectDropdownKnob": {
        "object_dropdown_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass ObjectDropdownKnob<T> extends Knob<T?> {\n  ObjectDropdownKnob({\n    required super.label,\n    required super.initialValue,\n    required this.options,\n    super.description,\n    this.labelBuilder,\n  });\n\n  ObjectDropdownKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    required this.options,\n    super.description,\n    this.labelBuilder,\n  }) : super(isNullable: true);\n\n  final List<T> options;\n  final LabelBuilder<T>? labelBuilder;\n\n  @override\n  List<Field> get fields {\n    return [\n      ObjectDropdownField<T>(\n        name: label,\n        values: options,\n        initialValue: initialValue,\n        labelBuilder: labelBuilder ?? ObjectDropdownField.defaultLabelBuilder,\n      ),\n    ];\n  }\n\n  @override\n  T? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "ObjectSegmentedKnob": {
        "object_segmented_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass ObjectSegmentedKnob<T> extends Knob<T?> {\n  ObjectSegmentedKnob({\n    required super.label,\n    required super.initialValue,\n    required this.options,\n    super.description,\n    this.labelBuilder,\n  });\n\n  ObjectSegmentedKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    required this.options,\n    super.description,\n    this.labelBuilder,\n  }) : super(isNullable: true);\n\n  final List<T> options;\n  final LabelBuilder<T>? labelBuilder;\n\n  @override\n  List<Field> get fields {\n    return [\n      ObjectSegmentedField<T>(\n        name: label,\n        values: options,\n        initialValue: initialValue,\n        labelBuilder: labelBuilder ?? ObjectSegmentedField.defaultLabelBuilder,\n      ),\n    ];\n  }\n\n  @override\n  T? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      },
      "StringKnob": {
        "string_knob": "import 'package:meta/meta.dart';\n\nimport '../fields/fields.dart';\nimport 'knob.dart';\n\n@internal\nclass StringKnob extends Knob<String?> {\n  StringKnob({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.maxLines,\n  });\n\n  StringKnob.nullable({\n    required super.label,\n    required super.initialValue,\n    super.description,\n    this.maxLines,\n  }) : super(isNullable: true);\n\n  final int? maxLines;\n\n  @override\n  List<Field> get fields {\n    return [\n      StringField(\n        name: label,\n        initialValue: initialValue,\n        maxLines: maxLines,\n      ),\n    ];\n  }\n\n  @override\n  String? valueFromQueryGroup(Map<String, String> group) {\n    return valueOf(label, group);\n  }\n}\n"
      }
    },
    "Layout": {
      "BaseLayout": {
        "base_layout": "import 'package:flutter/widgets.dart';\nimport 'package:meta/meta.dart';\n\n/// Base class for layouts in Widgetbook.\n@internal\nabstract class BaseLayout {\n  const BaseLayout({\n    required this.navigationBuilder,\n    required this.addonsBuilder,\n    required this.knobsBuilder,\n    required this.workbench,\n  });\n\n  final Widget Function(BuildContext context) navigationBuilder;\n  final List<Widget> Function(BuildContext context) addonsBuilder;\n  final List<Widget> Function(BuildContext context) knobsBuilder;\n  final Widget workbench;\n}\n"
      },
      "DesktopLayout": {
        "desktop_layout": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\nimport 'package:resizable_widget/resizable_widget.dart';\n\nimport '../settings/settings.dart';\nimport '../state/state.dart';\nimport '../widgetbook_theme.dart';\nimport 'base_layout.dart';\n\n/// The [DesktopLayout] is a layout for desktop devices that allows\n/// displaying the navigation, addons, knobs, and workbench in a\n/// resizable layout.\n@internal\nclass DesktopLayout extends StatelessWidget implements BaseLayout {\n  const DesktopLayout({\n    super.key,\n    required this.navigationBuilder,\n    required this.addonsBuilder,\n    required this.knobsBuilder,\n    required this.workbench,\n  });\n\n  final Widget Function(BuildContext context) navigationBuilder;\n  final List<Widget> Function(BuildContext context) addonsBuilder;\n  final List<Widget> Function(BuildContext context) knobsBuilder;\n  final Widget workbench;\n\n  @override\n  Widget build(BuildContext context) {\n    final state = WidgetbookState.of(context);\n\n    const kSidePanelPercentage = 0.2;\n    const kWorkbenchPercentage = 1 - 2 * kSidePanelPercentage;\n\n    final showNavigationPanel = state.canShowPanel(LayoutPanel.navigation);\n    final showSettingsPanel =\n        state.canShowPanel(LayoutPanel.addons) ||\n        state.canShowPanel(LayoutPanel.knobs);\n\n    return ColoredBox(\n      color: WidgetbookTheme.of(context).colorScheme.surface,\n      child: ResizableLayout(\n        items: [\n          if (showNavigationPanel)\n            ResizableLayoutItem(\n              percentage: kSidePanelPercentage,\n              child: Card(\n                child: navigationBuilder(context),\n              ),\n            ),\n          ResizableLayoutItem(\n            percentage: kWorkbenchPercentage,\n            child: workbench,\n          ),\n          if (showSettingsPanel)\n            ResizableLayoutItem(\n              percentage: kSidePanelPercentage,\n              child: Card(\n                child: SettingsPanel(\n                  settings: [\n                    if (state.canShowPanel(LayoutPanel.knobs)) ...{\n                      SettingsPanelData(\n                        name: 'Knobs',\n                        builder: knobsBuilder,\n                      ),\n                    },\n                    if (state.canShowPanel(LayoutPanel.addons) &&\n                        state.addons != null) ...{\n                      SettingsPanelData(\n                        name: 'Addons',\n                        builder: addonsBuilder,\n                      ),\n                    },\n                  ],\n                ),\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n\n@internal\nclass ResizableLayoutItem {\n  const ResizableLayoutItem({\n    required this.percentage,\n    required this.child,\n  });\n\n  final double percentage;\n  final Widget child;\n}\n\n/// An improved API for [ResizableWidget] that allows passing both percentage\n/// and child in a single object, allowing to easily add or remove items.\n/// Also distributes the remaining space equally among all items.\n@internal\nclass ResizableLayout extends StatelessWidget {\n  const ResizableLayout({super.key, required this.items});\n\n  final List<ResizableLayoutItem> items;\n\n  @override\n  Widget build(BuildContext context) {\n    final totalPercentage = items.fold(0.0, (sum, x) => sum + x.percentage);\n    final remainingPercentage = 1 - totalPercentage;\n    final extraPercentage = remainingPercentage / items.length;\n\n    return ResizableWidget(\n      separatorSize: 2,\n      separatorColor: Colors.white24,\n      percentages: items.map((x) => x.percentage + extraPercentage).toList(),\n      children: items.map((x) => x.child).toList(),\n    );\n  }\n}\n"
      },
      "MobileLayout": {
        "mobile_layout": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../settings/settings.dart';\nimport 'base_layout.dart';\n\n/// The [MobileLayout] is a layout for mobile devices that allows\n/// displaying the navigation, addons and knobs in a bottom-navigation layout.\n@internal\nclass MobileLayout extends StatelessWidget implements BaseLayout {\n  const MobileLayout({\n    super.key,\n    required this.navigationBuilder,\n    required this.addonsBuilder,\n    required this.knobsBuilder,\n    required this.workbench,\n  });\n\n  final Widget Function(BuildContext context) navigationBuilder;\n  final List<Widget> Function(BuildContext context) addonsBuilder;\n  final List<Widget> Function(BuildContext context) knobsBuilder;\n  final Widget workbench;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: workbench,\n      ),\n      bottomNavigationBar: BottomNavigationBar(\n        items: [\n          const BottomNavigationBarItem(\n            label: 'Navigation',\n            icon: Icon(Icons.list_outlined),\n          ),\n          const BottomNavigationBarItem(\n            label: 'Addons',\n            icon: Icon(Icons.dashboard_customize_outlined),\n          ),\n          const BottomNavigationBarItem(\n            label: 'Knobs',\n            icon: const Icon(Icons.tune_outlined),\n          ),\n        ],\n        onTap: (index) {\n          showModalBottomSheet<void>(\n            context: context,\n            builder: (context) {\n              switch (index) {\n                case 0:\n                  return navigationBuilder(context);\n                case 1:\n                  return MobileSettingsPanel(\n                    name: 'Addons',\n                    builder: addonsBuilder,\n                  );\n                case 2:\n                  return MobileSettingsPanel(\n                    name: 'Knobs',\n                    builder: knobsBuilder,\n                  );\n                default:\n                  return Container();\n              }\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n"
      },
      "ResponsiveLayout": {
        "responsive_layout": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../layout/desktop_layout.dart';\nimport '../layout/mobile_layout.dart';\nimport '../navigation/navigation.dart';\nimport '../state/state.dart';\n\n/// The [ResponsiveLayout] adapts the layout based on the screen size.\n/// It uses [MobileLayout] for mobile devices and [DesktopLayout] for\n/// larger screens.\n@internal\nclass ResponsiveLayout extends StatelessWidget {\n  const ResponsiveLayout({\n    super.key,\n    required this.child,\n  });\n\n  final Widget child;\n\n  Widget buildNavigation(BuildContext context, bool isMobile) {\n    final state = WidgetbookState.of(context);\n\n    return NavigationPanel(\n      initialPath: state.path,\n      root: state.root,\n      header: state.header,\n      onNodeSelected: (node) {\n        WidgetbookState.of(context).updatePath(node.path); // Fresh context\n\n        if (isMobile) {\n          Navigator.pop(context); // Close the modal\n        }\n      },\n    );\n  }\n\n  List<Widget> buildAddons(BuildContext context) {\n    final state = WidgetbookState.of(context);\n\n    return state.addons == null\n        ? []\n        : state.effectiveAddons!\n              .map((addon) => addon.buildFields(context))\n              .toList();\n  }\n\n  List<Widget> buildKnobs(BuildContext context) {\n    final state = WidgetbookState.of(context);\n\n    return state\n        .knobs\n        .values //\n        .map((knob) => knob.buildFields(context))\n        .toList();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Force desktop mode if `panels` query param is set.\n    // This is useful for when Widgetbook is used in docs, and users don't\n    // want the bottom navigation bar to be shown in the embedding.\n    final isEmbedded = WidgetbookState.of(context).panels != null;\n\n    // MediaQuery.sizeOf is not backwards compatible with Flutter < 3.10.0\n    //\n    // 840 is \"Expanded\" or \"Tablet in landscape\", \"Desktop\", ...\n    // See: https://m3.material.io/foundations/layout/applying-layout/window-size-classes#2bb70e22-d09b-4b73-9c9f-9ef60311ccc8\n    final isMobile = MediaQuery.of(context).size.width < 840;\n\n    return isMobile && !isEmbedded\n        ? MobileLayout(\n            navigationBuilder: (context) => buildNavigation(context, true),\n            addonsBuilder: buildAddons,\n            knobsBuilder: buildKnobs,\n            workbench: child,\n          )\n        : DesktopLayout(\n            navigationBuilder: (context) => buildNavigation(context, false),\n            addonsBuilder: buildAddons,\n            knobsBuilder: buildKnobs,\n            workbench: child,\n          );\n  }\n}\n"
      }
    },
    "Navigation": {
      "Icons": {
        "component_icon": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass ComponentIcon extends StatelessWidget {\n  const ComponentIcon({\n    super.key,\n    this.size = 12,\n  });\n\n  final double size;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      heightFactor: 1,\n      child: SizedBox(\n        width: size,\n        height: size,\n        child: Transform.rotate(\n          angle: 45 * pi / 180,\n          child: GridView.count(\n            crossAxisCount: 2,\n            padding: EdgeInsets.zero,\n            children: List.generate(\n              4,\n              (index) => Icon(\n                Icons.square_rounded,\n                size: size / 2,\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
        "expander_icon": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass ExpanderIcon extends StatelessWidget {\n  const ExpanderIcon({\n    super.key,\n    this.isExpanded = false,\n    this.size = 24,\n  });\n\n  final bool isExpanded;\n  final double size;\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedRotation(\n      duration: const Duration(milliseconds: 100),\n      turns: isExpanded ? 0.25 : 0,\n      child: Icon(\n        Icons.arrow_right_rounded,\n        size: size,\n      ),\n    );\n  }\n}\n",
        "icons": "export 'component_icon.dart';\nexport 'expander_icon.dart';\nexport 'use_case_icon.dart';\n",
        "resolve_icon": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../../../widgetbook.dart';\nimport '../nodes/nodes.dart';\nimport 'component_icon.dart';\nimport 'use_case_icon.dart';\n\n@internal\nWidget resolveIcon(WidgetbookNode node) {\n  if (node is WidgetbookPackage) {\n    return const Icon(Icons.inventory, size: 16);\n  } else if (node is WidgetbookCategory) {\n    return const Icon(Icons.auto_awesome_mosaic, size: 16);\n  } else if (node is WidgetbookFolder) {\n    return const Icon(Icons.folder, size: 16);\n  } else if (node is WidgetbookComponent) {\n    return const ComponentIcon();\n  } else if (node is WidgetbookUseCase) {\n    return const UseCaseIcon();\n  } else {\n    return const SizedBox();\n  }\n}\n",
        "use_case_icon": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass UseCaseIcon extends StatelessWidget {\n  const UseCaseIcon({\n    super.key,\n    this.size = 14,\n  });\n\n  final double size;\n\n  @override\n  Widget build(BuildContext context) {\n    return Transform.rotate(\n      angle: 45 * pi / 180,\n      child: Icon(\n        Icons.square_rounded,\n        size: size,\n      ),\n    );\n  }\n}\n"
      },
      "Navigation": {
        "navigation": "export 'icons/icons.dart';\nexport 'nodes/nodes.dart';\nexport 'widgets/widgets.dart';\n"
      },
      "Nodes": {
        "nodes": "export 'widgetbook_category.dart';\nexport 'widgetbook_component.dart';\nexport 'widgetbook_folder.dart';\nexport 'widgetbook_leaf_component.dart';\nexport 'widgetbook_node.dart';\nexport 'widgetbook_package.dart';\nexport 'widgetbook_root.dart';\nexport 'widgetbook_use_case.dart';\n",
        "widgetbook_category": "import 'widgetbook_node.dart';\n\n/// A navigation node that represents a category in the widget library.\n///\n/// This category can contain multiple components and use-cases.\n/// [WidgetbookCategory] is used to group related components or other categories\n/// into a hierarchical structure. This helps in categorizing widgets by\n/// functionality, design system sections, or any other logical grouping.\n///\n/// Example:\n///\n/// ```dart\n/// WidgetbookCategory(\n///   name: 'Buttons',\n///   children: [ ... ],\n/// )\n/// ```\nclass WidgetbookCategory extends WidgetbookNode {\n  /// Creates a [WidgetbookCategory] node.\n  WidgetbookCategory({\n    required super.name,\n    required super.children,\n    super.isInitiallyExpanded,\n  });\n\n  @override\n  WidgetbookCategory copyWith({\n    String? name,\n    List<WidgetbookNode>? children,\n  }) {\n    return WidgetbookCategory(\n      name: name ?? this.name,\n      children: children ?? this.children,\n      isInitiallyExpanded: isInitiallyExpanded,\n    );\n  }\n}\n",
        "widgetbook_component": "import 'widgetbook_node.dart';\nimport 'widgetbook_use_case.dart';\n\n/// A navigation node that represents a component in the widget library.\n///\n/// [WidgetbookComponent] organizes related [WidgetbookUseCase]s under a single\n/// component name. This is typically used to group different states or\n/// configurations of the same widget.\n///\n/// When this has a single use-case (i.e. also known as leaf component),\n/// this is represented as a \"component\" in the navigation tree but acts like\n/// a \"use-case\".\n///\n/// Example:\n/// ```dart\n/// WidgetbookComponent(\n///   name: 'Button',\n///   useCases: [\n///     WidgetbookUseCase(\n///       name: 'Primary',\n///       builder: (context) => ElevatedButton(\n///         onPressed: () {},\n///         child: Text('Primary Button'),\n///       ),\n///     ),\n///     WidgetbookUseCase(\n///       name: 'Secondary',\n///       builder: (context) => OutlinedButton(\n///         onPressed: () {},\n///         child: Text('Secondary Button'),\n///       ),\n///     ),\n///   ],\n/// )\n/// ```\nclass WidgetbookComponent extends WidgetbookNode {\n  /// Creates a [WidgetbookComponent] node.\n  WidgetbookComponent({\n    required super.name,\n    required this.useCases,\n    super.isInitiallyExpanded,\n  }) : super(\n         children: useCases,\n       );\n\n  /// The list of use cases that belong to this component.\n  ///\n  /// Each use case represents a different state or configuration of the widget.\n  final List<WidgetbookUseCase> useCases;\n\n  @override\n  WidgetbookComponent copyWith({\n    String? name,\n    List<WidgetbookNode>? children,\n  }) {\n    return WidgetbookComponent(\n      name: name ?? this.name,\n      useCases: children?.cast<WidgetbookUseCase>() ?? this.useCases,\n      isInitiallyExpanded: isInitiallyExpanded,\n    );\n  }\n}\n",
        "widgetbook_folder": "import 'widgetbook_node.dart';\n\n/// A navigation node that represents a folder in the widget library.\n///\n/// [WidgetbookFolder] is used to organize related components or other folders\n/// into a hierarchical structure. This helps in categorizing widgets by\n/// functionality, design system sections, or any other logical grouping.\n///\n/// Example:\n/// ```dart\n/// WidgetbookFolder(\n///   name: 'Buttons',\n///   children: [ ... ],\n/// )\n/// ```\nclass WidgetbookFolder extends WidgetbookNode {\n  /// Creates a [WidgetbookFolder] node\n  WidgetbookFolder({\n    required super.name,\n    required super.children,\n    super.isInitiallyExpanded,\n  });\n\n  @override\n  WidgetbookFolder copyWith({\n    String? name,\n    List<WidgetbookNode>? children,\n  }) {\n    return WidgetbookFolder(\n      name: name ?? this.name,\n      children: children ?? this.children,\n      isInitiallyExpanded: isInitiallyExpanded,\n    );\n  }\n}\n",
        "widgetbook_leaf_component": "import 'widgetbook_component.dart';\nimport 'widgetbook_use_case.dart';\n\n/// A special [WidgetbookComponent] with a single [WidgetbookUseCase].\n///\n@Deprecated('Use [WidgetbookComponent] instead.')\nclass WidgetbookLeafComponent extends WidgetbookComponent {\n  /// Creates a [WidgetbookLeafComponent] node.\n  WidgetbookLeafComponent({\n    required super.name,\n    required WidgetbookUseCase useCase,\n  }) : super(\n         useCases: [useCase],\n       );\n}\n",
        "widgetbook_node": "import 'nodes.dart';\n\n/// A base class for all nodes in the navigation tree.\n/// The nodes have the following hierarchy:\n///\n/// 1. [WidgetbookRoot]\n/// 2. [WidgetbookPackage]\n/// 3. [WidgetbookCategory]\n/// 4. [WidgetbookFolder]\n/// 5. [WidgetbookComponent]\n/// 6. [WidgetbookUseCase]\nabstract class WidgetbookNode {\n  /// Creates a [WidgetbookNode].\n  WidgetbookNode({\n    required this.name,\n    required this.children,\n    this.isInitiallyExpanded = true,\n  }) {\n    children?.forEach(\n      (child) => child.parent = this,\n    );\n  }\n\n  /// The name of the node.\n  final String name;\n\n  /// Whether the node is expanded by default.\n  final bool isInitiallyExpanded;\n\n  /// The children of the node.\n  final List<WidgetbookNode>? children;\n\n  /// The parent of the node.\n  /// This is set after the node is added to a parent node.\n  WidgetbookNode? parent;\n\n  /// Whether this node is the root node.\n  /// The root node does not have a parent.\n  bool get isRoot => parent == null;\n\n  /// Whether this node is a leaf node.\n  /// A leaf node has no children.\n  bool get isLeaf => children == null || children!.isEmpty;\n\n  /// Gets the path from root to this node without leading slash\n  /// Example: root/child/grandchild\n  String get path => nodesPath\n      .map((pathNode) => pathNode.name)\n      .join('/')\n      .replaceAll(' ', '-')\n      .toLowerCase()\n      .replaceFirst('/', '');\n\n  /// Gets the nodes path from root to this node.\n  List<WidgetbookNode> get nodesPath {\n    if (isRoot) {\n      return [this];\n    } else {\n      return [...parent!.nodesPath, this];\n    }\n  }\n\n  /// Gets the depth of the node within the tree.\n  int get depth {\n    if (isRoot) {\n      return 0;\n    } else {\n      return parent!.depth + 1;\n    }\n  }\n\n  /// Gets all leaf nodes of this node.\n  List<WidgetbookNode> get leaves {\n    if (isLeaf) {\n      return [this];\n    } else {\n      return children!.expand((child) => child.leaves).toList();\n    }\n  }\n\n  /// Gets the number of nodes in the sub-tree of this node.\n  int get count {\n    if (isLeaf) {\n      return 1;\n    } else {\n      return children!.fold<int>(\n        1,\n        (acc, child) => acc + child.count,\n      );\n    }\n  }\n\n  /// Filters the sub-tree of this node for any node that matches [predicate].\n  /// If a node matches the predicate, it will be included, along with all its\n  /// descendants, in the result.\n  ///\n  /// Returns null if no node matches the predicate.\n  WidgetbookNode? filter(\n    bool Function(WidgetbookNode node) predicate,\n  ) {\n    if (predicate(this)) {\n      return this;\n    } else {\n      final filteredChildren = children\n          ?.map((child) => child.filter(predicate))\n          .whereType<WidgetbookNode>()\n          .toList();\n\n      return filteredChildren == null || filteredChildren.isEmpty\n          ? null\n          : copyWith(\n              children: filteredChildren,\n            );\n    }\n  }\n\n  /// Searches for a node that matches [predicate] in the sub-tree of this node.\n  WidgetbookNode? find(\n    bool Function(WidgetbookNode node) predicate,\n  ) {\n    if (predicate(this)) {\n      return this;\n    } else {\n      return children //\n          ?.map((child) => child.find(predicate))\n          .firstWhere(\n            (child) => child != null,\n            orElse: () => null,\n          );\n    }\n  }\n\n  /// Returns an [Iterable] of all nodes that match the [predicate].\n  Iterable<WidgetbookNode> findAll(\n    bool Function(WidgetbookNode node) predicate,\n  ) {\n    if (predicate(this)) {\n      return [this];\n    } else {\n      return children?.expand((child) => child.findAll(predicate)) ?? [];\n    }\n  }\n\n  /// Creates a copy of this node with the given properties.\n  /// Used in [filter] to create a copy of the sub-tree.\n  WidgetbookNode copyWith({\n    String? name,\n    List<WidgetbookNode>? children,\n  });\n}\n",
        "widgetbook_package": "import 'widgetbook_node.dart';\n\n/// A navigation node that represents a package in the widget library.\n///\n/// [WidgetbookPackage] is used to group related components, folders, or other\n/// packages together. This is used to organize widgets by functionality,\n/// design system sections, or any other logical grouping.\n///\n/// Example:\n/// ```dart\n/// WidgetbookPackage(\n///   name: 'Material',\n///   children: [...],\n/// )\n/// ```\nclass WidgetbookPackage extends WidgetbookNode {\n  /// Creates a [WidgetbookPackage] node.\n  WidgetbookPackage({\n    required super.name,\n    required super.children,\n    super.isInitiallyExpanded,\n  });\n\n  @override\n  WidgetbookPackage copyWith({\n    String? name,\n    List<WidgetbookNode>? children,\n  }) {\n    return WidgetbookPackage(\n      name: name ?? this.name,\n      children: children ?? this.children,\n      isInitiallyExpanded: isInitiallyExpanded,\n    );\n  }\n}\n",
        "widgetbook_root": "import 'package:meta/meta.dart';\n\nimport 'widgetbook_component.dart';\nimport 'widgetbook_node.dart';\nimport 'widgetbook_use_case.dart';\n\n/// The root of all [WidgetbookNode]s.\nclass WidgetbookRoot extends WidgetbookNode {\n  /// Creates a [WidgetbookRoot] node.\n  WidgetbookRoot({\n    required super.children,\n  }) : super(\n         name: '',\n         isInitiallyExpanded: true,\n       ) {\n    table = Map.fromEntries(\n      leaves.whereType<WidgetbookUseCase>().map(\n        (node) => MapEntry(node.path, node),\n      ),\n    );\n\n    useCasesCount = leaves.whereType<WidgetbookUseCase>().length;\n    componentsCount = findAll((x) => x is WidgetbookComponent).length;\n  }\n\n  /// A table of all [WidgetbookUseCase]s and their paths.\n  @internal\n  late final Map<String, WidgetbookUseCase> table;\n\n  /// Count of all [WidgetbookUseCase]s in the root node.\n  late final int useCasesCount;\n\n  /// Count of all [WidgetbookComponent]s in the root node.\n  late final int componentsCount;\n\n  @override\n  WidgetbookRoot copyWith({\n    String? name,\n    List<WidgetbookNode>? children,\n  }) {\n    return WidgetbookRoot(\n      children: children ?? this.children,\n    );\n  }\n}\n",
        "widgetbook_use_case": "import 'package:flutter/material.dart';\n\nimport 'widgetbook_node.dart';\n\n/// A navigation node that represents a specific use case of a widget.\n///\n/// [WidgetbookUseCase] is the leaf node in the navigation tree and contains\n/// the actual widget implementation for a specific state or configuration.\n/// Each use case typically demonstrates a different scenario, state, or\n/// variant of a widget.\n///\n/// Example:\n/// ```dart\n/// WidgetbookUseCase(\n///   name: 'Loading State',\n///   builder: (context) => MyButton(\n///     onPressed: null,\n///     isLoading: true,\n///     child: Text('Loading...'),\n///   ),\n/// )\n/// ```\nclass WidgetbookUseCase extends WidgetbookNode {\n  /// Creates a [WidgetbookUseCase] node.\n  WidgetbookUseCase({\n    required super.name,\n    required this.builder,\n    this.designLink,\n  }) : super(\n         children: null,\n         isInitiallyExpanded: false,\n       );\n\n  /// @nodoc\n  @Deprecated(\n    'Use [AlignmentAddon] instead to '\n    'control your use-cases alignment. '\n    'For more info: https://docs.widgetbook.io/addons/alignment-addon',\n  )\n  factory WidgetbookUseCase.center({\n    required String name,\n    required Widget child,\n  }) {\n    return WidgetbookUseCase(\n      name: name,\n      builder: (_) => Center(child: child),\n    );\n  }\n\n  /// Creates a [WidgetbookUseCase] from a static [child] widget.\n  ///\n  /// This is a convenience factory for creating use cases with static widgets\n  /// that don't require access to the build context.\n  ///\n  /// The [designLink] is an optional URL to the design specifications for this use case.\n  factory WidgetbookUseCase.child({\n    required String name,\n    required Widget child,\n    String? designLink,\n  }) {\n    return WidgetbookUseCase(\n      name: name,\n      designLink: designLink,\n      builder: (_) => child,\n    );\n  }\n\n  /// A function that builds the widget for this use case.\n  ///\n  /// This function receives a [BuildContext] and should return the widget\n  /// that demonstrates the specific scenario for this use case.\n  final WidgetBuilder builder;\n\n  /// An optional URL to the design specifications for this use case.\n  ///\n  /// This can be used to link to Figma, Sketch, or other design tool files\n  /// that show the expected appearance of this use case.\n  final String? designLink;\n\n  /// Builds the widget for this use case using the provided [context].\n  Widget build(BuildContext context) {\n    return builder(context);\n  }\n\n  /// Creates a copy of this [WidgetbookUseCase].\n  ///\n  /// Note: Use cases are immutable leaf nodes, so this always returns\n  /// the same instance.\n  @override\n  WidgetbookUseCase copyWith({\n    String? name,\n    List<WidgetbookNode>? children,\n  }) {\n    return this;\n  }\n}\n"
      },
      "Widgets": {
        "navigation_panel": "import 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../../state/widgetbook_state.dart';\nimport '../nodes/nodes.dart';\nimport 'navigation_tree_node.dart';\nimport 'search_field.dart';\nimport 'stats_banner.dart';\n\n@internal\nclass NavigationPanel extends StatefulWidget {\n  const NavigationPanel({\n    super.key,\n    this.initialPath,\n    this.onNodeSelected,\n    required this.root,\n    this.header,\n  });\n\n  final String? initialPath;\n  final ValueChanged<WidgetbookNode>? onNodeSelected;\n  final WidgetbookNode root;\n\n  /// An optional widget to display at the top of the navigation panel.\n  /// This can be used for branding or additional information.\n  final Widget? header;\n\n  @override\n  State<NavigationPanel> createState() => _NavigationPanelState();\n}\n\nclass _NavigationPanelState extends State<NavigationPanel> {\n  Timer? _debounce;\n  WidgetbookNode? selectedNode;\n\n  bool filterNode(WidgetbookNode node, String query) {\n    // Escapes all the special character which are treated differently in regex\n    final escapedQuery = RegExp.escape(query);\n    final regex = RegExp(escapedQuery, caseSensitive: false);\n    return node.name.contains(regex);\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    selectedNode = widget.initialPath != null\n        ? widget.root.find((child) => child.path == widget.initialPath)\n        : null;\n  }\n\n  @override\n  void dispose() {\n    _debounce?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final query = WidgetbookState.of(context).query ?? '';\n    final filteredRoot = query.isEmpty\n        ? widget.root\n        : widget.root.filter((node) => filterNode(node, query)) ?? widget.root;\n\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: [\n        if (widget.header != null)\n          Padding(\n            padding: const EdgeInsets.all(16),\n            child: widget.header!,\n          ),\n        Padding(\n          padding: const EdgeInsets.all(16),\n          child: SearchField(\n            value: query,\n            onCleared: () => WidgetbookState.of(context).updateQuery(''),\n            onChanged: (value) {\n              _debounce?.cancel();\n              _debounce = Timer(\n                const Duration(milliseconds: 100),\n                () => WidgetbookState.of(context).updateQuery(value),\n              );\n            },\n          ),\n        ),\n        if (filteredRoot.children != null)\n          Expanded(\n            child: ListView.builder(\n              padding: const EdgeInsets.symmetric(\n                horizontal: 16,\n              ),\n              itemCount: filteredRoot.children!.length,\n              itemBuilder: (context, index) => NavigationTreeNode(\n                key: ObjectKey(filteredRoot.children![index]),\n                node: filteredRoot.children![index],\n                selectedNode: selectedNode,\n                onNodeSelected: (node) {\n                  if (!node.isLeaf || node.path == selectedNode?.path) {\n                    return;\n                  }\n\n                  setState(() => selectedNode = node);\n                  widget.onNodeSelected?.call(node);\n                },\n                enableLeafComponents: WidgetbookState.of(\n                  context,\n                ).enableLeafComponents,\n              ),\n            ),\n          ),\n        Padding(\n          padding: const EdgeInsets.all(8),\n          child: StatsBanner(\n            componentsCount: WidgetbookState.of(context).root.componentsCount,\n            useCasesCount: WidgetbookState.of(context).root.useCasesCount,\n          ),\n        ),\n      ],\n    );\n  }\n}\n",
        "navigation_tree_node": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../nodes/nodes.dart';\nimport 'navigation_tree_tile.dart';\n\n@internal\nclass NavigationTreeNode extends StatefulWidget {\n  const NavigationTreeNode({\n    super.key,\n    required this.node,\n    this.selectedNode,\n    this.onNodeSelected,\n    this.enableLeafComponents = true,\n  });\n\n  final WidgetbookNode node;\n  final WidgetbookNode? selectedNode;\n  final ValueChanged<WidgetbookNode>? onNodeSelected;\n  final bool enableLeafComponents;\n\n  @override\n  State<NavigationTreeNode> createState() => _NavigationTreeNodeState();\n}\n\nclass _NavigationTreeNodeState extends State<NavigationTreeNode> {\n  late bool isExpanded;\n\n  @override\n  void initState() {\n    super.initState();\n\n    isExpanded = widget.node.isInitiallyExpanded;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const animationDuration = Duration(\n      milliseconds: 200,\n    );\n\n    final isLeafComponent =\n        widget.enableLeafComponents &&\n        widget.node is WidgetbookComponent &&\n        widget.node.children?.length == 1;\n\n    // Redirect interactions to the use-case of the leaf component,\n    // so that when it's clicked, the route is updated to the use-case\n    // of the leaf component, and not the leaf component itself.\n    final targetNode = isLeafComponent\n        ? widget.node.children!.first\n        : widget.node;\n\n    return Column(\n      children: [\n        NavigationTreeTile(\n          node: widget.node,\n          isExpanded: isExpanded,\n          isSelected: targetNode.path == widget.selectedNode?.path,\n          enableLeafComponents: widget.enableLeafComponents,\n          onTap: () {\n            setState(() => isExpanded = !isExpanded);\n            widget.onNodeSelected?.call(targetNode);\n          },\n        ),\n        if (widget.node.children != null && !isLeafComponent)\n          ClipRect(\n            child: AnimatedSlide(\n              duration: animationDuration,\n              curve: Curves.easeInOut,\n              offset: Offset(0, isExpanded ? 0 : -1),\n              child: AnimatedAlign(\n                duration: animationDuration,\n                curve: Curves.easeInOut,\n                alignment: Alignment.topCenter,\n                heightFactor: isExpanded ? 1 : 0,\n                child: ListView.builder(\n                  physics: const NeverScrollableScrollPhysics(),\n                  itemCount: widget.node.children!.length,\n                  shrinkWrap: true,\n                  itemBuilder: (context, index) => NavigationTreeNode(\n                    node: widget.node.children![index],\n                    selectedNode: widget.selectedNode,\n                    onNodeSelected: widget.onNodeSelected,\n                    enableLeafComponents: widget.enableLeafComponents,\n                  ),\n                ),\n              ),\n            ),\n          ),\n      ],\n    );\n  }\n}\n",
        "navigation_tree_tile": "import 'dart:math';\n\nimport 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../../widgetbook_theme.dart';\nimport '../icons/icons.dart';\nimport '../icons/resolve_icon.dart';\nimport '../nodes/nodes.dart';\n\n@internal\nclass NavigationTreeTile extends StatelessWidget {\n  const NavigationTreeTile({\n    super.key,\n    required this.node,\n    this.onTap,\n    this.isExpanded = false,\n    this.isSelected = false,\n    this.enableLeafComponents = true,\n  });\n\n  static const indentation = 24.0;\n\n  final WidgetbookNode node;\n  final VoidCallback? onTap;\n  final bool isExpanded;\n  final bool isSelected;\n  final bool enableLeafComponents;\n\n  @override\n  Widget build(BuildContext context) {\n    final borderRadius = BorderRadius.circular(indentation);\n    final isLeafComponent =\n        enableLeafComponents &&\n        node is WidgetbookComponent &&\n        node.children?.length == 1;\n\n    return Container(\n      height: indentation,\n      decoration: BoxDecoration(\n        borderRadius: borderRadius,\n        color: isSelected\n            ? WidgetbookTheme.of(context).colorScheme.secondaryContainer\n            : null,\n      ),\n      child: InkWell(\n        onTap: onTap,\n        borderRadius: borderRadius,\n        child: Row(\n          children: [\n            SizedBox(\n              width: max(node.depth - 1, 0) * indentation,\n            ),\n            SizedBox(\n              width: indentation,\n              child: node.isLeaf || isLeafComponent\n                  ? null\n                  : ExpanderIcon(\n                      isExpanded: isExpanded,\n                    ),\n            ),\n            SizedBox(\n              width: indentation,\n              child: resolveIcon(node),\n            ),\n            const SizedBox(\n              width: 4,\n            ),\n            Expanded(\n              child: Text(\n                node.name,\n                maxLines: 1,\n                overflow: TextOverflow.ellipsis,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
        "search_field": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass SearchField extends StatefulWidget {\n  const SearchField({\n    super.key,\n    this.onChanged,\n    this.onCleared,\n    this.value = '',\n  });\n\n  final ValueChanged<String>? onChanged;\n  final VoidCallback? onCleared;\n  final String value;\n\n  @override\n  State<SearchField> createState() => _SearchFieldState();\n}\n\nclass _SearchFieldState extends State<SearchField> {\n  late final TextEditingController controller;\n  final FocusNode focusNode = FocusNode();\n\n  @override\n  void initState() {\n    super.initState();\n\n    controller = TextEditingController(text: widget.value);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final border = OutlineInputBorder(\n      borderRadius: BorderRadius.circular(50),\n      borderSide: const BorderSide(\n        color: Colors.transparent,\n        width: 0,\n      ),\n    );\n\n    return TextFormField(\n      controller: controller,\n      focusNode: focusNode,\n      onChanged: widget.onChanged,\n      decoration: InputDecoration(\n        hintText: 'Search',\n        enabledBorder: border,\n        focusedBorder: border,\n        contentPadding: const EdgeInsets.symmetric(\n          vertical: 5,\n        ),\n        prefixIcon: const Padding(\n          padding: EdgeInsets.all(12),\n          child: Icon(Icons.search),\n        ),\n        suffixIcon: widget.value.isNotEmpty\n            ? Padding(\n                padding: const EdgeInsets.only(\n                  right: 6,\n                  left: 12,\n                ),\n                child: IconButton(\n                  onPressed: () {\n                    controller.clear();\n                    focusNode.unfocus();\n                    widget.onCleared?.call();\n                  },\n                  hoverColor: Colors.white.withAlpha(25),\n                  icon: const Icon(Icons.close),\n                ),\n              )\n            : null,\n      ),\n    );\n  }\n}\n",
        "stats_banner": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\nimport 'package:url_launcher/url_launcher.dart';\n\nimport '../../widgetbook_theme.dart';\n\n/// A banner widget that displays statistics about the components and use-cases\n/// in the Widgetbook.\n@internal\nclass StatsBanner extends StatelessWidget {\n  const StatsBanner({\n    super.key,\n    required this.componentsCount,\n    required this.useCasesCount,\n  });\n\n  final int componentsCount;\n  final int useCasesCount;\n\n  String _pluralize(int count, String unit) {\n    return '$count ${count == 1 ? unit : unit + 's'}';\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Opacity(\n      opacity: 0.64,\n      child: Container(\n        decoration: BoxDecoration(\n          borderRadius: BorderRadius.circular(8),\n          border: Border.all(\n            color: WidgetbookTheme.of(context).colorScheme.outline,\n          ),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(12),\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              _SummaryItem(\n                icon: Icons.info_outline,\n                text:\n                    '${_pluralize(componentsCount, 'Component')} \u2022 '\n                    '${_pluralize(useCasesCount, 'Use-case')}',\n              ),\n              const SizedBox(height: 2),\n              const _SummaryItem(\n                icon: Icons.open_in_new,\n                text: 'Golden test with Widgetbook Cloud',\n                url:\n                    'https://docs.widgetbook.io/cloud?utm_source=oss&utm_medium=banner',\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass _SummaryItem extends StatelessWidget {\n  const _SummaryItem({\n    required this.text,\n    required this.icon,\n    this.url,\n  });\n\n  final String text;\n  final IconData icon;\n  final String? url;\n\n  @override\n  Widget build(BuildContext context) {\n    final isClickable = url != null;\n\n    return GestureDetector(\n      onTap: isClickable ? () => launchUrl(Uri.parse(url!)) : null,\n      behavior: HitTestBehavior.opaque,\n      child: MouseRegion(\n        cursor: isClickable ? SystemMouseCursors.click : MouseCursor.defer,\n        child: Row(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Icon(\n              icon,\n              size: 16,\n            ),\n            const SizedBox(width: 4),\n            Expanded(\n              child: Text(\n                text,\n                style:\n                    WidgetbookTheme.of(\n                      context,\n                    ).textTheme.bodySmall!.copyWith(\n                      decoration: isClickable ? TextDecoration.underline : null,\n                    ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
        "widgets": "export 'navigation_panel.dart';\nexport 'navigation_tree_node.dart';\nexport 'navigation_tree_tile.dart';\nexport 'search_field.dart';\nexport 'stats_banner.dart';\n"
      }
    },
    "Routing": {
      "AppRouter": {
        "app_router": "import 'package:flutter/widgets.dart';\nimport 'package:meta/meta.dart';\n\nimport '../state/state.dart';\nimport 'app_route_config.dart';\nimport 'app_route_parser.dart';\nimport 'app_router_delegate.dart';\n\n@internal\nclass AppRouter extends RouterConfig<AppRouteConfig> {\n  AppRouter({\n    required Uri uri,\n    required WidgetbookState state,\n  }) : super(\n         routeInformationParser: AppRouteParser(),\n         routeInformationProvider: PlatformRouteInformationProvider(\n           initialRouteInformation: RouteInformation(\n             uri: uri,\n           ),\n         ),\n         routerDelegate: AppRouterDelegate(\n           uri: uri,\n           state: state,\n         ),\n       );\n}\n"
      },
      "AppRouterDelegate": {
        "app_router_delegate": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../layout/responsive_layout.dart';\nimport '../state/state.dart';\nimport '../widgetbook_theme.dart';\nimport '../workbench/workbench.dart';\nimport 'app_route_config.dart';\n\n@internal\nclass AppRouterDelegate extends RouterDelegate<AppRouteConfig>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<AppRouteConfig> {\n  AppRouterDelegate({\n    required this.uri,\n    required this.state,\n  }) : _navigatorKey = GlobalKey<NavigatorState>(),\n       _configuration = AppRouteConfig(\n         uri: uri,\n       );\n\n  final Uri uri;\n  final WidgetbookState state;\n  final GlobalKey<NavigatorState> _navigatorKey;\n  AppRouteConfig _configuration;\n\n  @override\n  AppRouteConfig? get currentConfiguration => _configuration;\n\n  @override\n  GlobalKey<NavigatorState>? get navigatorKey => _navigatorKey;\n\n  @override\n  Future<void> setNewRoutePath(AppRouteConfig configuration) async {\n    _configuration = configuration;\n    state.updateFromRouteConfig(configuration);\n    notifyListeners();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final theme = Theme.of(context);\n    return WidgetbookTheme(\n      data: theme,\n      child: Navigator(\n        key: navigatorKey,\n        onDidRemovePage: (_) => {},\n        pages: [\n          MaterialPage(\n            child: _configuration.previewMode\n                ? const Workbench()\n                : ResponsiveLayout(\n                    key: ValueKey(_configuration),\n                    child: const Workbench(),\n                  ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
      },
      "AppRouteConfig": {
        "app_route_config": "import 'package:meta/meta.dart';\n\n@internal\nclass AppRouteConfig {\n  AppRouteConfig({\n    required this.uri,\n  });\n\n  static const reservedKeys = {'path', 'preview', 'q', 'panels'};\n\n  final Uri uri;\n\n  String? get path => uri.queryParameters['path'];\n\n  String? get query => uri.queryParameters['q'];\n\n  bool get previewMode => uri.queryParameters.containsKey('preview');\n\n  /// Example: `panels=navigation,addons,knobs`\n  Set<String>? get panels {\n    return uri.queryParameters['panels']?.split(',').toSet();\n  }\n\n  /// Returns a modifiable copy of the query parameters\n  /// without the reserved keys.\n  Map<String, String> get queryParams {\n    return Map<String, String>.from(uri.queryParameters)..removeWhere(\n      (key, _) => reservedKeys.contains(key),\n    );\n  }\n}\n"
      },
      "AppRouteParser": {
        "app_route_parser": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport 'app_route_config.dart';\n\n@internal\nclass AppRouteParser extends RouteInformationParser<AppRouteConfig> {\n  @override\n  Future<AppRouteConfig> parseRouteInformation(\n    RouteInformation routeInformation,\n  ) async {\n    return AppRouteConfig(\n      uri: routeInformation.uri,\n    );\n  }\n\n  @override\n  RouteInformation restoreRouteInformation(\n    AppRouteConfig configuration,\n  ) {\n    return RouteInformation(\n      uri: configuration.uri,\n    );\n  }\n}\n"
      },
      "Routing": {
        "routing": "export 'app_route_config.dart';\nexport 'app_route_parser.dart';\nexport 'app_router.dart';\nexport 'app_router_delegate.dart';\n"
      }
    },
    "Settings": {
      "MobileSettingsPanel": {
        "mobile_settings_panel": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass MobileSettingsPanel extends StatelessWidget {\n  const MobileSettingsPanel({\n    super.key,\n    required this.name,\n    required this.builder,\n  });\n\n  final String name;\n  final List<Widget> Function(BuildContext context) builder;\n\n  @override\n  Widget build(BuildContext context) {\n    final items = builder(context);\n\n    if (items.isEmpty) {\n      return Padding(\n        padding: const EdgeInsets.all(8),\n        child: Center(\n          child: Text('No $name available'),\n        ),\n      );\n    }\n\n    return ListView.builder(\n      padding: const EdgeInsets.only(top: 16),\n      itemCount: items.length,\n      itemBuilder: (context, index) => items[index],\n    );\n  }\n}\n"
      },
      "NullableSetting": {
        "nullable_setting": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport 'setting.dart';\n\n/// A widget that represents a nullable configuration option in Widgetbook.\n@internal\nclass NullableSetting extends Setting {\n  NullableSetting({\n    super.key,\n    required super.name,\n    super.description,\n    required super.child,\n    required bool isNullified,\n    ValueChanged<bool>? onNullified,\n  }) : super(\n         trailing: Checkbox(\n           // The value is inverted here because the checkbox\n           // is unchecked when the value is nullified.\n           // And the onChange callback is called with true when\n           // the value is unchecked (i.e. nullified).\n           value: !isNullified,\n           onChanged: (value) => onNullified?.call(!value!),\n         ),\n       );\n}\n"
      },
      "Setting": {
        "setting": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../widgetbook_theme.dart';\n\n/// A widget that represents a configuration option in Widgetbook.\n/// It's used for both addons and knobs to provide a consistent UI for settings.\n@internal\nclass Setting extends StatelessWidget {\n  const Setting({\n    super.key,\n    required this.name,\n    this.description,\n    this.trailing,\n    required this.child,\n  });\n\n  final String name;\n  final String? description;\n  final Widget? trailing;\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(\n        horizontal: 24,\n        vertical: 12,\n      ),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          Row(\n            children: [\n              Expanded(\n                child: Text(\n                  name,\n                  maxLines: 1,\n                  overflow: TextOverflow.ellipsis,\n                  style:\n                      WidgetbookTheme.of(\n                        context,\n                      ).textTheme.titleSmall!.copyWith(\n                        color: WidgetbookTheme.of(context).colorScheme.primary,\n                      ),\n                ),\n              ),\n              if (trailing != null) ...{\n                const SizedBox(width: 8),\n                trailing!,\n              },\n            ],\n          ),\n          const SizedBox(height: 12),\n          if (description != null) ...{\n            Text(description!),\n            const SizedBox(height: 12),\n          },\n          child,\n        ],\n      ),\n    );\n  }\n}\n"
      },
      "Settings": {
        "settings": "export 'mobile_settings_panel.dart';\nexport 'nullable_setting.dart';\nexport 'setting.dart';\nexport 'settings_panel.dart';\n"
      },
      "SettingsPanel": {
        "settings_panel": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n@internal\nclass SettingsPanelData {\n  SettingsPanelData({\n    required this.name,\n    required this.builder,\n  });\n\n  final String name;\n  final List<Widget> Function(BuildContext context) builder;\n}\n\n@internal\nclass SettingsPanel extends StatelessWidget {\n  SettingsPanel({\n    super.key,\n    required this.settings,\n  });\n\n  final List<SettingsPanelData> settings;\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      animationDuration: Duration.zero,\n      length: settings.length,\n      child: Column(\n        children: [\n          // If only one tab (e.g. Knobs), is provided (because the other is\n          // hidden via `panels` query parameter), then we don't need to\n          // show the TabBar.\n          if (settings.length > 1)\n            TabBar(\n              tabs: settings\n                  .map(\n                    (setting) => Padding(\n                      padding: const EdgeInsets.symmetric(\n                        vertical: 16,\n                        horizontal: 8,\n                      ),\n                      child: Text(\n                        setting.name,\n                        overflow: TextOverflow.ellipsis,\n                      ),\n                    ),\n                  )\n                  .toList(),\n            ),\n          Expanded(\n            child: TabBarView(\n              children: settings.map(\n                (setting) {\n                  final children = setting.builder(context);\n\n                  return children.isEmpty\n                      ? Center(\n                          child: Padding(\n                            padding: const EdgeInsets.all(8),\n                            child: Text('No ${setting.name} available'),\n                          ),\n                        )\n                      : SingleChildScrollView(\n                          padding: const EdgeInsets.symmetric(vertical: 16),\n                          child: Column(\n                            children: children,\n                          ),\n                        );\n                },\n              ).toList(),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
      }
    },
    "State": {
      "DefaultAppBuilders": {
        "default_app_builders": "/// @docImport '../widgetbook.dart';\nlibrary;\n\nimport 'package:flutter/cupertino.dart';\nimport 'package:flutter/material.dart';\n\n/// A [Widgetbook.appBuilder] that uses [WidgetsApp].\nWidget widgetsAppBuilder(BuildContext context, Widget child) {\n  return WidgetsApp(\n    debugShowCheckedModeBanner: false,\n    color: Colors.white,\n    home: child,\n  );\n}\n\n/// A [Widgetbook.appBuilder] that uses [MaterialApp].\nWidget materialAppBuilder(BuildContext context, Widget child) {\n  return MaterialApp(\n    debugShowCheckedModeBanner: false,\n    home: Material(\n      child: child,\n    ),\n  );\n}\n\n/// A [Widgetbook.appBuilder] that uses [CupertinoApp].\nWidget cupertinoAppBuilder(BuildContext context, Widget child) {\n  return CupertinoApp(\n    debugShowCheckedModeBanner: false,\n    home: child,\n  );\n}\n"
      },
      "DefaultHomePage": {
        "default_home_page": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\nimport 'package:url_launcher/url_launcher.dart';\n\nimport '../widgetbook_theme.dart';\n\n@internal\nclass DefaultHomePage extends StatelessWidget {\n  const DefaultHomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(16),\n      child: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(\n              'Welcome to Widgetbook',\n              textAlign: TextAlign.center,\n              style: WidgetbookTheme.of(context).textTheme.displaySmall,\n            ),\n            const SizedBox(height: 24),\n            const Wrap(\n              children: [\n                _Card(\n                  title: '\ud83d\udcd6 Docs',\n                  url:\n                      'https://docs.widgetbook.io?utm_source=oss&utm_medium=home',\n                  description:\n                      'Learn more about knobs, addons, mocking, and more.',\n                ),\n                _Card(\n                  title: '\ud83d\udcdd Examples',\n                  url:\n                      'https://github.com/widgetbook/widgetbook/tree/main/examples',\n                  description:\n                      'Explore the Widgetbook examples and learn how to use them.',\n                ),\n              ],\n            ),\n            const Wrap(\n              children: [\n                _Card(\n                  title: '\ud83d\ude80 Deploy',\n                  url:\n                      'https://docs.widgetbook.io/cloud/builds/overview?utm_source=oss&utm_medium=home',\n                  description:\n                      'Deploy your Widgetbook with our managed-hosting solution.',\n                ),\n                _Card(\n                  title: '\u2728 Detect Changes',\n                  url:\n                      'https://docs.widgetbook.io/cloud/reviews?utm_source=oss&utm_medium=home',\n                  description:\n                      'Detect visual changes in your PRs with Widgetbook Cloud.',\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass _Card extends StatelessWidget {\n  const _Card({\n    required this.title,\n    required this.description,\n    required this.url,\n  });\n\n  final String title;\n  final String description;\n  final String url;\n\n  @override\n  Widget build(BuildContext context) {\n    return ConstrainedBox(\n      constraints: const BoxConstraints(\n        maxWidth: 360,\n      ),\n      child: Card(\n        clipBehavior: Clip.hardEdge,\n        shape: RoundedRectangleBorder(\n          borderRadius: BorderRadius.circular(12),\n          side: BorderSide(\n            color: WidgetbookTheme.of(context).dividerColor.withAlpha(100),\n          ),\n        ),\n        child: InkWell(\n          onTap: () => launchUrl(Uri.parse(url)),\n          child: Padding(\n            padding: const EdgeInsets.all(16),\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                RichText(\n                  text: TextSpan(\n                    style: WidgetbookTheme.of(context).textTheme.titleMedium,\n                    children: [\n                      TextSpan(\n                        text: title,\n                      ),\n                      const TextSpan(text: ' '),\n                      const WidgetSpan(\n                        child: Icon(\n                          Icons.arrow_forward,\n                          size: 16,\n                        ),\n                      ),\n                    ],\n                  ),\n                ),\n                const SizedBox(height: 4),\n                Text(\n                  description,\n                  style:\n                      WidgetbookTheme.of(\n                        context,\n                      ).textTheme.bodyMedium!.copyWith(\n                        color: WidgetbookTheme.of(\n                          context,\n                        ).colorScheme.onSurface.withAlpha(120),\n                      ),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
      },
      "State": {
        "state": "export 'default_app_builders.dart';\nexport 'widgetbook_scope.dart';\nexport 'widgetbook_state.dart';\n"
      },
      "WidgetbookScope": {
        "widgetbook_scope": "import 'package:flutter/widgets.dart';\n\nimport 'widgetbook_state.dart';\n\n/// The [WidgetbookScope] is an [InheritedNotifier] that provides access to the\n/// [WidgetbookState] to its descendants.\n///\n/// You can can access the state as follows:\n///\n/// ```dart\n/// final state = WidgetbookState.of(context);\n/// ```\nclass WidgetbookScope extends InheritedNotifier<WidgetbookState> {\n  /// Creates a [WidgetbookScope] with the given initial [state] and [child].\n  WidgetbookScope({\n    super.key,\n    required WidgetbookState state,\n    required super.child,\n  }) : super(\n         notifier: state,\n       );\n}\n"
      },
      "WidgetbookState": {
        "widgetbook_state": "/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\nlibrary;\n\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\nimport 'package:meta/meta.dart';\n\nimport '../addons/addons.dart';\nimport '../fields/fields.dart';\nimport '../integrations/widgetbook_integration.dart';\nimport '../knobs/knobs.dart';\nimport '../navigation/navigation.dart';\nimport '../routing/routing.dart';\nimport '../utils.dart';\nimport 'default_app_builders.dart';\nimport 'default_home_page.dart';\nimport 'widgetbook_scope.dart';\n\n/// Function signature for building the app wrapper around use cases.\n///\n/// The [AppBuilder] receives a [BuildContext] and the child widget (use case)\n/// and should return a widget that wraps the child with the appropriate\n/// app-level widgets like [MaterialApp], [CupertinoApp], or [WidgetsApp].\ntypedef AppBuilder = Widget Function(BuildContext context, Widget child);\n\n/// Represents the main sections of the Widgetbook layout.\n///\n/// These panels can be shown or hidden individually to customize the\n/// Widgetbook interface layout.\nenum LayoutPanel {\n  /// The navigation panel showing the widget directory structure.\n  ///\n  /// Contains the tree view of folders, components, and use cases.\n  navigation,\n\n  /// The addons panel showing global addon controls.\n  ///\n  /// Contains settings for viewport, theme, localization, and other addons.\n  addons,\n\n  /// The knobs panel showing use case-specific controls.\n  ///\n  /// Contains interactive controls for the currently selected use case.\n  knobs,\n}\n\n/// Central state management for the Widgetbook application.\n///\n/// [WidgetbookState] maintains the current navigation state, query parameters,\n/// addon configurations, knob values, and other stateful information used\n/// throughout the Widgetbook application. It serves as the single source of\n/// truth for the application's state.\n///\n/// The state is accessible throughout the widget tree using:\n/// ```dart\n/// final state = WidgetbookState.of(context);\n/// ```\n///\n/// Key responsibilities:\n/// * Managing current path and navigation state\n/// * Synchronizing state with URL query parameters\n/// * Coordinating between addons, knobs, and use cases\n/// * Managing layout panel visibility\n/// * Handling integrations (like Widgetbook Cloud)\n///\n/// The state automatically notifies listeners when changes occur, enabling\n/// reactive updates throughout the UI.\nclass WidgetbookState extends ChangeNotifier {\n  /// Creates a new instance of [WidgetbookState].\n  WidgetbookState({\n    this.path,\n    this.query,\n    this.previewMode = false,\n    this.queryParams = const {},\n    this.appBuilder = widgetsAppBuilder,\n    this.addons,\n    this.integrations,\n    required this.root,\n    this.home = const DefaultHomePage(),\n    this.panels = null,\n    this.header,\n    this.enableLeafComponents = true,\n  }) {\n    this.knobs = KnobsRegistry(\n      onLock: () {\n        integrations?.forEach(\n          (integration) => integration.onKnobsRegistered(this),\n        );\n      },\n    );\n\n    knobs.addListener(\n      notifyListeners,\n    );\n  }\n\n  /// The current path in the Widgetbook.\n  String? path;\n\n  /// The current query (i.e. search) string, if any.\n  String? query;\n\n  /// Whether the Widgetbook is in preview mode.\n  ///\n  /// Preview mode is when only the workbench panels is shown, and all\n  /// [LayoutPanel]s are hidden.\n  bool previewMode;\n\n  /// The query parameters that are used to filter the use-cases.\n  Map<String, String> queryParams;\n\n  /// Determines which panels are shown.\n  ///\n  /// - If `null`, all panels are shown.\n  /// - If empty, no panels are shown (similar to [previewMode]).\n  /// - If [previewMode] is `true`, the [panels] are ignored.\n  ///\n  /// NOTE: this forces the desktop mode, even if the screen size is small.\n  Set<LayoutPanel>? panels;\n\n  /// The registry for knobs, which are interactive controls for use cases.\n  late final KnobsRegistry knobs;\n\n  /// The application builder function used to create the main app widget.\n  final AppBuilder appBuilder;\n\n  /// The list of addons that are available in the Widgetbook.\n  final List<WidgetbookAddon>? addons;\n\n  /// The list of integrations that are available in the Widgetbook.\n  final List<WidgetbookIntegration>? integrations;\n\n  /// The root node of the Widgetbook navigation tree.\n  final WidgetbookRoot root;\n\n  /// The home widget is a widget that is shown on startup when no use-case is\n  /// selected. This widget does not inherit from the [appBuilder] or the\n  /// [addons]; meaning that if `Theme.of(context)` is called inside this\n  final Widget home;\n\n  /// An optional widget to display at the top of the navigation panel.\n  /// This can be used for branding or additional information.\n  final Widget? header;\n\n  /// Whether leaf components are enabled in the navigation tree.\n  /// By default, this is set to true.\n  final bool enableLeafComponents;\n\n  /// List of directories passed to the root node.\n  List<WidgetbookNode> get directories => root.children!;\n\n  /// Returns the current [WidgetbookUseCase] based on the [path].\n  /// If the [path] is not found, it returns `null`.\n  WidgetbookUseCase? get useCase => path == null ? null : root.table[path!];\n\n  /// Same as [addons] but without the ones that have no fields.\n  @internal\n  List<WidgetbookAddon>? get effectiveAddons {\n    return addons?.where((addon) => addon.fields.isNotEmpty).toList();\n  }\n\n  /// A [Uri] representation of the current state.\n  Uri get uri {\n    final queryParameters = {\n      if (path != null) 'path': path,\n      if (query?.isNotEmpty ?? false) 'q': query,\n      if (panels?.isNotEmpty ?? false)\n        'panels': panels?.map((x) => x.name).join(','),\n      ...queryParams,\n    };\n\n    return Uri(\n      path: '/',\n      queryParameters: queryParameters.isEmpty ? null : queryParameters,\n    );\n  }\n\n  /// Gets the current state using [context], if any.\n  /// If there is no state in scope, then this function will return null.\n  static WidgetbookState? maybeOf(BuildContext context) {\n    return context\n        .dependOnInheritedWidgetOfExactType<WidgetbookScope>()\n        ?.notifier;\n  }\n\n  /// Gets the current state using [context].\n  static WidgetbookState of(BuildContext context) {\n    final state = WidgetbookState.maybeOf(context);\n    assert(state != null, 'No Widgetbook found in the context.');\n    return state!;\n  }\n\n  @internal\n  @override\n  void notifyListeners() {\n    super.notifyListeners();\n\n    // Do not sync route if the panels are not showing up,\n    // since the widget state is already controlled by using the URL.\n    if (canShowPanel(LayoutPanel.navigation) ||\n        canShowPanel(LayoutPanel.addons) ||\n        canShowPanel(LayoutPanel.knobs)) {\n      _syncRouteInformation();\n    }\n\n    integrations?.forEach(\n      (integration) => integration.onChange(this),\n    );\n  }\n\n  /// Whether the given [panel] can be shown based on the current state.\n  bool canShowPanel(LayoutPanel panel) {\n    if (previewMode) return false;\n    if (panels == null) return true;\n    return panels!.contains(panel);\n  }\n\n  /// Syncs this with the router's location using [SystemNavigator].\n  void _syncRouteInformation() {\n    SystemNavigator.routeInformationUpdated(\n      uri: uri,\n    );\n  }\n\n  /// Update the [name] query parameter with the given [value].\n  @internal\n  void updateQueryParam(String name, String value) {\n    if (AppRouteConfig.reservedKeys.contains(name)) {\n      throw ArgumentError(\n        'The query parameter $name is reserved and cannot be updated.',\n      );\n    }\n\n    queryParams[name] = value;\n    notifyListeners();\n  }\n\n  /// Update the field within the query [group] with the given [value].\n  void updateQueryField({\n    required String group,\n    required String field,\n    required String value,\n  }) {\n    final groupMap = FieldCodec.decodeQueryGroup(queryParams[group]);\n\n    final newGroupMap = Map<String, String>.from(groupMap)\n      ..update(\n        field,\n        (_) => value,\n        ifAbsent: () => value,\n      );\n\n    updateQueryParam(\n      group,\n      FieldCodec.encodeQueryGroup(newGroupMap),\n    );\n  }\n\n  /// Update the [path], causing a new [useCase] to bet returned.\n  /// Resets the [knobs] during the update.\n  @internal\n  void updatePath(String newPath) {\n    path = newPath;\n\n    // Reset Knobs\n    knobs.clear();\n    queryParams.remove('knobs');\n\n    notifyListeners();\n  }\n\n  /// Updates the `q` query parameter with the given [value].\n  @internal\n  void updateQuery(String value) {\n    query = value;\n    notifyListeners();\n  }\n\n  /// Updates [Knob.value] using the [label] to find the [Knob].\n  @Deprecated('Use [knobs.updateValue] instead.')\n  void updateKnobValue<T>(String label, T value) {\n    knobs.updateValue<T>(label, value);\n  }\n\n  /// Updates the current state using [AppRouteConfig] to update\n  /// the [path], [previewMode] and [queryParams] fields. Since these fields\n  /// can be manipulated from the router's query parameters, as opposed to the\n  /// rest of fields that stay unchanged during runtime.\n  @internal\n  void updateFromRouteConfig(AppRouteConfig routeConfig) {\n    path = routeConfig.path;\n    query = routeConfig.query;\n    previewMode = routeConfig.previewMode;\n    queryParams = routeConfig.queryParams;\n    panels = previewMode\n        ? null // Panels are ignored in preview mode\n        : routeConfig.panels\n              ?.map(LayoutPanel.values.byNameOrNull)\n              .nonNulls\n              .toSet();\n\n    notifyListeners();\n  }\n\n  @override\n  void dispose() {\n    knobs.dispose();\n    super.dispose();\n  }\n}\n"
      }
    },
    "Workbench": {
      "SafeBoundaries": {
        "safe_boundaries": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\n/// Sets safe boundaries around [child] for proper rendering.\n/// This is needed for widgets that depend on [MediaQuery],\n/// for example: widgets from `flutter_screenutil` package.\n@internal\nclass SafeBoundaries extends StatelessWidget {\n  const SafeBoundaries({\n    super.key,\n    required this.child,\n  });\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    return ClipRect(\n      child: LayoutBuilder(\n        builder: (context, constrains) {\n          return MediaQuery(\n            data: MediaQuery.of(context).copyWith(\n              size: Size(\n                constrains.maxWidth,\n                constrains.maxHeight,\n              ),\n            ),\n            child: child,\n          );\n        },\n      ),\n    );\n  }\n}\n"
      },
      "UseCaseBuilder": {
        "use_case_builder": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../state/state.dart';\n\n/// The [UseCaseBuilder] is a widget that builds the use case in the context\n/// of the [WidgetbookState]. It is responsible for locking the knobs\n/// after the use case has been built.\n@internal\nclass UseCaseBuilder extends StatefulWidget {\n  const UseCaseBuilder({\n    super.key,\n    required this.builder,\n  });\n\n  final Widget Function(BuildContext context) builder;\n\n  @override\n  State<UseCaseBuilder> createState() => _UseCaseBuilderState();\n}\n\nclass _UseCaseBuilderState extends State<UseCaseBuilder> {\n  @override\n  void initState() {\n    super.initState();\n\n    // Notify that the use case finished building,\n    // to rebuild the use case with all registered knobs\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      if (mounted) {\n        WidgetbookState.of(context).knobs.lock();\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Clear all registered knobs before building the use case.\n    // When use case is rebuilt, knobs will be re-registered.\n    // This ensures that only the knobs used in the current use case are kept and ordered correctly.\n    WidgetbookState.of(context).knobs.clear();\n    return widget.builder(context);\n  }\n}\n"
      },
      "Workbench": {
        "workbench": "import 'package:flutter/material.dart';\nimport 'package:meta/meta.dart';\n\nimport '../addons/addons.dart' hide WidgetbookTheme;\nimport '../fields/fields.dart';\nimport '../state/state.dart';\nimport '../widgetbook_theme.dart';\nimport 'safe_boundaries.dart';\nimport 'use_case_builder.dart';\n\n/// The [Workbench] is the main widget that displays the current use case\n/// in the context of the [WidgetbookState]. It is responsible for building\n/// the use case and applying the necessary addons.\n@internal\nclass Workbench extends StatelessWidget {\n  const Workbench({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final state = WidgetbookState.of(context);\n    final useCase = state.useCase;\n\n    if (useCase == null) {\n      return state.home;\n    }\n\n    final theme = WidgetbookTheme.of(context);\n\n    return Scaffold(\n      // Some addons require a Scaffold to work properly.\n      body: SafeBoundaries(\n        child: state.appBuilder(\n          context,\n          ColoredBox(\n            // Background color for the area behind device frame if\n            // the [DeviceFrameAddon] is used.\n            color: theme.scaffoldBackgroundColor,\n            child: MultiAddonBuilder(\n              addons: state.addons,\n              builder: (context, addon, child) {\n                final state = WidgetbookState.of(context);\n                final groupMap = FieldCodec.decodeQueryGroup(\n                  state.queryParams[addon.groupName],\n                );\n\n                final newSetting = addon.valueFromQueryGroup(groupMap);\n\n                return addon.buildUseCase(\n                  context,\n                  child,\n                  newSetting,\n                );\n              },\n              child: Builder(\n                builder: (context) {\n                  // Get a fresh state that has updated addons,\n                  // as the `state` variable from above might\n                  // be outdated.\n                  final state = WidgetbookState.of(context);\n\n                  return Stack(\n                    // The Stack is used to loosen the constraints of\n                    // the UseCaseBuilder. Without the Stack, UseCaseBuilder\n                    // would expand to the whole size of the Workbench.\n                    children: [\n                      UseCaseBuilder(\n                        key: ValueKey(state.uri),\n                        builder: (context) {\n                          final useCase = state.useCase;\n                          return useCase?.build(context) ??\n                              const SizedBox.shrink();\n                        },\n                      ),\n                    ],\n                  );\n                },\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
      }
    }
  }
}