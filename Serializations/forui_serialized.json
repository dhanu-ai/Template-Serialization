{
  "forui": {
    "Accordion": {
      "accordion": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\npart 'accordion.design.dart';\n\n/// A vertically stacked set of interactive headings, each revealing a section of content.\n///\n/// See:\n/// * https://forui.dev/docs/data/accordion for working examples.\n/// * [FAccordionController] for customizing the accordion's behavior.\n/// * [FAccordionItem] for adding items to an accordion.\n/// * [FAccordionStyle] for customizing an accordion's appearance.\nclass FAccordion extends StatefulWidget {\n  /// The controller. Defaults to [FAccordionController.new].\n  final FAccordionController? controller;\n\n  /// The style. Defaults to [FThemeData.accordionStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create accordion\n  /// ```\n  final FAccordionStyle Function(FAccordionStyle style)? style;\n\n  /// The individual accordion items and separators.\n  ///\n  /// ## Contract\n  /// An accordion item must mix-in [FAccordionItemMixin]. Not doing so will result in the item being treated as a\n  /// separator and cause undefined behavior.\n  final List<Widget> children;\n\n  /// Creates a [FAccordion].\n  const FAccordion({required this.children, this.controller, this.style, super.key});\n\n  @override\n  State<FAccordion> createState() => _FAccordionState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style));\n  }\n}\n\nclass _FAccordionState extends State<FAccordion> {\n  late FAccordionController _controller = widget.controller ?? FAccordionController();\n\n  @override\n  void didUpdateWidget(covariant FAccordion old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      }\n      _controller = widget.controller ?? FAccordionController();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.accordionStyle) ?? context.theme.accordionStyle;\n    return Column(\n      children: [\n        for (final (index, child) in widget.children.indexed)\n          if (child is FAccordionItemMixin)\n            InheritedAccordionData(index: index, controller: _controller, style: style, child: child)\n          else\n            child,\n      ],\n    );\n  }\n}\n\n@internal\nclass InheritedAccordionData extends InheritedWidget {\n  @useResult\n  static InheritedAccordionData of(BuildContext context) {\n    assert(debugCheckHasAncestor<InheritedAccordionData>('$FAccordion', context));\n    return context.dependOnInheritedWidgetOfExactType<InheritedAccordionData>()!;\n  }\n\n  final FAccordionController controller;\n  final FAccordionStyle style;\n  final int index;\n\n  const InheritedAccordionData({\n    required this.controller,\n    required this.style,\n    required this.index,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(covariant InheritedAccordionData old) =>\n      controller != old.controller || style != old.style || index != old.index;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(IntProperty('index', index));\n  }\n}\n\n/// The [FAccordion]'s style.\nclass FAccordionStyle with Diagnosticable, _$FAccordionStyleFunctions {\n  /// The title's text style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.tappable}\n  @override\n  final FWidgetStateMap<TextStyle> titleTextStyle;\n\n  /// The child's default text style.\n  @override\n  final TextStyle childTextStyle;\n\n  /// The padding around the title. Defaults to `EdgeInsets.symmetric(vertical: 15)`.\n  @override\n  final EdgeInsetsGeometry titlePadding;\n\n  /// The padding around the content. Defaults to `EdgeInsets.only(bottom: 15)`.\n  @override\n  final EdgeInsetsGeometry childPadding;\n\n  /// The icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.tappable}\n  @override\n  final FWidgetStateMap<IconThemeData> iconStyle;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// The divider's color.\n  @override\n  final FDividerStyle dividerStyle;\n\n  /// The tappable's style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// The motion-related properties.\n  @override\n  final FAccordionMotion motion;\n\n  /// Creates a [FAccordionStyle].\n  const FAccordionStyle({\n    required this.titleTextStyle,\n    required this.childTextStyle,\n    required this.iconStyle,\n    required this.focusedOutlineStyle,\n    required this.dividerStyle,\n    required this.tappableStyle,\n    this.titlePadding = const EdgeInsets.symmetric(vertical: 15),\n    this.childPadding = const EdgeInsets.only(bottom: 15),\n    this.motion = const FAccordionMotion(),\n  });\n\n  /// Creates a [FDividerStyles] that inherits its properties.\n  FAccordionStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        titleTextStyle: FWidgetStateMap({\n          WidgetState.hovered | WidgetState.pressed: typography.base.copyWith(\n            fontWeight: FontWeight.w500,\n            color: colors.foreground,\n            decoration: TextDecoration.underline,\n          ),\n          WidgetState.any: typography.base.copyWith(fontWeight: FontWeight.w500, color: colors.foreground),\n        }),\n        childTextStyle: typography.sm.copyWith(color: colors.foreground),\n        iconStyle: FWidgetStateMap.all(IconThemeData(color: colors.mutedForeground, size: 20)),\n        focusedOutlineStyle: style.focusedOutlineStyle,\n        dividerStyle: FDividerStyle(color: colors.border, padding: EdgeInsets.zero),\n        tappableStyle: style.tappableStyle.copyWith(motion: FTappableMotion.none),\n      );\n}\n\n/// Motion-related properties for [FAccordion].\nclass FAccordionMotion with Diagnosticable, _$FAccordionMotionFunctions {\n  /// A [FAccordionMotion] with no motion effects.\n  static const FAccordionMotion none = FAccordionMotion(\n    revealTween: FImmutableTween(begin: 1, end: 1),\n    iconTween: FImmutableTween(begin: 1, end: 1),\n  );\n\n  /// The expand animation's duration. Defaults to 200ms.\n  @override\n  final Duration expandDuration;\n\n  /// The collapse animation's duration. Defaults to 200ms.\n  @override\n  final Duration collapseDuration;\n\n  /// The expand animation's curve. Defaults to [Curves.easeOutCubic].\n  ///\n  /// It is recommended to change this and [collapseCurve] to [Curves.linear] if there is a max number of items shown\n  /// at once to avoid the height jumping effect.\n  @override\n  final Curve expandCurve;\n\n  /// The collapse animation's curve. Defaults to [Curves.easeInCubic].\n  @override\n  final Curve collapseCurve;\n\n  /// The icon's animation curve when expanding. Defaults to [Curves.easeOut].\n  @override\n  final Curve iconExpandCurve;\n\n  /// The icon's animation curve when collapsing. Defaults to [Curves.easeOut].\n  @override\n  final Curve iconCollapseCurve;\n\n  /// The reveal animation's tween. Defaults to `FImmutableTween(begin: 0.0, end: 1.0)`.\n  @override\n  final Animatable<double> revealTween;\n\n  /// The icon animation's tween. Defaults to `FImmutableTween(begin: 0.0, end: 0.5)`.\n  @override\n  final Animatable<double> iconTween;\n\n  /// Creates a [FAccordionMotion].\n  const FAccordionMotion({\n    this.expandDuration = const Duration(milliseconds: 200),\n    this.expandCurve = Curves.easeOutCubic,\n    this.collapseDuration = const Duration(milliseconds: 200),\n    this.collapseCurve = Curves.easeInCubic,\n    this.iconExpandCurve = Curves.easeOut,\n    this.iconCollapseCurve = Curves.easeOut,\n    this.revealTween = const FImmutableTween(begin: 0.0, end: 1.0),\n    this.iconTween = const FImmutableTween(begin: 0.0, end: 0.50),\n  });\n}\n",
      "accordion_controller": "import 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n/// A controller shows and hides items in an [FAccordion].\n///\n/// When the maximum number of expanded items is reached, it automatically collapses the least recently expanded item\n/// to make room for new expansions.\n///\n/// Methods like [toggle], [expand], and [collapse] will not work during [State.initState] or before the accordion\n/// items are built. Use [FAccordionItem.initiallyExpanded] instead.\nclass FAccordionController extends FChangeNotifier {\n  final Map<int, AnimationController> _controllers;\n  final Set<int> _expanded;\n  final int _min;\n  final int? _max;\n\n  /// Creates a [FAccordionController].\n  ///\n  /// [min] and [max] define the minimum and maximum number of expanded items allowed.\n  ///\n  /// # Contract:\n  /// [min] and [max] must be: `0 <= min <= max`.\n  FAccordionController({int min = 0, int? max})\n    : _controllers = {},\n      _expanded = {},\n      _min = min,\n      _max = max,\n      assert(debugCheckInclusiveRange<FAccordionController>(min, max));\n\n  /// Toggles the item at the given [index], expanding it if it is collapsed and vice versa.\n  ///\n  /// This method should not be called while the widget tree is being rebuilt.\n  Future<bool> toggle(int index) async => switch (_controllers[index]?.status) {\n    null => false,\n    final status when status.isForwardOrCompleted => await collapse(index),\n    _ => await expand(index),\n  };\n\n  /// Expands the item at the given [index], returning true if successfully expanded. It collapses the least recently\n  /// expanded item if the maximum number of expanded items is reached.\n  ///\n  /// This method should typically not be called while the widget tree is being rebuilt.\n  Future<bool> expand(int index) async {\n    final controller = _controllers[index];\n    if (_expanded.contains(index) || controller == null) {\n      return false;\n    }\n\n    final futures = <Future<void>>[];\n    if (_max != null && _max <= _expanded.length) {\n      final collapsing = _expanded.firstOrNull;\n      if (collapsing == null) {\n        return false;\n      }\n\n      _expanded.remove(collapsing);\n      futures.add(_controllers[collapsing]!.reverse());\n    }\n\n    _expanded.add(index);\n    futures.add(controller.forward());\n\n    await Future.wait(futures);\n    notifyListeners();\n\n    return true;\n  }\n\n  /// Collapses the item at the given [index], returning true if successfully collapsed.\n  ///\n  /// This method should typically not be called while the widget tree is being rebuilt.\n  Future<bool> collapse(int index) async {\n    if (controllers[index] == null || _expanded.length <= _min || !_expanded.contains(index)) {\n      return false;\n    }\n\n    _expanded.remove(index);\n    await _controllers[index]!.reverse();\n\n    notifyListeners();\n\n    return true;\n  }\n\n  /// The indexes of the currently expanded items.\n  Set<int> get expanded => {..._expanded};\n}\n\n@internal\nextension InternalAccordionController on FAccordionController {\n  /// Adds an item at the given [index], returning true if added.\n  bool add(int index, AnimationController controller) {\n    if (controller.value == 1 && _max != null && _max <= _expanded.length) {\n      return false;\n    }\n\n    _controllers[index] = controller;\n    if (controller.value == 1) {\n      _expanded.add(index);\n    }\n\n    return true;\n  }\n\n  /// Removes the item at the given [index], returning true if removed.\n  bool remove(int index) {\n    if (_expanded.length <= _min && _expanded.contains(index)) {\n      return false;\n    }\n\n    final removed = _controllers.remove(index);\n    _expanded.remove(index);\n    return removed != null;\n  }\n\n  @visibleForTesting\n  Map<int, AnimationController> get controllers => _controllers;\n}\n",
      "accordion_item": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/accordion/accordion.dart';\nimport 'package:forui/src/widgets/accordion/accordion_controller.dart';\n\n/// A marker interface which denotes that mixed-in widgets can be used in a [FAccordion].\nmixin FAccordionItemMixin on Widget {}\n\n/// An interactive heading that reveals a section of content.\n///\n/// See:\n/// * https://forui.dev/docs/data/accordion for working examples.\nclass FAccordionItem extends StatefulWidget with FAccordionItemMixin {\n  /// The accordion's style. Defaults to [FThemeData.accordionStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create accordion\n  /// ```\n  final FAccordionStyle? style;\n\n  /// The title.\n  final Widget title;\n\n  /// The icon, wrapped in a [IconTheme]. Defaults to `Icon(FIcons.chevronRight)`.\n  final Widget icon;\n\n  /// True if the item is initially expanded.\n  final bool initiallyExpanded;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// {@macro forui.foundation.FTappable.onHoverChange}\n  final ValueChanged<bool>? onHoverChange;\n\n  /// {@macro forui.foundation.FTappable.onStateChange}\n  final ValueChanged<FWidgetStatesDelta>? onStateChange;\n\n  /// The child.\n  final Widget child;\n\n  /// Creates an [FAccordionItem].\n  const FAccordionItem({\n    required this.title,\n    required this.child,\n    this.style,\n    this.icon = const Icon(FIcons.chevronDown),\n    this.initiallyExpanded = false,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    super.key,\n  });\n\n  @override\n  State<FAccordionItem> createState() => _FAccordionItemState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('initiallyExpanded', value: initiallyExpanded, ifTrue: 'Initially expanded'))\n      ..add(FlagProperty('autofocus', value: autofocus, defaultValue: false, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onStateChange', onStateChange));\n  }\n}\n\nclass _FAccordionItemState extends State<FAccordionItem> with TickerProviderStateMixin {\n  AnimationController? _controller;\n  CurvedAnimation? _curvedReveal;\n  CurvedAnimation? _curvedIconRotation;\n  Animation<double>? _reveal;\n  Animation<double>? _iconRotation;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n\n    final InheritedAccordionData(:index, :controller, :style) = InheritedAccordionData.of(context);\n    controller.remove(index);\n\n    _curvedReveal?.dispose();\n    _curvedIconRotation?.dispose();\n    _controller?.dispose();\n\n    _controller = AnimationController(\n      vsync: this,\n      value: widget.initiallyExpanded ? 1 : 0,\n      duration: style.motion.expandDuration,\n      reverseDuration: style.motion.collapseDuration,\n    );\n    _curvedReveal = CurvedAnimation(\n      curve: style.motion.expandCurve,\n      reverseCurve: style.motion.collapseCurve,\n      parent: _controller!,\n    );\n    _curvedIconRotation = CurvedAnimation(\n      curve: style.motion.iconExpandCurve,\n      reverseCurve: style.motion.iconCollapseCurve,\n      parent: _controller!,\n    );\n    _reveal = style.motion.revealTween.animate(_curvedReveal!);\n    _iconRotation = style.motion.iconTween.animate(_curvedIconRotation!);\n\n    if (!controller.add(index, _controller!)) {\n      throw StateError('Number of expanded items must be within the min and max.');\n    }\n  }\n\n  @override\n  void dispose() {\n    _curvedIconRotation?.dispose();\n    _curvedReveal?.dispose();\n    _controller?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedAccordionData(:index, :controller, style: inheritedStyle) = InheritedAccordionData.of(context);\n    final style = widget.style ?? inheritedStyle;\n\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: [\n        FTappable(\n          style: style.tappableStyle,\n          autofocus: widget.autofocus,\n          focusNode: widget.focusNode,\n          onFocusChange: widget.onFocusChange,\n          onHoverChange: widget.onHoverChange,\n          onStateChange: widget.onStateChange,\n          onPress: () => controller.toggle(index),\n          builder: (_, states, _) => Padding(\n            padding: style.titlePadding,\n            child: Row(\n              children: [\n                Expanded(\n                  child: DefaultTextStyle.merge(\n                    textHeightBehavior: const TextHeightBehavior(\n                      applyHeightToFirstAscent: false,\n                      applyHeightToLastDescent: false,\n                    ),\n                    style: style.titleTextStyle.resolve(states),\n                    child: widget.title,\n                  ),\n                ),\n                FFocusedOutline(\n                  style: style.focusedOutlineStyle,\n                  focused: states.contains(WidgetState.focused),\n                  child: RotationTransition(\n                    turns: _iconRotation!,\n                    child: IconTheme(data: style.iconStyle.resolve(states), child: widget.icon),\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ),\n        AnimatedBuilder(\n          animation: _reveal!,\n          builder: (_, _) => FCollapsible(\n            value: _reveal!.value,\n            child: Padding(\n              padding: style.childPadding,\n              child: DefaultTextStyle(style: style.childTextStyle, child: widget.child),\n            ),\n          ),\n        ),\n        FDivider(style: style.dividerStyle),\n      ],\n    );\n  }\n}\n"
    },
    "Autocomplete": {
      "autocomplete": "import 'dart:async';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/autocomplete/autocomplete_content.dart';\nimport 'package:forui/src/widgets/autocomplete/autocomplete_controller.dart';\nimport 'package:forui/src/widgets/autocomplete/skip_delegate_traversal_policy.dart';\n\npart 'autocomplete.design.dart';\n\n/// A builder for [FAutocomplete]'s results.\ntypedef FAutoCompleteContentBuilder =\n    List<FAutocompleteItemMixin> Function(BuildContext context, String query, Iterable<String> values);\n\n/// An autocomplete provides a list of suggestions based on the user's input and shows typeahead text for the first match.\n///\n/// It is a [FormField] and therefore can be used in a [Form] widget.\n///\n/// ## Note\n/// The autocomplete does not support using arrow keys to navigate the suggestions on web.\n///\n/// See:\n/// * https://forui.dev/docs/form/autocomplete for working examples.\n/// * [FAutocompleteController] for customizing the behavior of an autocomplete.\n/// * [FAutocompleteStyle] for customizing the appearance of an autocomplete.\nclass FAutocomplete extends StatefulWidget with FFormFieldProperties<String> {\n  /// The default loading builder that shows a spinner when an asynchronous search is pending.\n  static Widget defaultContentLoadingBuilder(BuildContext _, FAutocompleteContentStyle style) => Padding(\n    padding: const EdgeInsets.all(13),\n    child: FCircularProgress(style: style.progressStyle),\n  );\n\n  /// The default empty builder that shows a localized message when there are no results.\n  static Widget defaultContentEmptyBuilder(BuildContext context, FAutocompleteContentStyle style) {\n    final localizations = FLocalizations.of(context) ?? FDefaultLocalizations();\n    return Padding(\n      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 14),\n      child: Text(localizations.autocompleteNoResults, style: style.emptyTextStyle),\n    );\n  }\n\n  static bool _clearable(TextEditingValue _) => false;\n\n  static Widget _builder(BuildContext _, FAutocompleteStyle _, Set<WidgetState> _, Widget? child) => child!;\n\n  /// The controller.\n  final FAutocompleteController? controller;\n\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create autocomplete\n  /// ```\n  final FAutocompleteStyle Function(FAutocompleteStyle style)? style;\n\n  /// {@macro forui.text_field.label}\n  @override\n  final Widget? label;\n\n  /// {@macro forui.text_field.hint}\n  final String? hint;\n\n  /// {@macro forui.text_field.description}\n  @override\n  final Widget? description;\n\n  /// {@macro forui.text_field.magnifier_configuration}\n  final TextMagnifierConfiguration? magnifierConfiguration;\n\n  /// {@macro forui.text_field_groupId}\n  final Object groupId;\n\n  /// {@macro forui.text_field.keyboardType}\n  final TextInputType? keyboardType;\n\n  /// {@macro forui.text_field.textInputAction}\n  final TextInputAction? textInputAction;\n\n  /// {@macro forui.text_field.textCapitalization}\n  final TextCapitalization textCapitalization;\n\n  /// {@macro forui.text_field.textAlign}\n  final TextAlign textAlign;\n\n  /// {@macro forui.text_field.textAlignVertical}\n  final TextAlignVertical? textAlignVertical;\n\n  /// {@macro forui.text_field.textDirection}\n  final TextDirection? textDirection;\n\n  /// {@macro forui.text_field.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.text_field.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.text_field.statesController}\n  final WidgetStatesController? statesController;\n\n  /// {@macro forui.text_field.obscuringCharacter}\n  final String obscuringCharacter;\n\n  /// {@macro forui.text_field.obscureText}\n  final bool obscureText;\n\n  /// {@macro forui.text_field.autocorrect}\n  final bool autocorrect;\n\n  /// {@macro forui.text_field.smartDashesType}\n  final SmartDashesType? smartDashesType;\n\n  /// {@macro forui.text_field.smartQuotesType}\n  final SmartQuotesType? smartQuotesType;\n\n  /// {@macro forui.text_field.enableSuggestions}\n  final bool enableSuggestions;\n\n  /// {@macro forui.text_field.minLines}\n  final int? minLines;\n\n  /// {@macro forui.text_field.maxLines}\n  final int? maxLines;\n\n  /// {@macro forui.text_field.expands}\n  final bool expands;\n\n  /// {@macro forui.text_field.readOnly}\n  final bool readOnly;\n\n  /// {@macro forui.text_field.showCursor}\n  final bool? showCursor;\n\n  /// {@macro forui.text_field.maxLength}\n  final int? maxLength;\n\n  /// {@macro forui.text_field.maxLengthEnforcement}\n  final MaxLengthEnforcement? maxLengthEnforcement;\n\n  /// {@macro forui.text_field.onChange}\n  final ValueChanged<String>? onChange;\n\n  /// {@macro forui.text_field.onTap}\n  final bool onTapAlwaysCalled;\n\n  /// {@macro forui.text_field.onEditingComplete}\n  final VoidCallback? onEditingComplete;\n\n  /// {@macro forui.text_field.onSubmit}\n  final ValueChanged<String>? onSubmit;\n\n  /// {@macro forui.text_field.onAppPrivateCommand}\n  final AppPrivateCommandCallback? onAppPrivateCommand;\n\n  /// {@macro forui.text_field.inputFormatters}\n  final List<TextInputFormatter>? inputFormatters;\n\n  /// {@macro forui.text_field.enabled}\n  @override\n  final bool enabled;\n\n  /// {@macro forui.text_field.ignorePointers}\n  final bool? ignorePointers;\n\n  /// {@macro forui.text_field.enableInteractiveSelection}\n  final bool enableInteractiveSelection;\n\n  /// {@macro forui.text_field.selectionControls}\n  final TextSelectionControls? selectionControls;\n\n  /// {@macro forui.text_field.dragStartBehavior}\n  final DragStartBehavior dragStartBehavior;\n\n  /// {@macro forui.text_field.mouseCursor}\n  final MouseCursor? mouseCursor;\n\n  /// {@macro forui.text_field.counterBuilder}\n  final FTextFieldCounterBuilder? counterBuilder;\n\n  /// {@macro forui.text_field.scrollPhysics}\n  final ScrollPhysics? scrollPhysics;\n\n  /// {@macro forui.text_field.scrollController}\n  final ScrollController? scrollController;\n\n  /// {@macro forui.text_field.autofillHints}\n  final Iterable<String>? autofillHints;\n\n  /// {@macro forui.text_field.restorationId}\n  final String? restorationId;\n\n  /// {@macro forui.text_field.stylusHandwritingEnabled}\n  final bool stylusHandwritingEnabled;\n\n  /// {@macro forui.text_field.enableIMEPersonalizedLearning}\n  final bool enableIMEPersonalizedLearning;\n\n  /// {@macro forui.text_field.contentInsertionConfiguration}\n  final ContentInsertionConfiguration? contentInsertionConfiguration;\n\n  /// {@macro forui.text_field.contextMenuBuilder}\n  final EditableTextContextMenuBuilder? contextMenuBuilder;\n\n  /// {@macro forui.text_field.canRequestFocus}\n  final bool canRequestFocus;\n\n  /// {@macro forui.text_field.undoController}\n  final UndoHistoryController? undoController;\n\n  /// {@macro forui.text_field.spellCheckConfiguration}\n  final SpellCheckConfiguration? spellCheckConfiguration;\n\n  /// {@macro forui.text_field.prefixBuilder}\n  final FFieldIconBuilder<FAutocompleteStyle>? prefixBuilder;\n\n  /// {@macro forui.text_field.suffixBuilder}\n  final FFieldIconBuilder<FAutocompleteStyle>? suffixBuilder;\n\n  /// {@macro forui.text_field.clearable}\n  final bool Function(TextEditingValue value) clearable;\n\n  @override\n  final FormFieldSetter<String>? onSaved;\n\n  @override\n  final VoidCallback? onReset;\n\n  @override\n  final FormFieldValidator<String>? validator;\n\n  /// {@macro forui.text_field.initialValue}\n  final String? initialText;\n\n  @override\n  final AutovalidateMode autovalidateMode;\n\n  @override\n  final String? forceErrorText;\n\n  @override\n  final Widget Function(BuildContext context, String message) errorBuilder;\n\n  /// The alignment point on the content popover. Defaults to [AlignmentDirectional.topStart].\n  final AlignmentGeometry anchor;\n\n  /// The alignment point on the select's field. Defaults to [AlignmentDirectional.bottomStart].\n  final AlignmentGeometry fieldAnchor;\n\n  /// The constraints to apply to the content popover. Defaults to `const FAutoWidthPortalConstraints(maxHeight: 300)`.\n  final FPortalConstraints popoverConstraints;\n\n  /// {@macro forui.widgets.FPopover.spacing}\n  final FPortalSpacing spacing;\n\n  /// {@macro forui.widgets.FPopover.overflow}\n  final FPortalOverflow overflow;\n\n  /// {@macro forui.widgets.FPopover.offset}\n  final Offset offset;\n\n  /// {@macro forui.widgets.FPopover.hideRegion}\n  final FPopoverHideRegion hideRegion;\n\n  /// {@macro forui.widgets.FPopover.onTapHide}\n  final VoidCallback? onTapHide;\n\n  /// True if the content should be automatically hidden after an item is selected. Defaults to false.\n  final bool autoHide;\n\n  /// The builder used to decorate the autocomplete. It should always use the given child.\n  ///\n  /// Defaults to returning the given child.\n  final FFieldBuilder<FAutocompleteStyle> builder;\n\n  /// Whether the autocomplete should complete the text when a completion is available and the user presses right arrow.\n  /// Defaults to false.\n  final bool rightArrowToComplete;\n\n  /// A callback that produces a list of items based on the query either synchronously or asynchronously.\n  final FutureOr<Iterable<String>> Function(String text) filter;\n\n  /// The builder that is called when the select is empty. Defaults to [defaultContentEmptyBuilder].\n  final Widget Function(BuildContext context, FAutocompleteContentStyle style) contentEmptyBuilder;\n\n  /// The content's scroll controller.\n  final ScrollController? contentScrollController;\n\n  /// The content's scroll physics. Defaults to [ClampingScrollPhysics].\n  final ScrollPhysics contentPhysics;\n\n  /// The divider used to separate the content items. Defaults to [FItemDivider.none].\n  final FItemDivider contentDivider;\n\n  /// A callback builds the list of items based on search results returned by [filter].\n  final FAutoCompleteContentBuilder contentBuilder;\n\n  /// A callback that is used to show a loading indicator while the results is processed.\n  final Widget Function(BuildContext context, FAutocompleteContentStyle style) contentLoadingBuilder;\n\n  /// A callback that is used to show an error message when [filter] is asynchronous and fails.\n  final Widget Function(BuildContext context, Object? error, StackTrace stackTrace)? contentErrorBuilder;\n\n  /// Creates a [FAutocomplete] from the given [items].\n  ///\n  /// For more control over the appearance of items, use [FAutocomplete.builder].\n  FAutocomplete({\n    required List<String> items,\n    FAutocompleteStyle Function(FAutocompleteStyle style)? style,\n    Widget? label,\n    String? hint,\n    Widget? description,\n    TextMagnifierConfiguration? magnifierConfiguration,\n    Object groupId = EditableText,\n    FAutocompleteController? controller,\n    FocusNode? focusNode,\n    TextInputType? keyboardType,\n    TextInputAction? textInputAction,\n    TextCapitalization textCapitalization = TextCapitalization.none,\n    TextAlign textAlign = TextAlign.start,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    VoidCallback? onTapHide,\n    bool autofocus = false,\n    WidgetStatesController? statesController,\n    String obscuringCharacter = '\u2022',\n    bool obscureText = false,\n    bool autocorrect = true,\n    SmartDashesType? smartDashesType,\n    SmartQuotesType? smartQuotesType,\n    bool enableSuggestions = true,\n    int? minLines,\n    int? maxLines = 1,\n    bool expands = false,\n    bool readOnly = false,\n    bool? showCursor,\n    int? maxLength,\n    MaxLengthEnforcement? maxLengthEnforcement,\n    ValueChanged<String>? onChange,\n    bool onTapAlwaysCalled = false,\n    VoidCallback? onEditingComplete,\n    ValueChanged<String>? onSubmit,\n    AppPrivateCommandCallback? onAppPrivateCommand,\n    List<TextInputFormatter>? inputFormatters,\n    bool enabled = true,\n    bool? ignorePointers,\n    bool enableInteractiveSelection = true,\n    TextSelectionControls? selectionControls,\n    DragStartBehavior dragStartBehavior = DragStartBehavior.start,\n    MouseCursor? mouseCursor,\n    FTextFieldCounterBuilder? counterBuilder,\n    ScrollPhysics? scrollPhysics,\n    ScrollController? scrollController,\n    Iterable<String>? autofillHints,\n    String? restorationId,\n    bool stylusHandwritingEnabled = true,\n    bool enableIMEPersonalizedLearning = true,\n    ContentInsertionConfiguration? contentInsertionConfiguration,\n    EditableTextContextMenuBuilder? contextMenuBuilder,\n    bool canRequestFocus = true,\n    UndoHistoryController? undoController,\n    SpellCheckConfiguration? spellCheckConfiguration,\n    FFieldIconBuilder<FAutocompleteStyle>? prefixBuilder,\n    FFieldIconBuilder<FAutocompleteStyle>? suffixBuilder,\n    bool Function(TextEditingValue value) clearable = _clearable,\n    FormFieldSetter<String>? onSaved,\n    VoidCallback? onReset,\n    FormFieldValidator<String>? validator,\n    String? initialText,\n    AutovalidateMode autovalidateMode = AutovalidateMode.disabled,\n    String? forceErrorText,\n    Widget Function(BuildContext context, String message) errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    AlignmentGeometry anchor = AlignmentDirectional.topStart,\n    AlignmentGeometry fieldAnchor = AlignmentDirectional.bottomStart,\n    FPortalConstraints popoverConstraints = const FAutoWidthPortalConstraints(maxHeight: 300),\n    FPortalSpacing spacing = const FPortalSpacing(4),\n    FPortalOverflow overflow = FPortalOverflow.flip,\n    Offset offset = Offset.zero,\n    FPopoverHideRegion hideRegion = FPopoverHideRegion.excludeChild,\n    bool autoHide = true,\n    FFieldBuilder<FAutocompleteStyle> builder = _builder,\n    bool rightArrowToComplete = false,\n    FutureOr<Iterable<String>> Function(String query)? filter,\n    FAutoCompleteContentBuilder? contentBuilder,\n    ScrollController? contentScrollController,\n    ScrollPhysics contentPhysics = const ClampingScrollPhysics(),\n    FItemDivider contentDivider = FItemDivider.none,\n    Widget Function(BuildContext context, FAutocompleteContentStyle style) contentEmptyBuilder =\n        defaultContentEmptyBuilder,\n    Widget Function(BuildContext context, FAutocompleteContentStyle style) contentLoadingBuilder =\n        defaultContentLoadingBuilder,\n    Widget Function(BuildContext context, Object? error, StackTrace stackTrace)? contentErrorBuilder,\n    Key? key,\n  }) : this.builder(\n         filter: filter ?? (query) => items.where((item) => item.toLowerCase().startsWith(query.toLowerCase())),\n         contentBuilder:\n             contentBuilder ??\n             (context, query, values) => [for (final value in values) FAutocompleteItem(value: value)],\n         style: style,\n         label: label,\n         hint: hint,\n         description: description,\n         magnifierConfiguration: magnifierConfiguration,\n         groupId: groupId,\n         controller: controller,\n         focusNode: focusNode,\n         keyboardType: keyboardType,\n         textInputAction: textInputAction,\n         textCapitalization: textCapitalization,\n         textAlign: textAlign,\n         textAlignVertical: textAlignVertical,\n         textDirection: textDirection,\n         onTapHide: onTapHide,\n         autofocus: autofocus,\n         statesController: statesController,\n         obscuringCharacter: obscuringCharacter,\n         obscureText: obscureText,\n         autocorrect: autocorrect,\n         smartDashesType: smartDashesType,\n         smartQuotesType: smartQuotesType,\n         enableSuggestions: enableSuggestions,\n         minLines: minLines,\n         maxLines: maxLines,\n         expands: expands,\n         readOnly: readOnly,\n         showCursor: showCursor,\n         maxLength: maxLength,\n         maxLengthEnforcement: maxLengthEnforcement,\n         onChange: onChange,\n         onTapAlwaysCalled: onTapAlwaysCalled,\n         onEditingComplete: onEditingComplete,\n         onSubmit: onSubmit,\n         onAppPrivateCommand: onAppPrivateCommand,\n         inputFormatters: inputFormatters,\n         enabled: enabled,\n         ignorePointers: ignorePointers,\n         enableInteractiveSelection: enableInteractiveSelection,\n         selectionControls: selectionControls,\n         dragStartBehavior: dragStartBehavior,\n         mouseCursor: mouseCursor,\n         counterBuilder: counterBuilder,\n         scrollPhysics: scrollPhysics,\n         scrollController: scrollController,\n         autofillHints: autofillHints,\n         restorationId: restorationId,\n         stylusHandwritingEnabled: stylusHandwritingEnabled,\n         enableIMEPersonalizedLearning: enableIMEPersonalizedLearning,\n         contentInsertionConfiguration: contentInsertionConfiguration,\n         contextMenuBuilder: contextMenuBuilder,\n         canRequestFocus: canRequestFocus,\n         undoController: undoController,\n         spellCheckConfiguration: spellCheckConfiguration,\n         prefixBuilder: prefixBuilder,\n         suffixBuilder: suffixBuilder,\n         clearable: clearable,\n         onSaved: onSaved,\n         onReset: onReset,\n         validator: validator,\n         initialText: initialText,\n         autovalidateMode: autovalidateMode,\n         forceErrorText: forceErrorText,\n         errorBuilder: errorBuilder,\n         anchor: anchor,\n         fieldAnchor: fieldAnchor,\n         popoverConstraints: popoverConstraints,\n         spacing: spacing,\n         overflow: overflow,\n         offset: offset,\n         hideRegion: hideRegion,\n         autoHide: autoHide,\n         builder: builder,\n         rightArrowToComplete: rightArrowToComplete,\n         contentScrollController: contentScrollController,\n         contentPhysics: contentPhysics,\n         contentDivider: contentDivider,\n         contentEmptyBuilder: contentEmptyBuilder,\n         contentLoadingBuilder: contentLoadingBuilder,\n         contentErrorBuilder: contentErrorBuilder,\n         key: key,\n       );\n\n  /// Creates a [FAutocomplete] that uses the given [filter] to determine the results and the [contentBuilder] to build\n  /// the content.\n  const FAutocomplete.builder({\n    required this.filter,\n    required this.contentBuilder,\n    this.style,\n    this.label,\n    this.hint,\n    this.description,\n    this.magnifierConfiguration,\n    this.groupId = EditableText,\n    this.controller,\n    this.focusNode,\n    this.keyboardType,\n    this.textInputAction,\n    this.textCapitalization = TextCapitalization.none,\n    this.textAlign = TextAlign.start,\n    this.textAlignVertical,\n    this.textDirection,\n    this.onTapHide,\n    this.autofocus = false,\n    this.statesController,\n    this.obscuringCharacter = '\u2022',\n    this.obscureText = false,\n    this.autocorrect = true,\n    this.smartDashesType,\n    this.smartQuotesType,\n    this.enableSuggestions = true,\n    this.minLines,\n    this.maxLines = 1,\n    this.expands = false,\n    this.readOnly = false,\n    this.showCursor,\n    this.maxLength,\n    this.maxLengthEnforcement,\n    this.onChange,\n    this.onTapAlwaysCalled = false,\n    this.onEditingComplete,\n    this.onSubmit,\n    this.onAppPrivateCommand,\n    this.inputFormatters,\n    this.enabled = true,\n    this.ignorePointers,\n    this.enableInteractiveSelection = true,\n    this.selectionControls,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.mouseCursor,\n    this.counterBuilder,\n    this.scrollPhysics,\n    this.scrollController,\n    this.autofillHints,\n    this.restorationId,\n    this.stylusHandwritingEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contentInsertionConfiguration,\n    this.contextMenuBuilder,\n    this.canRequestFocus = true,\n    this.undoController,\n    this.spellCheckConfiguration,\n    this.prefixBuilder,\n    this.suffixBuilder,\n    this.clearable = _clearable,\n    this.onSaved,\n    this.onReset,\n    this.validator,\n    this.initialText,\n    this.autovalidateMode = AutovalidateMode.disabled,\n    this.forceErrorText,\n    this.errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    this.anchor = AlignmentDirectional.topStart,\n    this.fieldAnchor = AlignmentDirectional.bottomStart,\n    this.popoverConstraints = const FAutoWidthPortalConstraints(maxHeight: 300),\n    this.spacing = const FPortalSpacing(4),\n    this.overflow = FPortalOverflow.flip,\n    this.offset = Offset.zero,\n    this.hideRegion = FPopoverHideRegion.excludeChild,\n    this.autoHide = true,\n    this.builder = _builder,\n    this.rightArrowToComplete = false,\n    this.contentScrollController,\n    this.contentPhysics = const ClampingScrollPhysics(),\n    this.contentDivider = FItemDivider.none,\n    this.contentEmptyBuilder = defaultContentEmptyBuilder,\n    this.contentLoadingBuilder = defaultContentLoadingBuilder,\n    this.contentErrorBuilder,\n    super.key,\n  }) : assert(\n         controller == null || initialText == null,\n         'Cannot provide both a controller and initialText. To fix, set the initial text directly in the controller.',\n       );\n\n  @override\n  State<FAutocomplete> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(StringProperty('hint', hint))\n      ..add(DiagnosticsProperty('magnifierConfiguration', magnifierConfiguration))\n      ..add(DiagnosticsProperty('groupId', groupId))\n      ..add(DiagnosticsProperty('keyboardType', keyboardType))\n      ..add(EnumProperty('textInputAction', textInputAction))\n      ..add(EnumProperty('textCapitalization', textCapitalization))\n      ..add(EnumProperty('textAlign', textAlign))\n      ..add(DiagnosticsProperty('textAlignVertical', textAlignVertical))\n      ..add(EnumProperty('textDirection', textDirection))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(DiagnosticsProperty('statesController', statesController))\n      ..add(StringProperty('obscuringCharacter', obscuringCharacter))\n      ..add(FlagProperty('obscureText', value: obscureText, ifTrue: 'obscureText'))\n      ..add(FlagProperty('autocorrect', value: autocorrect, ifTrue: 'autocorrect'))\n      ..add(EnumProperty('smartDashesType', smartDashesType))\n      ..add(EnumProperty('smartQuotesType', smartQuotesType))\n      ..add(FlagProperty('enableSuggestions', value: enableSuggestions, ifTrue: 'enableSuggestions'))\n      ..add(IntProperty('minLines', minLines))\n      ..add(IntProperty('maxLines', maxLines))\n      ..add(FlagProperty('expands', value: expands, ifTrue: 'expands'))\n      ..add(FlagProperty('readOnly', value: readOnly, ifTrue: 'readOnly'))\n      ..add(FlagProperty('showCursor', value: showCursor, ifTrue: 'showCursor'))\n      ..add(IntProperty('maxLength', maxLength))\n      ..add(EnumProperty('maxLengthEnforcement', maxLengthEnforcement))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(FlagProperty('onTapAlwaysCalled', value: onTapAlwaysCalled, ifTrue: 'onTapAlwaysCalled'))\n      ..add(ObjectFlagProperty.has('onEditingComplete', onEditingComplete))\n      ..add(ObjectFlagProperty.has('onSubmit', onSubmit))\n      ..add(ObjectFlagProperty.has('onAppPrivateCommand', onAppPrivateCommand))\n      ..add(IterableProperty('inputFormatters', inputFormatters))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(FlagProperty('ignorePointers', value: ignorePointers, ifTrue: 'ignorePointers'))\n      ..add(\n        FlagProperty('enableInteractSelection', value: enableInteractiveSelection, ifTrue: 'enableInteractSelection'),\n      )\n      ..add(DiagnosticsProperty('selectionControls', selectionControls))\n      ..add(EnumProperty('dragStartBehavior', dragStartBehavior))\n      ..add(DiagnosticsProperty('mouseCursor', mouseCursor))\n      ..add(ObjectFlagProperty.has('counterBuilder', counterBuilder))\n      ..add(DiagnosticsProperty('scrollPhysics', scrollPhysics))\n      ..add(DiagnosticsProperty('scrollController', scrollController))\n      ..add(IterableProperty('autofillHints', autofillHints))\n      ..add(StringProperty('restorationId', restorationId))\n      ..add(\n        FlagProperty('stylusHandwritingEnabled', value: stylusHandwritingEnabled, ifTrue: 'stylusHandwritingEnabled'),\n      )\n      ..add(\n        FlagProperty(\n          'enableIMEPersonalizedLearning',\n          value: enableIMEPersonalizedLearning,\n          ifTrue: 'enableIMEPersonalizedLearning',\n        ),\n      )\n      ..add(DiagnosticsProperty('contentInsertionConfiguration', contentInsertionConfiguration))\n      ..add(ObjectFlagProperty.has('contextMenuBuilder', contextMenuBuilder))\n      ..add(FlagProperty('canRequestFocus', value: canRequestFocus, ifTrue: 'canRequestFocus'))\n      ..add(DiagnosticsProperty('undoController', undoController))\n      ..add(DiagnosticsProperty('spellCheckConfiguration', spellCheckConfiguration))\n      ..add(ObjectFlagProperty.has('prefixBuilder', prefixBuilder))\n      ..add(ObjectFlagProperty.has('suffixBuilder', suffixBuilder))\n      ..add(ObjectFlagProperty.has('clearable', clearable))\n      ..add(ObjectFlagProperty.has('onSaved', onSaved))\n      ..add(ObjectFlagProperty.has('onReset', onReset))\n      ..add(ObjectFlagProperty.has('validator', validator))\n      ..add(StringProperty('initialText', initialText))\n      ..add(EnumProperty('autovalidateMode', autovalidateMode))\n      ..add(StringProperty('forceErrorText', forceErrorText))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder))\n      ..add(DiagnosticsProperty('anchor', anchor))\n      ..add(DiagnosticsProperty('fieldAnchor', fieldAnchor))\n      ..add(DiagnosticsProperty('popoverConstraints', popoverConstraints))\n      ..add(DiagnosticsProperty('spacing', spacing))\n      ..add(ObjectFlagProperty.has('overflow', overflow))\n      ..add(DiagnosticsProperty('offset', offset))\n      ..add(EnumProperty('hideRegion', hideRegion))\n      ..add(ObjectFlagProperty.has('onTapHide', onTapHide))\n      ..add(FlagProperty('autoHide', value: autoHide, ifTrue: 'autoHide'))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(FlagProperty('rightArrowToComplete', value: rightArrowToComplete, ifTrue: 'rightArrowToComplete'))\n      ..add(ObjectFlagProperty.has('filter', filter))\n      ..add(ObjectFlagProperty.has('contentEmptyBuilder', contentEmptyBuilder))\n      ..add(DiagnosticsProperty('contentScrollController', contentScrollController))\n      ..add(DiagnosticsProperty('contentPhysics', contentPhysics))\n      ..add(EnumProperty('contentDivider', contentDivider))\n      ..add(ObjectFlagProperty.has('contentBuilder', contentBuilder))\n      ..add(ObjectFlagProperty.has('contentLoadingBuilder', contentLoadingBuilder))\n      ..add(ObjectFlagProperty.has('contentErrorBuilder', contentErrorBuilder));\n  }\n}\n\nclass _State extends State<FAutocomplete> with SingleTickerProviderStateMixin {\n  late FAutocompleteController _controller;\n  late FutureOr<Iterable<String>> _data;\n  late FocusNode _fieldFocus;\n  late FocusScopeNode _popoverFocus;\n  bool _tapFocus = false;\n  String? _previous;\n\n  /// The original text used to restore the textfield when navigating but not selecting any completion using a keyboard.\n  String? _restore;\n\n  @override\n  void initState() {\n    super.initState();\n    _fieldFocus = widget.focusNode ?? FocusNode(debugLabel: 'FAutocomplete field');\n    _fieldFocus.addListener(_focus);\n    _controller = widget.controller ?? FAutocompleteController(vsync: this, text: widget.initialText);\n    _controller\n      ..addListener(_update)\n      ..loadSuggestions(_data = widget.filter(_controller.text));\n    _popoverFocus = FocusScopeNode(debugLabel: 'FAutocomplete popover');\n  }\n\n  @override\n  void didUpdateWidget(covariant FAutocomplete old) {\n    super.didUpdateWidget(old);\n    // DO NOT REORDER\n    if (widget.focusNode != old.focusNode) {\n      if (old.focusNode == null) {\n        _fieldFocus.dispose();\n      }\n      _fieldFocus = widget.focusNode ?? FocusNode(debugLabel: 'FAutocomplete field');\n    }\n\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        _controller.removeListener(_update);\n      }\n\n      _controller = widget.controller ?? FAutocompleteController(vsync: this, text: widget.initialText);\n      _controller\n        ..addListener(_update)\n        ..loadSuggestions(widget.filter(_controller.text));\n    }\n  }\n\n  void _update() {\n    if (_previous == _controller.text) {\n      return;\n    }\n\n    if (_fieldFocus.hasFocus && !_controller.content.status.isForwardOrCompleted) {\n      _controller.content.show();\n    }\n\n    setState(() {\n      _previous = _controller.text;\n      _controller.loadSuggestions(_data = widget.filter(_controller.text));\n    });\n  }\n\n  void _focus() {\n    // Check if the field gained focus because of the user tapping/tabbing into the autocomplete while completions are\n    // hidden.\n    if (_fieldFocus.hasFocus && _restore == null) {\n      if (!_tapFocus) {\n        _controller.selection = TextSelection(baseOffset: 0, extentOffset: _controller.text.length);\n      }\n      _tapFocus = false;\n      _controller.content.show();\n      // Hide the popover when the textfield loses focus and there are no completions to prevent focus from being trapped\n      // in the empty popover.\n    } else if (!_fieldFocus.hasFocus && _popoverFocus.descendants.isEmpty) {\n      _controller.content.hide();\n    }\n\n    _restore = null;\n  }\n\n  @override\n  void dispose() {\n    _popoverFocus.dispose();\n\n    if (widget.focusNode == null) {\n      _fieldFocus.dispose();\n    }\n\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeListener(_update);\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.autocompleteStyle) ?? context.theme.autocompleteStyle;\n    // On desktop, the textfield selects the entire text when focused (except when tapped). However, refocusing on the\n    // textfield after keyboard navigation of completions should NOT select the entire text.\n    //\n    // To work around this, we disable the default behavior by setting selectAllOnFocus to false and manage the focus\n    // behavior ourselves.\n    //\n    // Focus gained by taps are tracked using this Listener. We cannot use FTextField's onTap method since it is called\n    // AFTER its focus change callback. Subsequently the entire text is selected in the focus change callback only if\n    // it is not caused by a tap.\n    return Listener(\n      onPointerDown: (_) {\n        if (!_fieldFocus.hasFocus) {\n          _tapFocus = true;\n        }\n      },\n      child: FTextFormField(\n        style: style.fieldStyle,\n        label: widget.label,\n        hint: widget.hint,\n        description: widget.description,\n        magnifierConfiguration: widget.magnifierConfiguration,\n        groupId: widget.groupId,\n        controller: _controller,\n        focusNode: _fieldFocus,\n        keyboardType: widget.keyboardType,\n        textInputAction: widget.textInputAction,\n        textCapitalization: widget.textCapitalization,\n        textAlign: widget.textAlign,\n        textAlignVertical: widget.textAlignVertical,\n        textDirection: widget.textDirection,\n        autofocus: widget.autofocus,\n        statesController: widget.statesController,\n        obscuringCharacter: widget.obscuringCharacter,\n        obscureText: widget.obscureText,\n        autocorrect: widget.autocorrect,\n        smartDashesType: widget.smartDashesType,\n        smartQuotesType: widget.smartQuotesType,\n        enableSuggestions: widget.enableSuggestions,\n        minLines: widget.minLines,\n        maxLines: widget.maxLines,\n        expands: widget.expands,\n        readOnly: widget.readOnly,\n        showCursor: widget.showCursor,\n        maxLength: widget.maxLength,\n        maxLengthEnforcement: widget.maxLengthEnforcement,\n        onChange: widget.onChange,\n        onTap: _controller.content.show,\n        onTapAlwaysCalled: true,\n        onEditingComplete: widget.onEditingComplete,\n        onSubmit: widget.onSubmit,\n        onAppPrivateCommand: widget.onAppPrivateCommand,\n        inputFormatters: widget.inputFormatters,\n        enabled: widget.enabled,\n        ignorePointers: widget.ignorePointers,\n        enableInteractiveSelection: widget.enableInteractiveSelection,\n        selectAllOnFocus: false,\n        selectionControls: widget.selectionControls,\n        dragStartBehavior: widget.dragStartBehavior,\n        mouseCursor: widget.mouseCursor,\n        counterBuilder: widget.counterBuilder,\n        scrollPhysics: widget.scrollPhysics,\n        scrollController: widget.scrollController,\n        autofillHints: widget.autofillHints,\n        restorationId: widget.restorationId,\n        stylusHandwritingEnabled: widget.stylusHandwritingEnabled,\n        enableIMEPersonalizedLearning: widget.enableIMEPersonalizedLearning,\n        contentInsertionConfiguration: widget.contentInsertionConfiguration,\n        contextMenuBuilder: widget.contextMenuBuilder,\n        canRequestFocus: widget.canRequestFocus,\n        undoController: widget.undoController,\n        spellCheckConfiguration: widget.spellCheckConfiguration,\n        prefixBuilder: widget.prefixBuilder == null\n            ? null\n            : (context, _, states) => widget.prefixBuilder!(context, style, states),\n        suffixBuilder: widget.suffixBuilder == null\n            ? null\n            : (context, _, states) => widget.suffixBuilder!(context, style, states),\n        clearable: widget.clearable,\n        onSaved: widget.onSaved,\n        onReset: widget.onReset,\n        validator: widget.validator,\n        initialText: widget.initialText,\n        autovalidateMode: widget.autovalidateMode,\n        forceErrorText: widget.forceErrorText,\n        errorBuilder: widget.errorBuilder,\n        builder: (context, _, states, field) => FocusTraversalGroup(\n          policy: SkipDelegateTraversalPolicy(FocusTraversalGroup.maybeOf(context) ?? ReadingOrderTraversalPolicy()),\n          child: FPopover(\n            controller: _controller.content,\n            style: style.contentStyle,\n            constraints: widget.popoverConstraints,\n            popoverAnchor: widget.anchor,\n            childAnchor: widget.fieldAnchor,\n            spacing: widget.spacing,\n            overflow: widget.overflow,\n            offset: widget.offset,\n            hideRegion: widget.hideRegion,\n            onTapHide: () {\n              if (_restore case final restore?) {\n                _previous = restore;\n                _controller.text = restore;\n              }\n              widget.onTapHide?.call();\n            },\n            focusNode: _popoverFocus,\n            popoverBuilder: (_, popoverController) => TextFieldTapRegion(\n              child: InheritedAutocompleteController(\n                popover: popoverController,\n                onPress: (value) {\n                  if (widget.autoHide) {\n                    _controller.content.hide();\n                  }\n                  _previous = value;\n                  _controller.text = value;\n                },\n                onFocus: (value) {\n                  _restore ??= _controller.text;\n                  _previous = value;\n                  _controller.text = value;\n                },\n                child: Content(\n                  controller: _controller,\n                  style: style.contentStyle,\n                  enabled: widget.enabled,\n                  scrollController: widget.contentScrollController,\n                  physics: widget.contentPhysics,\n                  divider: widget.contentDivider,\n                  data: _data,\n                  loadingBuilder: widget.contentLoadingBuilder,\n                  builder: widget.contentBuilder,\n                  emptyBuilder: widget.contentEmptyBuilder,\n                  errorBuilder: widget.contentErrorBuilder,\n                ),\n              ),\n            ),\n            child: InheritedAutocompleteStyle(\n              style: style,\n              states: states,\n              child: CallbackShortcuts(\n                bindings: {\n                  const SingleActivator(LogicalKeyboardKey.escape): _controller.content.hide,\n                  const SingleActivator(LogicalKeyboardKey.arrowDown): () =>\n                      _popoverFocus.descendants.firstOrNull?.requestFocus(),\n                  if (_controller.current case (:final replacement, completion: final _))\n                    const SingleActivator(LogicalKeyboardKey.tab): () => _complete(replacement),\n                  if (_controller.current case (\n                    :final replacement,\n                    completion: final _,\n                  ) when widget.rightArrowToComplete)\n                    const SingleActivator(LogicalKeyboardKey.arrowRight): () => _complete(replacement),\n                },\n                child: widget.builder(context, style, states, field),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  void _complete(String replacement) {\n    if (widget.autoHide) {\n      _controller.content.hide();\n    }\n    _previous = replacement;\n    _controller.complete();\n  }\n}\n\n/// An [FAutocomplete]'s style.\nclass FAutocompleteStyle with Diagnosticable, _$FAutocompleteStyleFunctions {\n  /// The select field's style.\n  @override\n  final FTextFieldStyle fieldStyle;\n\n  /// The composing text's [TextStyle].\n  ///\n  /// {@template forui.text_field.composingTextStyle}\n  /// It is strongly recommended that FTextFieldStyle.contentTextStyle], [composingTextStyle] and [typeaheadTextStyle]\n  /// are the same size to prevent visual discrepancies between the actual and typeahead text.\n  ///\n  /// The supported states are:\n  /// * [WidgetState.disabled]\n  /// * [WidgetState.error]\n  /// * [WidgetState.focused]\n  /// * [WidgetState.hovered]\n  /// * [WidgetState.pressed]\n  /// {@endtemplate}\n  @override\n  final FWidgetStateMap<TextStyle> composingTextStyle;\n\n  /// The typeahead's [TextStyle].\n  ///\n  /// {@macro forui.text_field.composingTextStyle}\n  @override\n  final FWidgetStateMap<TextStyle> typeaheadTextStyle;\n\n  /// The content's style.\n  @override\n  final FAutocompleteContentStyle contentStyle;\n\n  /// Creates a [FAutocompleteStyle].\n  FAutocompleteStyle({\n    required this.fieldStyle,\n    required this.composingTextStyle,\n    required this.typeaheadTextStyle,\n    required this.contentStyle,\n  });\n\n  /// Creates a [FAutocompleteStyle] that inherits its properties.\n  factory FAutocompleteStyle.inherit({\n    required FColors colors,\n    required FTypography typography,\n    required FStyle style,\n  }) {\n    final field = FTextFieldStyle.inherit(colors: colors, typography: typography, style: style);\n\n    return FAutocompleteStyle(\n      fieldStyle: field,\n      composingTextStyle: field.contentTextStyle.map((s) => s.copyWith(decoration: TextDecoration.underline)),\n      typeaheadTextStyle: field.contentTextStyle.map((s) => s.copyWith(color: colors.mutedForeground)),\n      contentStyle: FAutocompleteContentStyle.inherit(colors: colors, typography: typography, style: style),\n    );\n  }\n}\n",
      "autocomplete_content": "import 'dart:async';\nimport 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\npart 'autocomplete_content.design.dart';\n\n@internal\nclass ContentData extends InheritedWidget {\n  static ContentData of(BuildContext context) {\n    assert(debugCheckHasAncestor<ContentData>('$FAutocomplete', context));\n    return context.dependOnInheritedWidgetOfExactType<ContentData>()!;\n  }\n\n  final FAutocompleteSectionStyle style;\n  final bool enabled;\n\n  const ContentData({required this.style, required this.enabled, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(ContentData old) => style != old.style || enabled != old.enabled;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'));\n  }\n}\n\n@internal\nclass Content extends StatelessWidget {\n  final FAutocompleteController controller;\n  final FAutocompleteContentStyle style;\n  final bool enabled;\n  final ScrollController? scrollController;\n  final ScrollPhysics physics;\n  final FItemDivider divider;\n  final FutureOr<Iterable<String>> data;\n  final Widget Function(BuildContext context, FAutocompleteContentStyle style) loadingBuilder;\n  final FAutoCompleteContentBuilder builder;\n  final Widget Function(BuildContext context, FAutocompleteContentStyle style) emptyBuilder;\n  final Widget Function(BuildContext context, Object? error, StackTrace stackTrace)? errorBuilder;\n\n  const Content({\n    required this.controller,\n    required this.style,\n    required this.enabled,\n    required this.scrollController,\n    required this.physics,\n    required this.divider,\n    required this.data,\n    required this.loadingBuilder,\n    required this.builder,\n    required this.emptyBuilder,\n    required this.errorBuilder,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) => Column(\n    mainAxisSize: MainAxisSize.min,\n    children: [\n      switch (data) {\n        final Iterable<String> data => _content(context, data),\n        final Future<Iterable<String>> future => FutureBuilder(\n          future: future,\n          builder: (context, snapshot) => switch (snapshot.connectionState) {\n            ConnectionState.waiting => Center(child: loadingBuilder(context, style)),\n            _ when snapshot.hasError && errorBuilder != null => errorBuilder!.call(\n              context,\n              snapshot.error,\n              snapshot.stackTrace!,\n            ),\n            _ => _content(context, snapshot.data ?? []),\n          },\n        ),\n      },\n    ],\n  );\n\n  Widget _content(BuildContext context, Iterable<String> values) {\n    final children = builder(context, controller.text, values);\n    if (children.isEmpty) {\n      return Center(child: emptyBuilder(context, style));\n    }\n\n    final sectionStyle = style.sectionStyle;\n    final itemStyle = style.sectionStyle.itemStyle;\n\n    return Flexible(\n      child: ContentData(\n        style: sectionStyle,\n        enabled: enabled,\n        child: Padding(\n          padding: style.padding,\n          child: ListView(\n            controller: scrollController,\n            padding: EdgeInsets.zero,\n            physics: physics,\n            shrinkWrap: true,\n            children: [\n              for (final (i, child) in children.indexed)\n                FInheritedItemData(\n                  data: FItemData(\n                    style: itemStyle,\n                    dividerColor: sectionStyle.dividerColor,\n                    dividerWidth: sectionStyle.dividerWidth,\n                    divider: i == children.length - 1 ? FItemDivider.none : divider,\n                    enabled: enabled,\n                    index: i,\n                    last: i == children.length - 1,\n                    globalLast: i == children.length - 1,\n                  ),\n                  child: child,\n                ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'))\n      ..add(DiagnosticsProperty('scrollController', scrollController))\n      ..add(DiagnosticsProperty('physics', physics))\n      ..add(EnumProperty('divider', divider))\n      ..add(ObjectFlagProperty.has('data', data))\n      ..add(ObjectFlagProperty.has('loadingBuilder', loadingBuilder))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(ObjectFlagProperty.has('emptyBuilder', emptyBuilder))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder));\n  }\n}\n\n/// An [FAutocomplete]'s content style.\nclass FAutocompleteContentStyle extends FPopoverStyle with Diagnosticable, _$FAutocompleteContentStyleFunctions {\n  /// The default text style when there are no results.\n  @override\n  final TextStyle emptyTextStyle;\n\n  /// The padding surrounding the content. Defaults to `const EdgeInsets.symmetric(vertical: 5)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The loading progress's style.\n  @override\n  final FCircularProgressStyle progressStyle;\n\n  /// The section's style.\n  @override\n  final FAutocompleteSectionStyle sectionStyle;\n\n  /// Creates an [FAutocompleteContentStyle].\n  FAutocompleteContentStyle({\n    required this.emptyTextStyle,\n    required this.progressStyle,\n    required this.sectionStyle,\n    required super.decoration,\n    this.padding = const EdgeInsets.symmetric(vertical: 5),\n    super.barrierFilter,\n    super.backgroundFilter,\n    super.viewInsets,\n  });\n\n  /// Creates a [FAutocompleteContentStyle] that inherits its properties.\n  FAutocompleteContentStyle.inherit({required super.colors, required FTypography typography, required super.style})\n    : emptyTextStyle = typography.sm,\n      progressStyle = FCircularProgressStyle.inherit(colors: colors),\n      sectionStyle = FAutocompleteSectionStyle.inherit(colors: colors, style: style, typography: typography),\n      padding = const EdgeInsets.symmetric(vertical: 5),\n      super.inherit();\n}\n",
      "autocomplete_controller": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n/// A controller for managing autocomplete functionality in a text field.\nclass FAutocompleteController extends FTypeaheadController {\n  /// The popover controller used to show all autocomplete suggestions.\n  final FPopoverController content;\n\n  /// Creates a [FAutocompleteController] with an optional initial text and suggestions.\n  FAutocompleteController({\n    required TickerProvider vsync,\n    super.text,\n    super.suggestions,\n    FPopoverMotion popoverMotion = const FPopoverMotion(),\n  }) : content = FPopoverController(vsync: vsync, motion: popoverMotion),\n       super(\n         textStyles: (context) {\n           final InheritedAutocompleteStyle(:style, :states) = InheritedAutocompleteStyle.of(context);\n           return (\n             style.fieldStyle.contentTextStyle.resolve(states),\n             style.composingTextStyle.resolve(states),\n             style.typeaheadTextStyle.resolve(states),\n           );\n         },\n       );\n\n  @override\n  void dispose() {\n    content.dispose();\n    super.dispose();\n  }\n}\n\n@internal\nfinal class InheritedAutocompleteStyle extends InheritedWidget {\n  @useResult\n  static InheritedAutocompleteStyle of(BuildContext context) {\n    assert(debugCheckHasAncestor<InheritedAutocompleteStyle>('FAutocomplete', context));\n    return context.dependOnInheritedWidgetOfExactType<InheritedAutocompleteStyle>()!;\n  }\n\n  /// The autocomplete style.\n  final FAutocompleteStyle style;\n\n  /// The current widget states.\n  final Set<WidgetState> states;\n\n  const InheritedAutocompleteStyle({required this.style, required this.states, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(InheritedAutocompleteStyle old) => style != old.style || states != old.states;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('states', states));\n  }\n}\n\n@internal\nclass InheritedAutocompleteController extends InheritedWidget {\n  static InheritedAutocompleteController of(BuildContext context) {\n    assert(debugCheckHasAncestor<InheritedAutocompleteController>('$FAutocomplete', context));\n    return context.dependOnInheritedWidgetOfExactType<InheritedAutocompleteController>()!;\n  }\n\n  final FPopoverController popover;\n  final ValueChanged<String> onPress;\n  final ValueChanged<String> onFocus;\n\n  const InheritedAutocompleteController({\n    required this.popover,\n    required this.onPress,\n    required this.onFocus,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(InheritedAutocompleteController old) => popover != old.popover || onPress != old.onPress;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('popover', popover))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(ObjectFlagProperty.has('onFocus', onFocus));\n  }\n}\n",
      "autocomplete_item": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/autocomplete/autocomplete_content.dart';\nimport 'package:forui/src/widgets/autocomplete/autocomplete_controller.dart';\n\npart 'autocomplete_item.design.dart';\n\n/// A marker interface which denotes that mixed-in widgets can be used in a [FAutocomplete].\nmixin FAutocompleteItemMixin on Widget {}\n\n/// A section in a [FAutocomplete] that can contain multiple [FAutocompleteItem]s.\nclass FAutocompleteSection extends StatelessWidget with FAutocompleteItemMixin {\n  /// The style. Defaults to the [FAutocompleteSectionStyle] inherited from the parent [FAutocomplete].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create autocomplete-section\n  /// ```\n  final FAutocompleteSectionStyle Function(FAutocompleteSectionStyle style)? style;\n\n  /// True if the section is enabled. Disabled sections cannot be selected, and is skipped during traversal.\n  ///\n  /// Defaults to inheriting from the [FAutocomplete].\n  final bool? enabled;\n\n  /// The divider style. Defaults to the [FItemDivider] inherited from the parent [FAutocomplete]. Defaults to\n  /// [FItemDivider.none].\n  final FItemDivider divider;\n\n  /// The label.\n  final Widget label;\n\n  /// The nested [FAutocompleteItem]s.\n  final List<FAutocompleteItem> children;\n\n  /// Creates a [FAutocompleteSection] from the given items.\n  ///\n  /// For more control over the appearance of individual items, use [FAutocompleteSection.rich].\n  FAutocompleteSection({\n    required Widget label,\n    required List<String> items,\n    FAutocompleteSectionStyle Function(FAutocompleteSectionStyle style)? style,\n    bool? enabled,\n    FItemDivider divider = FItemDivider.none,\n    Key? key,\n  }) : this.rich(\n         label: label,\n         children: [for (final item in items) FAutocompleteItem(value: item)],\n         style: style,\n         enabled: enabled,\n         divider: divider,\n         key: key,\n       );\n\n  /// Creates a [FAutocompleteSection] with the given [children].\n  const FAutocompleteSection.rich({\n    required this.label,\n    required this.children,\n    this.style,\n    this.enabled,\n    this.divider = FItemDivider.none,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final content = ContentData.of(context);\n    final enabled = this.enabled ?? content.enabled;\n    final style = this.style?.call(content.style) ?? content.style;\n    final itemStyle = style.itemStyle;\n\n    return ContentData(\n      style: style,\n      enabled: enabled,\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          DefaultTextStyle.merge(\n            style: style.labelTextStyle.resolve({if (!enabled) WidgetState.disabled}),\n            child: Padding(padding: style.labelPadding, child: label),\n          ),\n          if (children.firstOrNull case final first?)\n            ContentData(\n              style: style,\n              enabled: enabled,\n              child: FInheritedItemData.merge(\n                style: itemStyle,\n                divider: divider,\n                index: 0,\n                last: children.length == 1,\n                child: first,\n              ),\n            ),\n          for (final (i, child) in children.indexed.skip(1))\n            FInheritedItemData.merge(\n              style: itemStyle,\n              divider: divider,\n              index: i,\n              last: i == children.length - 1,\n              child: child,\n            ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'))\n      ..add(EnumProperty('divider', divider));\n  }\n}\n\n/// A [FAutocompleteSection]'s style.\nclass FAutocompleteSectionStyle with Diagnosticable, _$FAutocompleteSectionStyleFunctions {\n  /// The enabled label's text style.\n  ///\n  /// Supported states:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<TextStyle> labelTextStyle;\n\n  /// The padding around the label. Defaults to `EdgeInsetsDirectional.only(start: 15, top: 7.5, bottom: 7.5, end: 10)`.\n  @override\n  final EdgeInsetsGeometry labelPadding;\n\n  /// The divider's style.\n  ///\n  /// Supported states:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<Color> dividerColor;\n\n  /// The divider's width.\n  @override\n  final double dividerWidth;\n\n  /// The section's items' style.\n  @override\n  final FItemStyle itemStyle;\n\n  /// Creates a [FAutocompleteSectionStyle].\n  FAutocompleteSectionStyle({\n    required this.labelTextStyle,\n    required this.dividerColor,\n    required this.dividerWidth,\n    required this.itemStyle,\n    this.labelPadding = const EdgeInsetsDirectional.only(start: 15, top: 7.5, bottom: 7.5, end: 10),\n  });\n\n  /// Creates a [FAutocompleteSectionStyle] that inherits its properties.\n  factory FAutocompleteSectionStyle.inherit({\n    required FColors colors,\n    required FStyle style,\n    required FTypography typography,\n  }) {\n    const padding = EdgeInsetsDirectional.only(start: 11, top: 7.5, bottom: 7.5, end: 6);\n    final iconStyle = FWidgetStateMap({\n      WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 15),\n      WidgetState.any: IconThemeData(color: colors.primary, size: 15),\n    });\n    final textStyle = FWidgetStateMap({\n      WidgetState.disabled: typography.sm.copyWith(color: colors.disable(colors.primary)),\n      WidgetState.any: typography.sm.copyWith(color: colors.primary),\n    });\n\n    return FAutocompleteSectionStyle(\n      labelTextStyle: FWidgetStateMap({\n        WidgetState.disabled: typography.sm.copyWith(\n          color: colors.disable(colors.primary),\n          fontWeight: FontWeight.w600,\n        ),\n        WidgetState.any: typography.sm.copyWith(color: colors.primary, fontWeight: FontWeight.w600),\n      }),\n      dividerColor: FWidgetStateMap.all(colors.border),\n      dividerWidth: style.borderWidth,\n      itemStyle: FItemStyle(\n        backgroundColor: FWidgetStateMap.all(null),\n        decoration: FWidgetStateMap({\n          ~WidgetState.disabled & (WidgetState.focused | WidgetState.hovered | WidgetState.pressed): BoxDecoration(\n            color: colors.secondary,\n            borderRadius: style.borderRadius,\n          ),\n        }),\n        contentStyle: FItemContentStyle.inherit(colors: colors, typography: typography).copyWith(\n          padding: padding,\n          prefixIconStyle: iconStyle,\n          prefixIconSpacing: 10,\n          titleTextStyle: textStyle,\n          titleSpacing: 4,\n          subtitleTextStyle: FWidgetStateMap({\n            WidgetState.disabled: typography.xs.copyWith(color: colors.disable(colors.mutedForeground)),\n            WidgetState.any: typography.xs.copyWith(color: colors.mutedForeground),\n          }),\n          suffixIconStyle: FWidgetStateMap({\n            WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 15),\n            WidgetState.any: IconThemeData(color: colors.primary, size: 15),\n          }),\n        ),\n        rawItemContentStyle: FRawItemContentStyle(\n          padding: padding,\n          prefixIconStyle: iconStyle,\n          childTextStyle: textStyle,\n        ),\n        tappableStyle: style.tappableStyle.copyWith(motion: FTappableMotion.none),\n        focusedOutlineStyle: null,\n      ),\n    );\n  }\n}\n\n/// A suggestion in a [FAutocomplete] that can optionally be nested in a [FAutocompleteSection].\nabstract class FAutocompleteItem extends StatelessWidget with FAutocompleteItemMixin {\n  /// The style. Defaults to the [FItemStyle] inherited from the parent [FAutocompleteSection] or [FAutocomplete].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create autocomplete-section\n  /// ```\n  final FItemStyle Function(FItemStyle style)? style;\n\n  /// The value.\n  final String value;\n\n  /// True if the item is enabled. Disabled items cannot be selected, and is skipped during traversal.\n  ///\n  /// Defaults to the value inherited from the parent [FAutocompleteSection] or [FAutocomplete].\n  final bool? enabled;\n\n  /// A prefix.\n  final Widget? prefix;\n\n  /// Creates a [FAutocompleteItem] with a custom [title] and value.\n  ///\n  /// For even more control over the item's appearance, use [FAutocompleteItem.raw].\n  factory FAutocompleteItem({\n    required String value,\n    FItemStyle Function(FItemStyle style)? style,\n    bool? enabled,\n    Widget? prefix,\n    Widget? title,\n    Widget? subtitle,\n    Widget? suffix,\n    Key? key,\n  }) = _AutocompleteItem;\n\n  /// Creates a [FAutocompleteItem] with raw layout that delegates to [FItem.raw].\n  ///\n  /// This provides full control over the item's layout without the structured\n  /// title/subtitle/prefix/suffix layout of the default constructor.\n  factory FAutocompleteItem.raw({\n    required Widget child,\n    required String value,\n    FItemStyle Function(FItemStyle style)? style,\n    bool? enabled,\n    Widget? prefix,\n    Key? key,\n  }) = _RawAutocompleteItem;\n\n  const FAutocompleteItem._({required this.value, this.style, this.enabled, this.prefix, super.key});\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('value', value))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'));\n  }\n}\n\nclass _AutocompleteItem extends FAutocompleteItem {\n  final Widget? subtitle;\n  final Widget title;\n  final Widget? suffix;\n\n  _AutocompleteItem({\n    required super.value,\n    super.style,\n    super.enabled,\n    super.prefix,\n    this.subtitle,\n    this.suffix,\n    Widget? title,\n    super.key,\n  }) : title = title ?? Text(value),\n       super._();\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedAutocompleteController(:popover, :onPress, :onFocus) = InheritedAutocompleteController.of(context);\n    final content = ContentData.of(context);\n\n    final enabled = this.enabled ?? content.enabled;\n    final style = this.style?.call(content.style.itemStyle);\n\n    return FItem(\n      style: style?.call,\n      enabled: enabled,\n      onPress: () => onPress(value),\n      onFocusChange: (focused) {\n        if (focused) {\n          onFocus(value);\n        }\n      },\n      prefix: prefix,\n      title: title,\n      subtitle: subtitle,\n      suffix: suffix,\n    );\n  }\n}\n\nclass _RawAutocompleteItem extends FAutocompleteItem {\n  final Widget child;\n\n  const _RawAutocompleteItem({\n    required this.child,\n    required super.value,\n    super.style,\n    super.enabled,\n    super.prefix,\n    super.key,\n  }) : super._();\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedAutocompleteController(:popover, :onPress, :onFocus) = InheritedAutocompleteController.of(context);\n    final content = ContentData.of(context);\n\n    final enabled = this.enabled ?? content.enabled;\n    final style = this.style?.call(content.style.itemStyle);\n\n    return FItem.raw(\n      style: style?.call,\n      enabled: enabled,\n      onPress: () => onPress(value),\n      onFocusChange: (focused) {\n        if (focused) {\n          onFocus(value);\n        }\n      },\n      prefix: prefix,\n      child: child,\n    );\n  }\n}\n",
      "skip_delegate_traversal_policy": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\n/// A [FocusTraversalPolicy] that delegates to another policy but skips [FocusScopeNode] descendants that have no\n/// traversal descendants themselves.\n@internal\nclass SkipDelegateTraversalPolicy with Diagnosticable implements FocusTraversalPolicy {\n  final FocusTraversalPolicy _delegate;\n\n  SkipDelegateTraversalPolicy(this._delegate);\n\n  @override\n  TraversalRequestFocusCallback get requestFocusCallback => _delegate.requestFocusCallback;\n\n  @override\n  FocusNode? findFirstFocus(FocusNode currentNode, {bool ignoreCurrentFocus = false}) =>\n      _delegate.findFirstFocus(currentNode, ignoreCurrentFocus: ignoreCurrentFocus);\n\n  @override\n  FocusNode findLastFocus(FocusNode currentNode, {bool ignoreCurrentFocus = false}) =>\n      _delegate.findLastFocus(currentNode, ignoreCurrentFocus: ignoreCurrentFocus);\n\n  @override\n  FocusNode? findFirstFocusInDirection(FocusNode currentNode, TraversalDirection direction) =>\n      _delegate.findFirstFocusInDirection(currentNode, direction);\n\n  @override\n  void invalidateScopeData(FocusScopeNode node) => _delegate.invalidateScopeData(node);\n\n  @override\n  void changedScope({FocusNode? node, FocusScopeNode? oldScope}) =>\n      _delegate.changedScope(node: node, oldScope: oldScope);\n\n  @override\n  bool next(FocusNode currentNode) => _delegate.next(currentNode);\n\n  @override\n  bool previous(FocusNode currentNode) => _delegate.previous(currentNode);\n\n  @override\n  bool inDirection(FocusNode currentNode, TraversalDirection direction) =>\n      _delegate.inDirection(currentNode, direction);\n\n  @override\n  Iterable<FocusNode> sortDescendants(Iterable<FocusNode> descendants, FocusNode currentNode) =>\n      _delegate.sortDescendants(\n        descendants.where((descendant) => descendant is! FocusScopeNode || descendant.traversalDescendants.isNotEmpty),\n        currentNode,\n      );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    return _delegate.debugFillProperties(properties);\n  }\n}\n"
    },
    "Avatar": {
      "avatar": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/avatar/avatar_content.dart';\n\npart 'avatar.design.dart';\n\n/// An image element with a fallback for representing the user.\n///\n/// Typically used with a user's profile image. If the image fails to load, the fallback widget is used instead, which\n/// usually displays the user's initials.\n///\n/// If the user's profile has no image, use the fallback property to display the initials using a [Text] widget styled\n/// with [FAvatarStyle.backgroundColor].\n///\n/// See:\n/// * https://forui.dev/docs/data/avatar for working examples.\nclass FAvatar extends StatelessWidget {\n  /// The style. Defaults to [FThemeData.avatarStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create accordion\n  /// ```\n  final FAvatarStyle Function(FAvatarStyle style)? style;\n\n  /// The circle's size. Defaults to 40.\n  final double size;\n\n  /// The child, typically an image.\n  final Widget child;\n\n  /// Creates an [FAvatar].\n  FAvatar({\n    required ImageProvider image,\n    this.style,\n    this.size = 40.0,\n    String? semanticsLabel,\n    Widget? fallback,\n    super.key,\n  }) : child = Content(style: style, size: size, image: image, semanticsLabel: semanticsLabel, fallback: fallback);\n\n  /// Creates a [FAvatar] without a fallback.\n  FAvatar.raw({Widget? child, this.style, this.size = 40.0, super.key})\n    : child = child ?? PlaceholderContent(style: style, size: size);\n\n  @override\n  Widget build(BuildContext context) {\n    final style = this.style?.call(context.theme.avatarStyle) ?? context.theme.avatarStyle;\n    return Container(\n      alignment: Alignment.center,\n      height: size,\n      width: size,\n      decoration: BoxDecoration(color: style.backgroundColor, shape: BoxShape.circle),\n      clipBehavior: Clip.hardEdge,\n      child: DefaultTextStyle(style: style.textStyle, child: child),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DoubleProperty('size', size));\n  }\n}\n\n/// [FAvatar]'s style.\nclass FAvatarStyle with Diagnosticable, _$FAvatarStyleFunctions {\n  /// The fallback's background color.\n  @override\n  final Color backgroundColor;\n\n  /// The fallback's color.\n  @override\n  final Color foregroundColor;\n\n  /// The text style for the fallback text.\n  @override\n  final TextStyle textStyle;\n\n  /// Duration for the transition animation. Defaults to 500ms.\n  @override\n  final Duration fadeInDuration;\n\n  /// Creates a [FAvatarStyle].\n  const FAvatarStyle({\n    required this.backgroundColor,\n    required this.foregroundColor,\n    required this.textStyle,\n    this.fadeInDuration = const Duration(milliseconds: 500),\n  });\n\n  /// Creates a [FAvatarStyle] that inherits its properties.\n  FAvatarStyle.inherit({required FColors colors, required FTypography typography})\n    : this(\n        backgroundColor: colors.muted,\n        foregroundColor: colors.mutedForeground,\n        textStyle: typography.base.copyWith(color: colors.mutedForeground, height: 0),\n      );\n}\n",
      "avatar_content": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\n\n@internal\nclass Content extends StatelessWidget {\n  final FAvatarStyle Function(FAvatarStyle style)? style;\n  final double size;\n  final ImageProvider image;\n  final String? semanticsLabel;\n  final Widget? fallback;\n\n  const Content({\n    required this.style,\n    required this.size,\n    required this.image,\n    required this.semanticsLabel,\n    required this.fallback,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final fallback = this.fallback ?? PlaceholderContent(style: style, size: size);\n\n    return Image(\n      height: size,\n      width: size,\n      image: image,\n      semanticLabel: semanticsLabel,\n      errorBuilder: (_, _, _) => fallback,\n      frameBuilder: (_, child, frame, wasSynchronouslyLoaded) => wasSynchronouslyLoaded\n          ? child\n          : AnimatedSwitcher(duration: const Duration(milliseconds: 500), child: frame == null ? fallback : child),\n      loadingBuilder: (_, child, loadingProgress) => loadingProgress == null ? child : fallback,\n      fit: BoxFit.cover,\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DoubleProperty('size', size))\n      ..add(DiagnosticsProperty('image', image))\n      ..add(StringProperty('semanticsLabel', semanticsLabel));\n  }\n}\n\n@internal\nclass PlaceholderContent extends StatelessWidget {\n  final FAvatarStyle Function(FAvatarStyle style)? style;\n  final double size;\n\n  const PlaceholderContent({required this.size, this.style, super.key});\n\n  @override\n  Widget build(BuildContext context) => Icon(\n    FIcons.userRound,\n    size: size / 2,\n    color: (style?.call(context.theme.avatarStyle) ?? context.theme.avatarStyle).foregroundColor,\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DoubleProperty('size', size));\n  }\n}\n"
    },
    "Badge": {
      "badge": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/badge/badge_content.dart';\n\npart 'badge.design.dart';\n\n/// A badge. Badges are typically used to draw attention to specific information, such as labels and counts.\n///\n/// The constants in [FBadgeStyle] provide a convenient way to style a badge.\n///\n/// See:\n/// * https://forui.dev/docs/data/badge for working examples.\n/// * [FBadgeStyle] for customizing a badge's appearance.\nclass FBadge extends StatelessWidget {\n  static _Resolve _primary(FBadgeStyle _) => _Resolve((context) => context.theme.badgeStyles.primary);\n\n  /// The style. Defaults to [FBadgeStyle.primary].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create badges\n  /// ```\n  final FBaseBadgeStyle Function(FBadgeStyle style) style;\n\n  /// The builder used to build the badge's content.\n  final Widget Function(BuildContext context, FBadgeStyle style) builder;\n\n  /// Creates a [FBadge].\n  FBadge({required Widget child, this.style = _primary, super.key})\n    : builder = ((_, style) => Content(style: style, child: child));\n\n  /// Creates a [FBadge] with no defaults applied.\n  const FBadge.raw({required this.builder, this.style = _primary, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final style = switch (this.style(context.theme.badgeStyles.primary)) {\n      final FBadgeStyle style => style,\n      final _Resolve resolver => resolver._resolve(context),\n    };\n\n    return IntrinsicWidth(\n      child: IntrinsicHeight(\n        child: DecoratedBox(decoration: style.decoration, child: builder(context, style)),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style, defaultValue: FBadgeStyle.primary))\n      ..add(ObjectFlagProperty.has('builder', builder));\n  }\n}\n\n/// A [FBadge]'s style.\n///\n/// A style can be either one of the pre-defined styles in [FBadgeStyle] or a [FBadgeStyle] itself.\nsealed class FBaseBadgeStyle {}\n\nclass _Resolve extends FBaseBadgeStyle {\n  final FBadgeStyle Function(BuildContext context) _resolve;\n\n  _Resolve(this._resolve);\n}\n\n/// A [FBadge]'s style.\n///\n/// The pre-defined styles are a convenient shorthand for the various [FBadgeStyle]s in the current context's\n/// [FBadgeStyles].\nclass FBadgeStyle with Diagnosticable, _$FBadgeStyleFunctions implements FBaseBadgeStyle {\n  /// The badge's primary style.\n  ///\n  /// Shorthand for the current context's [FBadgeStyles.primary] style.\n  static FBaseBadgeStyle Function(FBadgeStyle) primary([FBadgeStyle Function(FBadgeStyle)? style]) =>\n      (_) => _Resolve((context) => style?.call(context.theme.badgeStyles.primary) ?? context.theme.badgeStyles.primary);\n\n  /// The badge's secondary style.\n  ///\n  /// Shorthand for the current context's [FBadgeStyles.secondary] style.\n  static FBaseBadgeStyle Function(FBadgeStyle) secondary([FBadgeStyle Function(FBadgeStyle)? style]) =>\n      (_) => _Resolve(\n        (context) => style?.call(context.theme.badgeStyles.secondary) ?? context.theme.badgeStyles.secondary,\n      );\n\n  /// The badge's outline style.\n  ///\n  /// Shorthand for the current context's [FBadgeStyles.outline] style.\n  static FBaseBadgeStyle Function(FBadgeStyle) outline([FBadgeStyle Function(FBadgeStyle)? style]) =>\n      (_) => _Resolve((context) => style?.call(context.theme.badgeStyles.outline) ?? context.theme.badgeStyles.outline);\n\n  /// The badge's destructive style.\n  ///\n  /// Shorthand for the current context's [FBadgeStyles.destructive] style.\n  static FBaseBadgeStyle Function(FBadgeStyle) destructive([FBadgeStyle Function(FBadgeStyle)? style]) =>\n      (_) => _Resolve(\n        (context) => style?.call(context.theme.badgeStyles.destructive) ?? context.theme.badgeStyles.destructive,\n      );\n\n  /// The decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// The content's style.\n  @override\n  final FBadgeContentStyle contentStyle;\n\n  /// Creates a [FBadgeStyle].\n  const FBadgeStyle({required this.decoration, required this.contentStyle});\n}\n",
      "badge_content": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'badge_content.design.dart';\n\n@internal\nclass Content extends StatelessWidget {\n  final FBadgeStyle style;\n  final Widget child;\n\n  const Content({required this.style, required this.child, super.key});\n\n  @override\n  Widget build(BuildContext _) => Center(\n    child: Padding(\n      padding: style.contentStyle.padding,\n      child: DefaultTextStyle.merge(style: style.contentStyle.labelTextStyle, child: child),\n    ),\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// [FBadge] content's style.\nfinal class FBadgeContentStyle with Diagnosticable, _$FBadgeContentStyleFunctions {\n  /// The label's [TextStyle].\n  @override\n  final TextStyle labelTextStyle;\n\n  /// The padding.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// Creates a [FBadgeContentStyle].\n  const FBadgeContentStyle({\n    required this.labelTextStyle,\n    this.padding = const EdgeInsets.symmetric(horizontal: 14, vertical: 2),\n  });\n}\n",
      "badge_styles": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'badge_styles.design.dart';\n\n/// The [FBadgeStyle]s.\nclass FBadgeStyles with Diagnosticable, _$FBadgeStylesFunctions {\n  /// The default border radius for badges.\n  static const BorderRadius defaultRadius = BorderRadius.all(Radius.circular(100));\n\n  /// The primary badge style.\n  @override\n  final FBadgeStyle primary;\n\n  /// The secondary badge style.\n  @override\n  final FBadgeStyle secondary;\n\n  /// The outlined badge style.\n  @override\n  final FBadgeStyle outline;\n\n  /// The destructive badge style.\n  @override\n  final FBadgeStyle destructive;\n\n  /// Creates a [FBadgeStyles].\n  FBadgeStyles({required this.primary, required this.secondary, required this.outline, required this.destructive});\n\n  /// Creates a [FBadgeStyles] that inherits its properties.\n  FBadgeStyles.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        primary: FBadgeStyle(\n          decoration: BoxDecoration(color: colors.primary, borderRadius: FBadgeStyles.defaultRadius),\n          contentStyle: FBadgeContentStyle(\n            labelTextStyle: typography.sm.copyWith(color: colors.primaryForeground, fontWeight: FontWeight.w600),\n          ),\n        ),\n        secondary: FBadgeStyle(\n          decoration: BoxDecoration(color: colors.secondary, borderRadius: FBadgeStyles.defaultRadius),\n          contentStyle: FBadgeContentStyle(\n            labelTextStyle: typography.sm.copyWith(color: colors.secondaryForeground, fontWeight: FontWeight.w600),\n          ),\n        ),\n        outline: FBadgeStyle(\n          decoration: BoxDecoration(\n            border: Border.all(color: colors.border, width: style.borderWidth),\n            borderRadius: FBadgeStyles.defaultRadius,\n          ),\n          contentStyle: FBadgeContentStyle(\n            labelTextStyle: typography.sm.copyWith(color: colors.foreground, fontWeight: FontWeight.w600),\n          ),\n        ),\n        destructive: FBadgeStyle(\n          decoration: BoxDecoration(color: colors.destructive, borderRadius: FBadgeStyles.defaultRadius),\n          contentStyle: FBadgeContentStyle(\n            labelTextStyle: typography.sm.copyWith(color: colors.destructiveForeground, fontWeight: FontWeight.w600),\n          ),\n        ),\n      );\n}\n"
    },
    "BottomNavigationBar": {
      "bottom_navigation_bar": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\npart 'bottom_navigation_bar.design.dart';\n\n/// A bottom navigation bar.\n///\n/// A bottom navigation bar is usually present at the bottom of root pages. It is used to navigate between a small\n/// number of views, typically between three and five.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/bottom-navigation-bar for working examples.\n/// * [FBottomNavigationBarStyle] for customizing a bottom navigation bar's appearance.\n/// * [FBottomNavigationBarItem] for the items in a bottom navigation bar.\nclass FBottomNavigationBar extends StatelessWidget {\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create bottom-navigation-bar\n  /// ```\n  final FBottomNavigationBarStyle Function(FBottomNavigationBarStyle style)? style;\n\n  /// A callback for when an item is selected.\n  final ValueChanged<int>? onChange;\n\n  /// The index.\n  final int index;\n\n  /// The children.\n  final List<Widget> children;\n\n  /// Creates a [FBottomNavigationBar] with [FBottomNavigationBarItem]s.\n  ///\n  /// See [FBottomNavigationBarItem] for the items in a bottom navigation bar.\n  const FBottomNavigationBar({required this.children, this.style, this.onChange, this.index = -1, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final style = this.style?.call(context.theme.bottomNavigationBarStyle) ?? context.theme.bottomNavigationBarStyle;\n    final padding = style.padding.resolve(Directionality.maybeOf(context) ?? TextDirection.ltr);\n\n    Widget bar = DecoratedBox(\n      decoration: style.decoration,\n      child: SafeArea(\n        top: false,\n        bottom: false,\n        child: Padding(\n          padding: padding.copyWith(bottom: padding.bottom + (MediaQuery.viewPaddingOf(context).bottom * 2 / 3)),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: [\n              for (final (i, child) in children.indexed)\n                Expanded(\n                  child: FBottomNavigationBarData(\n                    itemStyle: style.itemStyle,\n                    index: i,\n                    selected: i == index,\n                    onChange: onChange,\n                    child: child,\n                  ),\n                ),\n            ],\n          ),\n        ),\n      ),\n    );\n\n    if (style.backgroundFilter case final filter?) {\n      bar = Stack(\n        children: [\n          Positioned.fill(\n            child: ClipRect(\n              child: BackdropFilter(filter: filter, child: Container()),\n            ),\n          ),\n          bar,\n        ],\n      );\n    }\n\n    return bar;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(IntProperty('index', index));\n  }\n}\n\n/// A [FBottomNavigationBar]'s data.\nclass FBottomNavigationBarData extends InheritedWidget {\n  /// Returns the [FBottomNavigationBarItemStyle] and current states of the [FBottomNavigationBar] in the given [context].\n  @useResult\n  static FBottomNavigationBarData of(BuildContext context) {\n    assert(debugCheckHasAncestor<FBottomNavigationBarData>('$FBottomNavigationBar', context));\n    return context.dependOnInheritedWidgetOfExactType<FBottomNavigationBarData>()!;\n  }\n\n  /// The item's style.\n  final FBottomNavigationBarItemStyle itemStyle;\n\n  /// The item's index.\n  final int index;\n\n  /// True if the item is selected.\n  final bool selected;\n\n  /// A callback for when an item is selected.\n  final ValueChanged<int>? onChange;\n\n  /// Creates a [FBottomNavigationBarData].\n  const FBottomNavigationBarData({\n    required this.itemStyle,\n    required this.index,\n    required this.selected,\n    required this.onChange,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(FBottomNavigationBarData old) =>\n      old.itemStyle != itemStyle || old.index != index || old.selected != selected;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('itemStyle', itemStyle))\n      ..add(IntProperty('index', index))\n      ..add(FlagProperty('selected', value: selected, ifTrue: 'selected', ifFalse: 'not selected'))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n\n/// [FBottomNavigationBar]'s style.\nclass FBottomNavigationBarStyle with Diagnosticable, _$FBottomNavigationBarStyleFunctions {\n  /// The decoration.\n  ///\n  /// ## Removing the top border\n  /// By default, both [FBottomNavigationBar] and [FScaffold.footer] specify a top border. When used together, the\n  /// top border must be removed from both [FBottomNavigationBarStyle.decoration] and [FScaffoldStyle.footerDecoration]\n  /// for the changes to take effect.\n  @override\n  final BoxDecoration decoration;\n\n  /// An optional background filter. This only takes effect if the [decoration] has a transparent or translucent\n  /// background color.\n  ///\n  /// This is typically combined with a transparent/translucent background to create a glassmorphic effect.\n  ///\n  /// ## Examples\n  /// ```dart\n  /// // Blurred\n  /// ImageFilter.blur(sigmaX: 5, sigmaY: 5);\n  ///\n  /// // Solid color\n  /// ColorFilter.mode(Colors.white, BlendMode.srcOver);\n  ///\n  /// // Tinted\n  /// ColorFilter.mode(Colors.white.withValues(alpha: 0.5), BlendMode.srcOver);\n  ///\n  /// // Blurred & tinted\n  /// ImageFilter.compose(\n  ///   outer: ImageFilter.blur(sigmaX: 5, sigmaY: 5),\n  ///   inner: ColorFilter.mode(Colors.white.withValues(alpha: 0.5), BlendMode.srcOver),\n  /// );\n  /// ```\n  @override\n  final ImageFilter? backgroundFilter;\n\n  /// The padding. Defaults to `EdgeInsets.all(5)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The item's style.\n  @override\n  final FBottomNavigationBarItemStyle itemStyle;\n\n  /// Creates a [FBottomNavigationBarStyle].\n  const FBottomNavigationBarStyle({\n    required this.decoration,\n    required this.itemStyle,\n    this.backgroundFilter,\n    this.padding = const EdgeInsets.all(5),\n  });\n\n  /// Creates a [FBottomNavigationBarStyle] that inherits its properties.\n  FBottomNavigationBarStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        decoration: BoxDecoration(\n          border: Border(top: BorderSide(color: colors.border)),\n          color: colors.background,\n        ),\n        itemStyle: FBottomNavigationBarItemStyle.inherit(colors: colors, typography: typography, style: style),\n      );\n}\n",
      "bottom_navigation_bar_item": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'bottom_navigation_bar_item.design.dart';\n\n/// A [FBottomNavigationBar] item.\nclass FBottomNavigationBarItem extends StatelessWidget {\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create bottom-navigation-bar-item\n  /// ```\n  final FBottomNavigationBarItemStyle Function(FBottomNavigationBarItemStyle style)? style;\n\n  /// The icon, wrapped in a [IconTheme].\n  final Widget icon;\n\n  /// The label.\n  final Widget? label;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// {@macro forui.foundation.FTappable.onHoverChange}\n  final ValueChanged<bool>? onHoverChange;\n\n  /// {@macro forui.foundation.FTappable.onStateChange}\n  final ValueChanged<FWidgetStatesDelta>? onStateChange;\n\n  /// Creates a [FBottomNavigationBarItem].\n  const FBottomNavigationBarItem({\n    required this.icon,\n    this.label,\n    this.style,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final FBottomNavigationBarData(:itemStyle, :selected, :index, :onChange) = FBottomNavigationBarData.of(context);\n    final style = this.style?.call(itemStyle) ?? itemStyle;\n\n    return FTappable(\n      style: style.tappableStyle,\n      focusedOutlineStyle: style.focusedOutlineStyle,\n      autofocus: autofocus,\n      focusNode: focusNode,\n      onFocusChange: onFocusChange,\n      onHoverChange: onHoverChange,\n      onStateChange: onStateChange,\n      behavior: HitTestBehavior.opaque,\n      selected: selected,\n      onPress: () => onChange?.call(index),\n      builder: (_, states, _) => Padding(\n        padding: style.padding,\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          spacing: style.spacing,\n          children: [\n            ExcludeSemantics(\n              child: IconTheme(data: style.iconStyle.resolve(states), child: icon),\n            ),\n            if (label case final label?)\n              DefaultTextStyle.merge(\n                style: style.textStyle.resolve(states),\n                overflow: TextOverflow.ellipsis,\n                child: label,\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(ObjectFlagProperty.has('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onStateChange', onStateChange));\n  }\n}\n\n/// [FBottomNavigationBarItem]'s style.\nclass FBottomNavigationBarItemStyle with Diagnosticable, _$FBottomNavigationBarItemStyleFunctions {\n  /// The icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<IconThemeData> iconStyle;\n\n  /// The text style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<TextStyle> textStyle;\n\n  /// The padding. Defaults to `EdgeInsets.all(5)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The spacing between the icon and the label. Defaults to 2.\n  @override\n  final double spacing;\n\n  /// The item's tappable's style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// The item's focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// Creates a [FBottomNavigationBarItemStyle].\n  FBottomNavigationBarItemStyle({\n    required this.iconStyle,\n    required this.textStyle,\n    required this.tappableStyle,\n    required this.focusedOutlineStyle,\n    this.padding = const EdgeInsets.all(5),\n    this.spacing = 2,\n  });\n\n  /// Creates a [FBottomNavigationBarItemStyle] that inherits its properties.\n  FBottomNavigationBarItemStyle.inherit({\n    required FColors colors,\n    required FTypography typography,\n    required FStyle style,\n  }) : this(\n         iconStyle: FWidgetStateMap({\n           WidgetState.selected: IconThemeData(color: colors.primary, size: 24),\n           WidgetState.any: IconThemeData(color: colors.disable(colors.foreground), size: 24),\n         }),\n         textStyle: FWidgetStateMap({\n           WidgetState.selected: typography.base.copyWith(color: colors.primary, fontSize: 10),\n           WidgetState.any: typography.base.copyWith(color: colors.disable(colors.foreground), fontSize: 10),\n         }),\n         tappableStyle: style.tappableStyle,\n         focusedOutlineStyle: style.focusedOutlineStyle,\n       );\n}\n"
    },
    "Button": {
      "button": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\nimport 'package:forui/src/widgets/button/button_content.dart';\n\npart 'button.design.dart';\n\n/// A button.\n///\n/// [FButton] typically contains icons and/or a label. If the [onPress] and [onLongPress] callbacks are null, then this\n/// button will be disabled, and it will not react to touch.\n///\n/// The constants in [FBaseButtonStyle] provide a convenient way to style a button.\n///\n/// See:\n/// * https://forui.dev/docs/form/button for working examples.\n/// * [FButtonStyle] for customizing a button's appearance.\nclass FButton extends StatelessWidget {\n  static _Resolve _primary(FButtonStyle? _) => _Resolve((context) => context.theme.buttonStyles.primary);\n\n  static _Resolve _outline(FButtonStyle? _) => _Resolve((context) => context.theme.buttonStyles.outline);\n\n  /// The style. Defaults to [FButtonStyle.primary].\n  ///\n  /// Although typically one of the pre-defined styles in [FBaseButtonStyle], it can also be a [FButtonStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create buttons\n  /// ```\n  final FBaseButtonStyle Function(FButtonStyle style) style;\n\n  /// {@macro forui.foundation.FTappable.onPress}\n  final VoidCallback? onPress;\n\n  /// {@macro forui.foundation.FTappable.onLongPress}\n  final VoidCallback? onLongPress;\n\n  /// {@macro forui.foundation.FTappable.onSecondaryPress}\n  final VoidCallback? onSecondaryPress;\n\n  /// {@macro forui.foundation.FTappable.onSecondaryLongPress}\n  final VoidCallback? onSecondaryLongPress;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// {@macro forui.foundation.FTappable.onHoverChange}\n  final ValueChanged<bool>? onHoverChange;\n\n  /// {@macro forui.foundation.FTappable.onStateChange}\n  final ValueChanged<FWidgetStatesDelta>? onStateChange;\n\n  /// {@macro forui.foundation.FTappable.shortcuts}\n  final Map<ShortcutActivator, Intent>? shortcuts;\n\n  /// {@macro forui.foundation.FTappable.actions}\n  final Map<Type, Action<Intent>>? actions;\n\n  /// True if this button is currently selected. Defaults to false.\n  final bool selected;\n\n  /// The child.\n  final Widget child;\n\n  /// Creates a [FButton] that contains a [prefix], [child], and [suffix].\n  ///\n  /// [mainAxisSize] determines how the button's width is sized.\n  ///\n  /// [mainAxisAlignment] and [crossAxisAlignment] determine how the button's content is aligned horizontally and\n  /// vertically, respectively.\n  ///\n  /// [textBaseline] is used to align the [prefix], [child] and [suffix] if [crossAxisAlignment] is\n  /// [CrossAxisAlignment.baseline].\n  ///\n  /// [prefix] and [suffix] are wrapped in [IconThemeData].\n  ///\n  /// The button layout is as follows, assuming the locale is LTR:\n  /// ```diagram\n  /// |---------------------------------------|\n  /// |  [prefix]  [child]  [suffix]  |\n  /// |---------------------------------------|\n  /// ```\n  ///\n  /// The layout is reversed for RTL locales.\n  FButton({\n    required this.onPress,\n    required Widget child,\n    this.style = _primary,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.selected = false,\n    this.shortcuts,\n    this.actions,\n    MainAxisSize mainAxisSize = MainAxisSize.max,\n    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.center,\n    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,\n    TextBaseline? textBaseline,\n    Widget? prefix,\n    Widget? suffix,\n    super.key,\n  }) : child = Content(\n         mainAxisSize: mainAxisSize,\n         mainAxisAlignment: mainAxisAlignment,\n         crossAxisAlignment: crossAxisAlignment,\n         textBaseline: textBaseline,\n         prefix: prefix,\n         suffix: suffix,\n         child: child,\n       );\n\n  /// Creates a [FButton] that contains only an icon.\n  ///\n  /// [child] is wrapped in [IconThemeData].\n  FButton.icon({\n    required this.onPress,\n    required Widget child,\n    this.style = _outline,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.selected = false,\n    this.shortcuts,\n    this.actions,\n    super.key,\n  }) : child = IconContent(child: child);\n\n  /// Creates a [FButton] with custom content.\n  const FButton.raw({\n    required this.onPress,\n    required this.child,\n    this.style = _primary,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.selected = false,\n    this.shortcuts,\n    this.actions,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final style = switch (this.style(context.theme.buttonStyles.primary)) {\n      final FButtonStyle style => style,\n      final _Resolve resolver => resolver._resolve(context),\n    };\n\n    return FTappable(\n      style: style.tappableStyle,\n      focusedOutlineStyle: style.focusedOutlineStyle,\n      autofocus: autofocus,\n      focusNode: focusNode,\n      onFocusChange: onFocusChange,\n      onHoverChange: onHoverChange,\n      onStateChange: onStateChange,\n      onPress: onPress,\n      onLongPress: onLongPress,\n      onSecondaryPress: onSecondaryPress,\n      onSecondaryLongPress: onSecondaryLongPress,\n      selected: selected,\n      builder: (_, states, _) => DecoratedBox(\n        decoration: style.decoration.resolve(states),\n        child: FButtonData(style: style, states: states, child: child),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(ObjectFlagProperty.has('onLongPress', onLongPress))\n      ..add(ObjectFlagProperty.has('onSecondaryPress', onSecondaryPress))\n      ..add(ObjectFlagProperty.has('onSecondaryLongPress', onSecondaryLongPress))\n      ..add(FlagProperty('autofocus', value: autofocus, defaultValue: false, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onStateChange', onStateChange))\n      ..add(DiagnosticsProperty('shortcuts', shortcuts))\n      ..add(DiagnosticsProperty('actions', actions))\n      ..add(FlagProperty('selected', value: selected, defaultValue: false, ifTrue: 'selected'));\n  }\n}\n\n/// A [FButton]'s style.\n///\n/// A style can be either one of the pre-defined styles in [FButtonStyle] or a [FButtonStyle] itself.\nsealed class FBaseButtonStyle {}\n\nclass _Resolve extends FBaseButtonStyle {\n  final FButtonStyle Function(BuildContext context) _resolve;\n\n  _Resolve(this._resolve);\n}\n\n/// A [FButton]'s style.\n///\n/// The pre-defined styles are a convenient shorthand for the various [FButtonStyle]s in the current context's\n/// [FButtonStyles].\nclass FButtonStyle extends FBaseButtonStyle with Diagnosticable, _$FButtonStyleFunctions {\n  /// The button's primary style.\n  ///\n  /// Shorthand for the current context's [FButtonStyles.primary] style.\n  static FBaseButtonStyle Function(FButtonStyle style) primary([FButtonStyle Function(FButtonStyle style)? style]) =>\n      (_) =>\n          _Resolve((context) => style?.call(context.theme.buttonStyles.primary) ?? context.theme.buttonStyles.primary);\n\n  /// The button's secondary style.\n  ///\n  /// Shorthand for the current context's [FButtonStyles.secondary] style.\n  static FBaseButtonStyle Function(FButtonStyle style) secondary([FButtonStyle Function(FButtonStyle style)? style]) =>\n      (_) => _Resolve(\n        (context) => style?.call(context.theme.buttonStyles.secondary) ?? context.theme.buttonStyles.secondary,\n      );\n\n  /// The button's destructive style.\n  ///\n  /// Shorthand for the current context's [FButtonStyles.destructive] style.\n  static FBaseButtonStyle Function(FButtonStyle style) destructive([\n    FButtonStyle Function(FButtonStyle style)? style,\n  ]) =>\n      (_) => _Resolve(\n        (context) => style?.call(context.theme.buttonStyles.destructive) ?? context.theme.buttonStyles.destructive,\n      );\n\n  /// The button's outline style.\n  ///\n  /// Shorthand for the current context's [FButtonStyles.outline] style.\n  static FBaseButtonStyle Function(FButtonStyle style) outline([FButtonStyle Function(FButtonStyle style)? style]) =>\n      (_) =>\n          _Resolve((context) => style?.call(context.theme.buttonStyles.outline) ?? context.theme.buttonStyles.outline);\n\n  /// The button's ghost style.\n  ///\n  /// Shorthand for the current context's [FButtonStyles.ghost] style.\n  static FBaseButtonStyle Function(FButtonStyle style) ghost([FButtonStyle Function(FButtonStyle style)? style]) =>\n      (_) => _Resolve((context) => style?.call(context.theme.buttonStyles.ghost) ?? context.theme.buttonStyles.ghost);\n\n  /// The box decoration.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<BoxDecoration> decoration;\n\n  /// The content's style.\n  @override\n  final FButtonContentStyle contentStyle;\n\n  /// The icon content's style.\n  @override\n  final FButtonIconContentStyle iconContentStyle;\n\n  /// The tappable's style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// Creates a [FButtonStyle].\n  FButtonStyle({\n    required this.decoration,\n    required this.contentStyle,\n    required this.iconContentStyle,\n    required this.tappableStyle,\n    required this.focusedOutlineStyle,\n  });\n\n  /// Creates a [FButtonStyle] that inherits its properties.\n  FButtonStyle.inherit({\n    required FColors colors,\n    required FTypography typography,\n    required FStyle style,\n    required Color color,\n    required Color foregroundColor,\n  }) : this(\n         decoration: FWidgetStateMap({\n           WidgetState.disabled: BoxDecoration(borderRadius: style.borderRadius, color: colors.disable(color)),\n           WidgetState.hovered | WidgetState.pressed: BoxDecoration(\n             borderRadius: style.borderRadius,\n             color: colors.hover(color),\n           ),\n           WidgetState.any: BoxDecoration(borderRadius: style.borderRadius, color: color),\n         }),\n         focusedOutlineStyle: style.focusedOutlineStyle,\n         contentStyle: FButtonContentStyle.inherit(\n           typography: typography,\n           enabled: foregroundColor,\n           disabled: colors.disable(foregroundColor, colors.disable(color)),\n         ),\n         iconContentStyle: FButtonIconContentStyle(\n           iconStyle: FWidgetStateMap({\n             WidgetState.disabled: IconThemeData(\n               color: colors.disable(foregroundColor, colors.disable(color)),\n               size: 20,\n             ),\n             WidgetState.any: IconThemeData(color: foregroundColor, size: 20),\n           }),\n         ),\n         tappableStyle: style.tappableStyle,\n       );\n}\n\n/// A button's data.\nclass FButtonData extends InheritedWidget {\n  /// Returns the [FButtonData] of the [FButton] in the given [context].\n  @useResult\n  static FButtonData of(BuildContext context) {\n    assert(debugCheckHasAncestor<FButtonData>('$FButton', context));\n    return context.dependOnInheritedWidgetOfExactType<FButtonData>()!;\n  }\n\n  /// The button's style.\n  final FButtonStyle style;\n\n  /// The current states.\n  final Set<WidgetState> states;\n\n  /// Creates a [FButtonData].\n  const FButtonData({required this.style, required this.states, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(covariant FButtonData old) => style != old.style || !setEquals(states, old.states);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(IterableProperty('states', states));\n  }\n}\n",
      "button_content": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'button_content.design.dart';\n\n@internal\nclass Content extends StatelessWidget {\n  final MainAxisSize mainAxisSize;\n  final MainAxisAlignment mainAxisAlignment;\n  final CrossAxisAlignment crossAxisAlignment;\n  final TextBaseline? textBaseline;\n  final Widget? prefix;\n  final Widget? suffix;\n  final Widget child;\n\n  const Content({\n    required this.mainAxisSize,\n    required this.mainAxisAlignment,\n    required this.crossAxisAlignment,\n    required this.textBaseline,\n    required this.prefix,\n    required this.suffix,\n    required this.child,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final FButtonData(style: FButtonStyle(:contentStyle), :states) = FButtonData.of(context);\n    return Padding(\n      padding: contentStyle.padding,\n      child: DefaultTextStyle.merge(\n        style: contentStyle.textStyle.resolve(states),\n        child: IconTheme(\n          data: contentStyle.iconStyle.resolve(states),\n          child: FInheritedCircularProgressStyle(\n            style: contentStyle.circularProgressStyle.resolve(states),\n            child: Row(\n              mainAxisAlignment: mainAxisAlignment,\n              mainAxisSize: mainAxisSize,\n              crossAxisAlignment: crossAxisAlignment,\n              textBaseline: textBaseline,\n              spacing: contentStyle.spacing,\n              children: [?prefix, child, ?suffix],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(EnumProperty('mainAxisSize', mainAxisSize, defaultValue: MainAxisSize.max))\n      ..add(EnumProperty('mainAxisAlignment', mainAxisAlignment))\n      ..add(EnumProperty('crossAxisAlignment', crossAxisAlignment))\n      ..add(EnumProperty('textBaseline', textBaseline));\n  }\n}\n\n@internal\nclass IconContent extends StatelessWidget {\n  final Widget child;\n\n  const IconContent({required this.child, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final FButtonData(:style, :states) = FButtonData.of(context);\n\n    return Padding(\n      padding: style.iconContentStyle.padding,\n      child: IconTheme(data: style.iconContentStyle.iconStyle.resolve(states), child: child),\n    );\n  }\n}\n\n/// [FButton] content's style.\nclass FButtonContentStyle with Diagnosticable, _$FButtonContentStyleFunctions {\n  /// The [TextStyle].\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<TextStyle> textStyle;\n\n  /// The icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<IconThemeData> iconStyle;\n\n  /// The circular progress's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<FCircularProgressStyle> circularProgressStyle;\n\n  /// The padding. Defaults to `EdgeInsets.symmetric(horizontal: 16, vertical: 12.5)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The spacing between prefix, child, and suffix. Defaults to 10.\n  @override\n  final double spacing;\n\n  /// Creates a [FButtonContentStyle].\n  const FButtonContentStyle({\n    required this.textStyle,\n    required this.iconStyle,\n    required this.circularProgressStyle,\n    this.padding = const EdgeInsets.symmetric(horizontal: 16, vertical: 12.5),\n    this.spacing = 10,\n  });\n\n  /// Creates a [FButtonContentStyle] that inherits its properties.\n  FButtonContentStyle.inherit({required FTypography typography, required Color enabled, required Color disabled})\n    : this(\n        textStyle: FWidgetStateMap({\n          WidgetState.disabled: typography.base.copyWith(color: disabled, fontWeight: FontWeight.w500, height: 1),\n          WidgetState.any: typography.base.copyWith(color: enabled, fontWeight: FontWeight.w500, height: 1),\n        }),\n        iconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: disabled, size: 20),\n          WidgetState.any: IconThemeData(color: enabled, size: 20),\n        }),\n        circularProgressStyle: FWidgetStateMap({\n          WidgetState.disabled: FCircularProgressStyle(iconStyle: IconThemeData(color: disabled, size: 20)),\n          WidgetState.any: FCircularProgressStyle(iconStyle: IconThemeData(color: enabled, size: 20)),\n        }),\n      );\n}\n\n/// [FButton] icon content's style.\nclass FButtonIconContentStyle with Diagnosticable, _$FButtonIconContentStyleFunctions {\n  /// The icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<IconThemeData> iconStyle;\n\n  /// The padding. Defaults to `EdgeInsets.all(7.5)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// Creates a [FButtonIconContentStyle].\n  const FButtonIconContentStyle({required this.iconStyle, this.padding = const EdgeInsets.all(7.5)});\n\n  /// Creates a [FButtonIconContentStyle] that inherits its properties.\n  FButtonIconContentStyle.inherit({required Color enabled, required Color disabled})\n    : this(\n        iconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: disabled, size: 20),\n          WidgetState.any: IconThemeData(color: enabled, size: 20),\n        }),\n      );\n}\n",
      "button_styles": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'button_styles.design.dart';\n\n/// [FButtonStyle]'s style.\nclass FButtonStyles with Diagnosticable, _$FButtonStylesFunctions {\n  /// The primary button style.\n  @override\n  final FButtonStyle primary;\n\n  /// The secondary  button style.\n  @override\n  final FButtonStyle secondary;\n\n  /// The destructive button style.\n  @override\n  final FButtonStyle destructive;\n\n  /// The outlined button style.\n  @override\n  final FButtonStyle outline;\n\n  /// The ghost button style.\n  @override\n  final FButtonStyle ghost;\n\n  /// Creates a [FButtonStyle].\n  const FButtonStyles({\n    required this.primary,\n    required this.secondary,\n    required this.destructive,\n    required this.outline,\n    required this.ghost,\n  });\n\n  /// Creates a [FButtonStyle] that inherits its properties.\n  FButtonStyles.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        primary: FButtonStyle.inherit(\n          colors: colors,\n          style: style,\n          typography: typography,\n          color: colors.primary,\n          foregroundColor: colors.primaryForeground,\n        ),\n        secondary: FButtonStyle.inherit(\n          colors: colors,\n          style: style,\n          typography: typography,\n          color: colors.secondary,\n          foregroundColor: colors.secondaryForeground,\n        ),\n        destructive: FButtonStyle.inherit(\n          colors: colors,\n          style: style,\n          typography: typography,\n          color: colors.destructive,\n          foregroundColor: colors.destructiveForeground,\n        ),\n        outline: FButtonStyle(\n          decoration: FWidgetStateMap({\n            WidgetState.disabled: BoxDecoration(\n              border: Border.all(color: colors.disable(colors.border)),\n              borderRadius: style.borderRadius,\n            ),\n            WidgetState.hovered | WidgetState.pressed: BoxDecoration(\n              border: Border.all(color: colors.border),\n              borderRadius: style.borderRadius,\n              color: colors.secondary,\n            ),\n            WidgetState.any: BoxDecoration(\n              border: Border.all(color: colors.border),\n              borderRadius: style.borderRadius,\n            ),\n          }),\n          focusedOutlineStyle: style.focusedOutlineStyle,\n          contentStyle: FButtonContentStyle.inherit(\n            typography: typography,\n            enabled: colors.secondaryForeground,\n            disabled: colors.disable(colors.secondaryForeground),\n          ),\n          iconContentStyle: FButtonIconContentStyle.inherit(\n            enabled: colors.secondaryForeground,\n            disabled: colors.disable(colors.secondaryForeground),\n          ),\n          tappableStyle: style.tappableStyle,\n        ),\n        ghost: FButtonStyle(\n          decoration: FWidgetStateMap({\n            WidgetState.disabled: BoxDecoration(borderRadius: style.borderRadius),\n            WidgetState.hovered | WidgetState.pressed: BoxDecoration(\n              borderRadius: style.borderRadius,\n              color: colors.secondary,\n            ),\n            WidgetState.any: BoxDecoration(borderRadius: style.borderRadius),\n          }),\n          focusedOutlineStyle: style.focusedOutlineStyle,\n          contentStyle: FButtonContentStyle.inherit(\n            typography: typography,\n            enabled: colors.secondaryForeground,\n            disabled: colors.disable(colors.secondaryForeground),\n          ),\n          iconContentStyle: FButtonIconContentStyle.inherit(\n            enabled: colors.secondaryForeground,\n            disabled: colors.disable(colors.secondaryForeground),\n          ),\n          tappableStyle: style.tappableStyle,\n        ),\n      );\n}\n"
    },
    "Calendar": {
      "calendar": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\nimport 'package:sugar/sugar.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/calendar/day/day_picker.dart';\nimport 'package:forui/src/widgets/calendar/day/paged_day_picker.dart';\nimport 'package:forui/src/widgets/calendar/shared/header.dart';\nimport 'package:forui/src/widgets/calendar/year_month_picker.dart';\n\npart 'calendar.design.dart';\n\n/// A calendar.\n///\n/// The calendar pages are designed to be navigable through swipe gestures on mobile Android, iOS & iPadOS, allowing\n/// left and right swipes to transition between pages.\n///\n/// All [DateTime]s are in UTC timezone. A [FCalendarController] is used to customize the date selection behavior.\n/// [DateTime]s outside [start] and [end] are unselectable regardless of the [FCalendarController] used.\n///\n/// See:\n/// * https://forui.dev/docs/calendar for working examples.\n/// * [FCalendarController] for customizing a calendar's date selection behavior.\n/// * [FCalendarStyle] for customizing a calendar's appearance.\nclass FCalendar extends StatefulWidget {\n  /// The default day builder.\n  static Widget defaultDayBuilder(BuildContext _, FCalendarDayData data, Widget? child) => child!;\n\n  /// The style. Defaults to [FThemeData.calendarStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create calendar\n  /// ```\n  final FCalendarStyle Function(FCalendarStyle style)? style;\n\n  /// A controller that determines if a date is selected.\n  final FCalendarController controller;\n\n  /// The builder used to build a day in the day picker. Defaults to returning the given child.\n  ///\n  /// The `child` is the default content with no alterations. Consider wrapping the `child` and other custom decoration\n  /// in a [Stack] to avoid re-creating the custom day content from scratch.\n  final ValueWidgetBuilder<FCalendarDayData> dayBuilder;\n\n  /// The start date, inclusive. It is truncated to the nearest date. Defaults to 1st January, 1900.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [end] <= [start].\n  final DateTime start;\n\n  /// The end date, exclusive. It is truncated to the nearest date. Defaults to 1st January, 2100.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [end] <= [start].\n  final DateTime end;\n\n  /// The current date. It is truncated to the nearest date. Defaults to the [DateTime.now].\n  final DateTime today;\n\n  /// A callback for when the displayed month changes.\n  final ValueChanged<DateTime>? onMonthChange;\n\n  /// A callback for when a date in a [FCalendarPickerType.day] picker is pressed.\n  final ValueChanged<DateTime>? onPress;\n\n  /// A callback for when a date in a [FCalendarPickerType.day] picker is long pressed.\n  final ValueChanged<DateTime>? onLongPress;\n\n  final FCalendarPickerType _initialType;\n  final LocalDate _initialMonth;\n\n  /// Creates a [FCalendar].\n  ///\n  /// Subsequently changing [initialType] has no effect.\n  ///\n  /// [initialMonth] defaults to [today]. It is truncated to the nearest date. Subsequently changing [initialMonth] has\n  /// no effect. To change the selected date, change the key to create a new [FCalendar], and provide that widget the\n  /// new [initialMonth]. This will reset the widget's interactive state.\n  FCalendar({\n    required this.controller,\n    this.style,\n    this.dayBuilder = defaultDayBuilder,\n    this.onMonthChange,\n    this.onPress,\n    this.onLongPress,\n    FCalendarPickerType initialType = FCalendarPickerType.day,\n    DateTime? start,\n    DateTime? end,\n    DateTime? today,\n    DateTime? initialMonth,\n    super.key,\n  }) : start = start ?? DateTime(1900),\n       end = end ?? DateTime(2100),\n       today = today ?? DateTime.now(),\n       _initialType = initialType,\n       _initialMonth = (initialMonth ?? today ?? DateTime.now()).toLocalDate().truncate(to: DateUnit.months) {\n    assert(this.start.toLocalDate() < this.end.toLocalDate(), 'start ($start) must be < end ($end)');\n  }\n\n  @override\n  State<FCalendar> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(ObjectFlagProperty.has('dayBuilder', dayBuilder))\n      ..add(DiagnosticsProperty('start', start))\n      ..add(DiagnosticsProperty('end', end))\n      ..add(DiagnosticsProperty('today', today))\n      ..add(ObjectFlagProperty.has('onMonthChange', onMonthChange))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(ObjectFlagProperty.has('onLongPress', onLongPress));\n  }\n}\n\nclass _State extends State<FCalendar> {\n  late ValueNotifier<FCalendarPickerType> _type;\n  late ValueNotifier<LocalDate> _month;\n\n  @override\n  void initState() {\n    super.initState();\n    _type = ValueNotifier(widget._initialType);\n    _month = ValueNotifier(widget._initialMonth);\n  }\n\n  @override\n  void dispose() {\n    _month.dispose();\n    _type.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.calendarStyle) ?? context.theme.calendarStyle;\n    return DecoratedBox(\n      decoration: style.decoration,\n      child: Padding(\n        padding: style.padding,\n        child: SizedBox(\n          height: (DayPicker.maxRows * style.dayPickerStyle.tileSize) + Header.height + 5,\n          width: DateTime.daysPerWeek * style.dayPickerStyle.tileSize,\n          child: Stack(\n            alignment: Alignment.topCenter,\n            children: [\n              ValueListenableBuilder(\n                valueListenable: _month,\n                builder: (_, month, _) => Header(style: style.headerStyle, type: _type, month: month),\n              ),\n              ValueListenableBuilder(\n                valueListenable: _type,\n                builder: (_, value, _) => switch (value) {\n                  FCalendarPickerType.day => PagedDayPicker(\n                    style: style,\n                    dayBuilder: widget.dayBuilder,\n                    start: widget.start.toLocalDate(),\n                    end: widget.end.toLocalDate(),\n                    today: widget.today.toLocalDate(),\n                    initial: _month.value,\n                    selectable: (date) => widget.controller.selectable(date.toNative()),\n                    selected: (date) => widget.controller.selected(date.toNative()),\n                    onMonthChange: (date) {\n                      _month.value = date;\n                      widget.onMonthChange?.call(date.toNative());\n                    },\n                    onPress: (date) {\n                      final native = date.toNative();\n                      widget.controller.select(native);\n                      widget.onPress?.call(native);\n                    },\n                    onLongPress: (date) => widget.onLongPress?.call(date.toNative()),\n                  ),\n                  FCalendarPickerType.yearMonth => YearMonthPicker(\n                    style: style,\n                    start: widget.start.toLocalDate(),\n                    end: widget.end.toLocalDate(),\n                    today: widget.today.toLocalDate(),\n                    month: _month,\n                    type: _type,\n                  ),\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// The calendar's style.\nclass FCalendarStyle with Diagnosticable, _$FCalendarStyleFunctions {\n  /// The header's style.\n  @override\n  final FCalendarHeaderStyle headerStyle;\n\n  /// The day picker's style.\n  @override\n  final FCalendarDayPickerStyle dayPickerStyle;\n\n  /// The year/month picker's style.\n  @override\n  final FCalendarEntryStyle yearMonthPickerStyle;\n\n  /// The decoration surrounding the header & picker.\n  @override\n  final BoxDecoration decoration;\n\n  /// The padding surrounding the header & picker. Defaults to `EdgeInsets.symmetric(horizontal: 12, vertical: 16)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The duration of the page switch animation. Defaults to 200 milliseconds.\n  @override\n  final Duration pageAnimationDuration;\n\n  /// Creates a new [FCalendarStyle].\n  FCalendarStyle({\n    required this.headerStyle,\n    required this.dayPickerStyle,\n    required this.yearMonthPickerStyle,\n    required this.decoration,\n    this.padding = const EdgeInsets.symmetric(horizontal: 12, vertical: 16),\n    this.pageAnimationDuration = const Duration(milliseconds: 200),\n  });\n\n  /// Creates a [FCalendarStyle] that inherits its properties.\n  FCalendarStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        headerStyle: FCalendarHeaderStyle.inherit(colors: colors, typography: typography, style: style),\n        dayPickerStyle: FCalendarDayPickerStyle.inherit(colors: colors, typography: typography),\n        yearMonthPickerStyle: FCalendarEntryStyle(\n          backgroundColor: FWidgetStateMap({\n            (WidgetState.hovered | WidgetState.pressed) & ~WidgetState.disabled: colors.secondary,\n            WidgetState.any: colors.background,\n          }),\n          borderColor: FWidgetStateMap({\n            WidgetState.disabled: colors.background,\n            WidgetState.focused: colors.foreground,\n          }),\n          textStyle: FWidgetStateMap({\n            WidgetState.disabled: typography.base.copyWith(\n              color: colors.disable(colors.mutedForeground),\n              fontWeight: FontWeight.w500,\n            ),\n            WidgetState.any: typography.base.copyWith(color: colors.foreground, fontWeight: FontWeight.w500),\n          }),\n          radius: const Radius.circular(8),\n        ),\n        decoration: BoxDecoration(\n          borderRadius: style.borderRadius,\n          border: Border.all(color: colors.border),\n          color: colors.background,\n        ),\n      );\n}\n",
      "calendar_controller": "import 'package:sugar/sugar.dart';\n\nimport 'package:forui/forui.dart';\n\nbool _true(DateTime _) => true;\n\nDateTime _truncateAndStripTimezone(DateTime date) => DateTime.utc(date.year, date.month, date.day);\n\n/// A controller that controls date selection in a calendar.\n///\n/// All returned [DateTime]s are in UTC timezone with no time component. It is possible to set the controller's value\n/// to a unselectable date. Doing so will result in undefined behavior.\n///\n/// This class should be extended to customize date selection. By default, the following controllers are provided:\n/// * [FCalendarController.date] for selecting a single date.\n/// * [FCalendarController.dates] for selecting multiple dates.\n/// * [FCalendarController.range] for selecting a single range.\nabstract class FCalendarController<T> extends FValueNotifier<T> {\n  /// Creates a [FCalendarController] that allows only a single date to be selected, with the given initially selected\n  /// date.\n  ///\n  /// [selectable] will always return true if not given.\n  ///\n  /// [toggleable] determines whether the controller should unselect a date if it is already selected. Defaults to true.\n  ///\n  /// [truncateAndStripTimezone] determines whether the controller should truncate and convert all given [DateTime]s to\n  /// dates in UTC timezone. Defaults to true.\n  ///\n  /// ```dart\n  /// DateTime truncateAndStripTimezone(DateTime date) => DateTime.utc(date.year, date.month, date.day);\n  /// ```\n  ///\n  /// [truncateAndStripTimezone] should be set to false if you can guarantee that all dates are in UTC timezone (with\n  /// the help of a 3rd party library), which will improve performance. **Warning:** Giving a [DateTime] in local\n  /// timezone or with a time component when [truncateAndStripTimezone] is false is undefined behavior.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [initialSelection] is not in UTC timezone and [truncateAndStripTimezone] is false.\n  static FCalendarController<DateTime?> date({\n    DateTime? initialSelection,\n    Predicate<DateTime>? selectable,\n    bool toggleable = true,\n    bool truncateAndStripTimezone = true,\n  }) => truncateAndStripTimezone\n      ? _AutoDateController(initialSelection: initialSelection, selectable: selectable, toggleable: toggleable)\n      : _DateController(initialSelection: initialSelection, selectable: selectable, toggleable: toggleable);\n\n  /// Creates a [FCalendarController] that allows multiple dates to be selected, with the given initial selected dates.\n  ///\n  /// [selectable] will always return true if not given.\n  ///\n  /// [truncateAndStripTimezone] determines whether the controller should truncate and convert all given [DateTime]s to\n  /// dates in UTC timezone. Defaults to true.\n  ///\n  /// ```dart\n  /// DateTime truncateAndStripTimezone(DateTime date) => DateTime.utc(date.year, date.month, date.day);\n  /// ```\n  ///\n  /// [truncateAndStripTimezone] should be set to false if you can guarantee that all dates are in UTC timezone (with\n  /// the help of a 3rd party library), which will improve performance. **Warning:** Giving a [DateTime] in local\n  /// timezone or with a time component when [truncateAndStripTimezone] is false is undefined behavior.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if the dates in [initialSelections] are not in UTC timezone and [truncateAndStripTimezone]\n  /// is false.\n  static FCalendarController<Set<DateTime>> dates({\n    Set<DateTime> initialSelections = const {},\n    Predicate<DateTime>? selectable,\n    bool truncateAndStripTimezone = true,\n  }) => truncateAndStripTimezone\n      ? _AutoDatesController(initialSelections: initialSelections, selectable: selectable)\n      : _DatesController(initialSelections: initialSelections, selectable: selectable);\n\n  /// Creates a [FCalendarController] that allows a single range to be selected, with the given initial range.\n  ///\n  /// [selectable] will always return true if not given.\n  ///\n  /// [truncateAndStripTimezone] determines whether the controller should truncate and convert all given [DateTime]s to\n  /// dates in UTC timezone. Defaults to true.\n  ///\n  /// ```dart\n  /// DateTime truncateAndStripTimezone(DateTime date) => DateTime.utc(date.year, date.month, date.day);\n  /// ```\n  ///\n  /// [truncateAndStripTimezone] should be set to false if you can guarantee that all dates are in UTC timezone (with\n  /// the help of a 3rd party library), which will improve performance. **Warning:** Giving a [DateTime] in local\n  /// timezone or with a time component when [truncateAndStripTimezone] is false is undefined behavior.\n  ///\n  /// Both the start and end dates of the range are inclusive. Unselectable dates within the selected range are selected\n  /// regardless.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * the given dates in [initialSelection] are not in UTC timezone and [truncateAndStripTimezone] is false.\n  /// * the end date is less than start date.\n  static FCalendarController<(DateTime, DateTime)?> range({\n    (DateTime, DateTime)? initialSelection,\n    Predicate<DateTime>? selectable,\n    bool truncateAndStripTimezone = true,\n  }) => truncateAndStripTimezone\n      ? _AutoRangeController(initialSelection: initialSelection, selectable: selectable)\n      : _RangeController(initialSelection: initialSelection, selectable: selectable);\n\n  /// Creates a [FCalendarController] with the given initial [value].\n  FCalendarController(super._value);\n\n  /// Returns true if the given [date] can be selected/unselected.\n  ///\n  /// ## Note\n  /// It is unsafe for this function to have side effects since it may be called more than once for a single date. As it\n  /// is called frequently, it should also not be computationally expensive.\n  bool selectable(DateTime date);\n\n  /// Returns true if the given [date] is selected.\n  bool selected(DateTime date);\n\n  /// Selects the given [date].\n  void select(DateTime date);\n}\n\n// The single date controllers.\nclass _AutoDateController extends FCalendarController<DateTime?> {\n  final Predicate<DateTime> _selectable;\n  final bool toggleable;\n\n  _AutoDateController({\n    required DateTime? initialSelection,\n    required Predicate<DateTime>? selectable,\n    required this.toggleable,\n  }) : _selectable = selectable ?? _true,\n       super(initialSelection = initialSelection == null ? null : _truncateAndStripTimezone(initialSelection));\n\n  @override\n  bool selectable(DateTime date) => _selectable(_truncateAndStripTimezone(date));\n\n  @override\n  bool selected(DateTime date) => value == _truncateAndStripTimezone(date);\n\n  @override\n  void select(DateTime date) {\n    date = _truncateAndStripTimezone(date);\n    super.value = (toggleable && value == date) ? null : date;\n  }\n\n  @override\n  set value(DateTime? value) {\n    if (toggleable && super.value == value) {\n      super.value = null;\n    } else {\n      super.value = value == null ? null : _truncateAndStripTimezone(value);\n    }\n  }\n}\n\nclass _DateController extends FCalendarController<DateTime?> {\n  final Predicate<DateTime> _selectable;\n  final bool toggleable;\n\n  _DateController({\n    required DateTime? initialSelection,\n    required Predicate<DateTime>? selectable,\n    required this.toggleable,\n  }) : assert(initialSelection?.isUtc ?? true, 'initialSelection ($initialSelection) must be in UTC timezone'),\n       _selectable = selectable ?? _true,\n       super(initialSelection);\n\n  @override\n  bool selectable(DateTime date) => _selectable(date);\n\n  @override\n  bool selected(DateTime date) => value == date;\n\n  @override\n  void select(DateTime date) => value = (toggleable && value == date) ? null : date;\n\n  @override\n  set value(DateTime? value) => super.value = (toggleable && super.value == value) ? null : value;\n}\n\n// The multiple dates controllers.\nfinal class _AutoDatesController extends FCalendarController<Set<DateTime>> {\n  final Predicate<DateTime> _selectable;\n\n  _AutoDatesController({Set<DateTime> initialSelections = const {}, Predicate<DateTime>? selectable})\n    : _selectable = selectable ?? _true,\n      super(initialSelections.map(_truncateAndStripTimezone).toSet());\n\n  @override\n  bool selectable(DateTime date) => _selectable(_truncateAndStripTimezone(date));\n\n  @override\n  bool selected(DateTime date) => value.contains(_truncateAndStripTimezone(date));\n\n  @override\n  void select(DateTime date) {\n    final copy = {...value};\n    super.value = copy..toggle(_truncateAndStripTimezone(date));\n  }\n\n  @override\n  set value(Set<DateTime> value) => super.value = value.map(_truncateAndStripTimezone).toSet();\n}\n\nfinal class _DatesController extends FCalendarController<Set<DateTime>> {\n  final Predicate<DateTime> _selectable;\n\n  _DatesController({Set<DateTime> initialSelections = const {}, Predicate<DateTime>? selectable})\n    : assert(initialSelections.every((d) => d.isUtc), 'initialSelections ($initialSelections) must be in UTC timezone'),\n      _selectable = selectable ?? _true,\n      super(initialSelections);\n\n  @override\n  bool selectable(DateTime date) => _selectable(date);\n\n  @override\n  bool selected(DateTime date) => value.contains(date);\n\n  @override\n  void select(DateTime date) => value = value..toggle(date);\n}\n\n// The range controllers.\nfinal class _AutoRangeController extends FCalendarController<(DateTime, DateTime)?> {\n  final Predicate<DateTime> _selectable;\n\n  _AutoRangeController({(DateTime, DateTime)? initialSelection, Predicate<DateTime>? selectable})\n    : _selectable = selectable ?? _true,\n      super(\n        initialSelection = initialSelection == null\n            ? null\n            : (_truncateAndStripTimezone(initialSelection.$1), _truncateAndStripTimezone(initialSelection.$2)),\n      ) {\n    final range = value;\n    assert(\n      range == null || (range.$1.isBefore(range.$2) || range.$1.isAtSameMomentAs(range.$2)),\n      'start (${range.$1}) must be <= end (${range.$2})',\n    );\n  }\n\n  @override\n  bool selectable(DateTime date) => _selectable(_truncateAndStripTimezone(date));\n\n  @override\n  bool selected(DateTime date) {\n    if (value case (final first, final last)) {\n      final current = date.toLocalDate();\n      return first.toLocalDate() <= current && current <= last.toLocalDate();\n    }\n\n    return false;\n  }\n\n  @override\n  void select(DateTime date) {\n    date = _truncateAndStripTimezone(date);\n    switch (value) {\n      case null:\n        super.value = (date, date);\n\n      case (final first, final last) when date == first || date == last:\n        super.value = null;\n\n      case (final first, final last) when date.isBefore(first):\n        super.value = (date, last);\n\n      case (final first, _):\n        super.value = (first, date);\n    }\n  }\n\n  @override\n  set value((DateTime, DateTime)? value) =>\n      super.value = value == null ? null : (_truncateAndStripTimezone(value.$1), _truncateAndStripTimezone(value.$2));\n}\n\nfinal class _RangeController extends FCalendarController<(DateTime, DateTime)?> {\n  final Predicate<DateTime> _selectable;\n\n  _RangeController({(DateTime, DateTime)? initialSelection, Predicate<DateTime>? selectable})\n    : assert(\n        initialSelection == null || (initialSelection.$1.isUtc && initialSelection.$2.isUtc),\n        'value must be in UTC timezone',\n      ),\n      assert(\n        initialSelection == null ||\n            (initialSelection.$1.isBefore(initialSelection.$2) ||\n                initialSelection.$1.isAtSameMomentAs(initialSelection.$2)),\n        'end date must be greater than or equal to start date',\n      ),\n      _selectable = selectable ?? _true,\n      super(initialSelection);\n\n  @override\n  bool selectable(DateTime date) => _selectable(date);\n\n  @override\n  bool selected(DateTime date) {\n    if (value case (final first, final last)) {\n      final current = date.toLocalDate();\n      return first.toLocalDate() <= current && current <= last.toLocalDate();\n    }\n\n    return false;\n  }\n\n  @override\n  void select(DateTime date) {\n    switch (value) {\n      case null:\n        super.value = (date, date);\n\n      case (final first, final last) when date == first || date == last:\n        super.value = null;\n\n      case (final first, final last) when date.isBefore(first):\n        super.value = (date, last);\n\n      case (final first, _):\n        super.value = (first, date);\n    }\n  }\n}\n",
      "year_month_picker": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:sugar/sugar.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/calendar/month/paged_month_picker.dart';\nimport 'package:forui/src/widgets/calendar/year/paged_year_picker.dart';\n\n@internal\nclass YearMonthPicker extends StatefulWidget {\n  final FCalendarStyle style;\n  final LocalDate start;\n  final LocalDate end;\n  final LocalDate today;\n  final ValueNotifier<LocalDate> month;\n  final ValueNotifier<FCalendarPickerType> type;\n\n  const YearMonthPicker({\n    required this.style,\n    required this.start,\n    required this.end,\n    required this.today,\n    required this.month,\n    required this.type,\n    super.key,\n  });\n\n  @override\n  State<YearMonthPicker> createState() => _YearMonthPickerState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('start', start))\n      ..add(DiagnosticsProperty('end', end))\n      ..add(DiagnosticsProperty('today', today))\n      ..add(DiagnosticsProperty('month', month))\n      ..add(DiagnosticsProperty('type', type));\n  }\n}\n\nclass _YearMonthPickerState extends State<YearMonthPicker> {\n  bool _year = true;\n\n  @override\n  Widget build(BuildContext _) {\n    if (_year) {\n      return PagedYearPicker(\n        style: widget.style,\n        start: widget.start.truncate(to: DateUnit.years),\n        end: widget.end.truncate(to: DateUnit.years),\n        today: widget.today,\n        initial: widget.month.value.truncate(to: DateUnit.years),\n        onPress: (date) {\n          widget.month.value = switch (widget.month.value.copyWith(year: date.year)) {\n            final proposed when proposed < widget.start => widget.start,\n            final proposed when widget.end < proposed => widget.end,\n            final proposed => proposed,\n          };\n\n          setState(() {\n            _year = false;\n          });\n        },\n      );\n    } else {\n      return PagedMonthPicker(\n        style: widget.style,\n        start: widget.start.truncate(to: DateUnit.months),\n        end: widget.end.truncate(to: DateUnit.months),\n        today: widget.today,\n        initial: widget.month.value.truncate(to: DateUnit.years),\n        onPress: (date) {\n          widget.month.value = switch (widget.month.value.copyWith(month: date.month)) {\n            final proposed when proposed < widget.start => widget.start,\n            final proposed when widget.end < proposed => widget.end,\n            final proposed => proposed,\n          };\n\n          widget.type.value = FCalendarPickerType.day;\n        },\n      );\n    }\n  }\n}\n"
    },
    "Card": {
      "card": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/card/card_content.dart';\n\npart 'card.design.dart';\n\n/// A card.\n///\n/// Cards are typically used to group related information together.\n///\n/// See:\n/// * https://forui.dev/docs/data/card for working examples.\n/// * [FCardStyle] for customizing a card's appearance.\nclass FCard extends StatelessWidget {\n  /// The style. Defaults to [FThemeData.cardStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create card\n  /// ```\n  final FCardStyle Function(FCardStyle style)? style;\n\n  /// The child.\n  final Widget child;\n\n  /// Creates a [FCard] with a title, subtitle, and [child].\n  ///\n  /// The card's layout is as follows:\n  /// ```diagram\n  /// |---------------------------|\n  /// |  [image]                  |\n  /// |                           |\n  /// |  [title]                  |\n  /// |  [subtitle]               |\n  /// |                           |\n  /// |  [child]                  |\n  /// |---------------------------|\n  /// ```\n  FCard({Widget? image, Widget? title, Widget? subtitle, Widget? child, this.style, super.key})\n    : child = Content(image: image, title: title, subtitle: subtitle, style: style, child: child);\n\n  /// Creates a [FCard] with custom content.\n  const FCard.raw({required this.child, this.style, super.key});\n\n  @override\n  Widget build(BuildContext context) => DecoratedBox(\n    decoration: (style?.call(context.theme.cardStyle) ?? context.theme.cardStyle).decoration,\n    child: child,\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// [FCard]'s style.\nclass FCardStyle with Diagnosticable, _$FCardStyleFunctions {\n  /// The decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// The card content's style.\n  @override\n  final FCardContentStyle contentStyle;\n\n  /// Creates a [FCardStyle].\n  FCardStyle({required this.decoration, required this.contentStyle});\n\n  /// Creates a [FCardStyle] that inherits its properties.\n  FCardStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        decoration: BoxDecoration(\n          border: Border.all(color: colors.border),\n          borderRadius: style.borderRadius,\n          color: colors.background,\n        ),\n        contentStyle: FCardContentStyle(\n          titleTextStyle: typography.xl2.copyWith(fontWeight: FontWeight.w600, color: colors.foreground, height: 1.5),\n          subtitleTextStyle: typography.sm.copyWith(color: colors.mutedForeground),\n        ),\n      );\n}\n",
      "card_content": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'card_content.design.dart';\n\n@internal\nclass Content extends StatelessWidget {\n  final Widget? image;\n  final Widget? title;\n  final Widget? subtitle;\n  final Widget? child;\n  final FCardStyle Function(FCardStyle style)? style;\n\n  const Content({this.image, this.title, this.subtitle, this.child, this.style, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final style = (this.style?.call(context.theme.cardStyle) ?? context.theme.cardStyle).contentStyle;\n    return Padding(\n      padding: style.padding,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          if (image case final image?) ClipRRect(borderRadius: context.theme.style.borderRadius, child: image),\n          if ((title != null || subtitle != null || child != null) && image != null)\n            SizedBox(height: style.imageSpacing),\n          if (title case final title?)\n            DefaultTextStyle.merge(\n              textHeightBehavior: const TextHeightBehavior(\n                applyHeightToFirstAscent: false,\n                applyHeightToLastDescent: false,\n              ),\n              style: style.titleTextStyle,\n              child: title,\n            ),\n          if (subtitle case final subtitle?)\n            DefaultTextStyle.merge(\n              textHeightBehavior: const TextHeightBehavior(\n                applyHeightToFirstAscent: false,\n                applyHeightToLastDescent: false,\n              ),\n              style: style.subtitleTextStyle,\n              child: subtitle,\n            ),\n          if (title != null && subtitle != null && image == null) SizedBox(height: style.subtitleSpacing),\n          ?child,\n        ],\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('image', image));\n  }\n}\n\n/// [FCard] content's style.\nclass FCardContentStyle with Diagnosticable, _$FCardContentStyleFunctions {\n  /// The spacing between the image and the title, subtitle, and child if any of them is provided. Defaults to 10.\n  @override\n  final double imageSpacing;\n\n  /// The spacing between the title/subtitle and the child if an image is provided. Defaults to 8.\n  @override\n  final double subtitleSpacing;\n\n  /// The title's [TextStyle].\n  @override\n  final TextStyle titleTextStyle;\n\n  /// The subtitle's [TextStyle].\n  @override\n  final TextStyle subtitleTextStyle;\n\n  /// The padding. Defaults to `EdgeInsets.all(16)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// Creates a [FCardContentStyle].\n  const FCardContentStyle({\n    required this.titleTextStyle,\n    required this.subtitleTextStyle,\n    this.imageSpacing = 10,\n    this.subtitleSpacing = 8,\n    this.padding = const EdgeInsets.all(16),\n  });\n}\n"
    },
    "DateField": {
      "date_field": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:intl/intl.dart' hide TextDirection;\nimport 'package:sugar/sugar.dart' hide Offset;\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/form_field.dart';\nimport 'package:forui/src/widgets/date_field/input/date_input.dart';\n\npart 'calendar/calendar_date_field.dart';\n\npart 'input/input_date_field.dart';\n\n/// The date field's controller.\nclass FDateFieldController implements FValueNotifier<DateTime?> {\n  static String? _defaultValidator(DateTime? _) => null;\n\n  /// The controller for the calendar popover. Does nothing if the date field is input only.\n  ///\n  /// ## Contract\n  /// Manually disposing this controller is undefined behavior. Dispose this [FDateFieldController] instead.\n  final FPopoverController calendar;\n\n  /// Returns an error string to display if the input is invalid, or null otherwise. It is also used to determine\n  /// whether a date in a calendar is selectable.\n  ///\n  /// Defaults to always returning null.\n  final FormFieldValidator<DateTime> validator;\n\n  /// True if the controller should truncate and convert all given [DateTime]s to dates in UTC timezone. Defaults to\n  /// true.\n  ///\n  /// ```dart\n  /// DateTime truncateAndStripTimezone(DateTime date) => DateTime.utc(date.year, date.month, date.day);\n  /// ```\n  ///\n  /// [truncateAndStripTimezone] should be set to false if you can guarantee that all dates are in UTC timezone (with\n  /// the help of a 3rd party library), which will improve performance. **Warning:** Giving a [DateTime] in local\n  /// timezone or with a time component when [truncateAndStripTimezone] is false is undefined behavior.\n  final bool truncateAndStripTimezone;\n\n  /// We use the calendar controller as the source of truth.\n  final FCalendarController<DateTime?> _calendar;\n\n  /// Creates a [FDateFieldController].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [initialDate] is not in UTC timezone and [truncateAndStripTimezone] is false.\n  FDateFieldController({\n    required TickerProvider vsync,\n    this.validator = _defaultValidator,\n    this.truncateAndStripTimezone = true,\n    DateTime? initialDate,\n    FPopoverMotion popoverMotion = const FPopoverMotion(),\n  }) : calendar = FPopoverController(vsync: vsync, motion: popoverMotion),\n       _calendar = FCalendarController.date(\n         initialSelection: initialDate,\n         selectable: (date) => validator(date) == null,\n       );\n\n  @override\n  void addListener(VoidCallback listener) => _calendar.addListener(listener);\n\n  @override\n  void addValueListener(ValueChanged<DateTime?>? listener) => _calendar.addValueListener(listener);\n\n  @override\n  void notifyListeners() => _calendar.notifyListeners();\n\n  @override\n  void removeListener(VoidCallback listener) => _calendar.removeListener(listener);\n\n  @override\n  void removeValueListener(ValueChanged<DateTime?>? listener) => _calendar.removeValueListener(listener);\n\n  @override\n  bool get hasListeners => _calendar.hasListeners;\n\n  @override\n  DateTime? get value => _calendar.value;\n\n  @override\n  set value(DateTime? value) => _calendar.value = value;\n\n  @override\n  bool get disposed => _calendar.disposed;\n\n  @override\n  void dispose() {\n    _calendar.dispose();\n    calendar.dispose();\n  }\n}\n\n/// A date field allows a date to be selected from a calendar, input field, or both.\n///\n/// A [FDateField] is internally a [FormField], therefore it can be used in a [Form].\n///\n/// It is recommended to use [FDateField.calendar] on touch devices and [FDateField.new]/[FDateField.input] on\n/// non-touch devices.\n///\n/// The input field supports both arrow key navigation:\n/// * Up/Down arrows: Increment/decrement values\n/// * Left/Right arrows: Move between date segments\n///\n/// The input field does not support the following locales that use non-western numerals, it will default to English:\n/// {@macro forui.localizations.scriptNumerals}\n///\n/// Consider providing a [FDateFieldController.validator] to perform custom date validation logic. By default, all\n/// dates are valid.\n///\n/// See:\n/// * https://forui.dev/docs/form/date-field for working examples.\n/// * [FDateFieldController] for controlling a date field.\n/// * [FDateFieldCalendarProperties] for customizing a date field calendar's behavior.\n/// * [FDateFieldStyle] for customizing a date field's appearance.\nabstract class FDateField extends StatefulWidget {\n  /// The default prefix builder that shows a calendar icon.\n  static Widget defaultIconBuilder(BuildContext _, FDateFieldStyle style, Set<WidgetState> _) => Padding(\n    padding: const EdgeInsetsDirectional.only(start: 14.0, end: 8.0),\n    child: IconTheme(data: style.iconStyle, child: const Icon(FIcons.calendar)),\n  );\n\n  static Widget _fieldBuilder(BuildContext _, FDateFieldStyle _, Set<WidgetState> _, Widget child) => child;\n\n  /// The controller.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * Both [controller] and [initialDate] are provided.\n  final FDateFieldController? controller;\n\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create date-field\n  /// ```\n  final FDateFieldStyle Function(FDateFieldStyle style)? style;\n\n  /// The initial date.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * Both [controller] and [initialDate] are provided.\n  final DateTime? initialDate;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// The builder used to decorate the date-field. It should use the given child.\n  ///\n  /// Defaults to returning the given child.\n  final FFieldBuilder<FDateFieldStyle> builder;\n\n  /// Builds a widget at the start of the input field that can be pressed to toggle the calendar popover. Defaults to\n  /// [defaultIconBuilder].\n  final FFieldIconBuilder<FDateFieldStyle>? prefixBuilder;\n\n  /// Builds a widget at the end of the input field that can be pressed to toggle the calendar popover. Defaults to\n  /// no prefix.\n  final FFieldIconBuilder<FDateFieldStyle>? suffixBuilder;\n\n  /// The label.\n  final Widget? label;\n\n  /// The description.\n  final Widget? description;\n\n  /// {@macro forui.foundation.form_field_properties.errorBuilder}\n  final Widget Function(BuildContext context, String message) errorBuilder;\n\n  /// {@macro forui.foundation.form_field_properties.enabled}\n  final bool enabled;\n\n  /// Handler called when the date changes.\n  ///\n  /// The given [DateTime] is always in UTC timezone.\n  final ValueChanged<DateTime?>? onChange;\n\n  /// {@macro forui.foundation.form_field_properties.onSaved}\n  final FormFieldSetter<DateTime>? onSaved;\n\n  /// {@macro forui.foundation.form_field_properties.onReset}\n  final VoidCallback? onReset;\n\n  /// Used to enable/disable this checkbox auto validation and update its error text.\n  ///\n  /// Defaults to [AutovalidateMode.onUnfocus].\n  ///\n  /// If [AutovalidateMode.onUserInteraction], this checkbox will only auto-validate after its content changes. If\n  /// [AutovalidateMode.always], it will auto-validate even without user interaction. If [AutovalidateMode.disabled],\n  /// auto-validation will be disabled.\n  final AutovalidateMode autovalidateMode;\n\n  /// An optional property that forces the [FormFieldState] into an error state by directly setting the\n  /// [FormFieldState.errorText] property without running the validator function.\n  ///\n  /// When the [forceErrorText] property is provided, the [FormFieldState.errorText] will be set to the provided value,\n  /// causing the form field to be considered invalid and to display the error message specified.\n  ///\n  /// When [FDateFieldController.validator] is provided, [forceErrorText] will override any error that it returns.\n  /// [FDateFieldController.validator] will not be called unless [forceErrorText] is null.\n  final String? forceErrorText;\n\n  FDateField._({\n    this.controller,\n    this.style,\n    this.autofocus = false,\n    this.focusNode,\n    this.builder = _fieldBuilder,\n    this.prefixBuilder = defaultIconBuilder,\n    this.suffixBuilder,\n    this.label,\n    this.description,\n    this.enabled = true,\n    this.onChange,\n    this.onSaved,\n    this.onReset,\n    this.autovalidateMode = AutovalidateMode.onUnfocus,\n    this.forceErrorText,\n    this.errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    DateTime? initialDate,\n    super.key,\n  }) : assert(\n         controller == null || initialDate == null,\n         'Cannot provide both a controller and an initialDate. To fix, set the date directly in the controller.',\n       ),\n       initialDate = initialDate?.toLocalDate().toNative();\n\n  /// Creates a [FDateField] that allows date selection through both an input field and a calendar popover.\n  ///\n  /// The input field supports arrow key navigation:\n  /// * Up/Down arrows: Increment/decrement values\n  /// * Left/Right arrows: Move between date segments\n  ///\n  /// The [textInputAction] property can be used to specify the action button on the soft keyboard. The [textAlign]\n  /// property is used to specify the alignment of the text within the input field.\n  ///\n  /// The [textAlignVertical] property is used to specify the vertical alignment of the text and can be useful when\n  /// used with a prefix or suffix.\n  ///\n  /// The [textDirection] property can be used to specify the directionality of the text input.\n  ///\n  /// If [expands] is true, the input field will expand to fill its parent's height.\n  ///\n  /// The [onEditingComplete] callback is called when the user submits the input field, such as by pressing the done\n  /// button on the keyboard.\n  ///\n  /// The [onSubmit] callback is called when the user submits a valid date value.\n  ///\n  /// The [mouseCursor] can be used to specify the cursor shown when hovering over the input field.\n  ///\n  /// If [canRequestFocus] is false, the input field cannot obtain focus but can still be selected.\n  ///\n  /// If [clearable] is true, the input field will show a clear button when a date is selected. Defaults to false.\n  ///\n  /// The [baselineInputYear] is used as a reference point for two-digit year input. Years will be interpreted as\n  /// being within 80 years before or 20 years after this year.\n  ///\n  /// The [calendar] property can be used to customize the appearance and behavior of the calendar popover.\n  ///\n  /// See also:\n  /// * [FDateField.calendar] - Creates a date field with only a calendar.\n  /// * [FDateField.input] - Creates a date field with only an input field.\n  factory FDateField({\n    FDateFieldController? controller,\n    FDateFieldStyle Function(FDateFieldStyle style)? style,\n    DateTime? initialDate,\n    FocusNode? focusNode,\n    TextInputAction? textInputAction,\n    TextAlign textAlign,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    bool autofocus,\n    bool expands,\n    VoidCallback? onEditingComplete,\n    ValueChanged<DateTime>? onSubmit,\n    MouseCursor? mouseCursor,\n    bool canRequestFocus,\n    bool clearable,\n    int baselineInputYear,\n    FFieldBuilder<FDateFieldStyle> builder,\n    FFieldIconBuilder<FDateFieldStyle>? prefixBuilder,\n    FFieldIconBuilder<FDateFieldStyle>? suffixBuilder,\n    FDateFieldCalendarProperties calendar,\n    Widget? label,\n    Widget? description,\n    bool enabled,\n    ValueChanged<DateTime?>? onChange,\n    FormFieldSetter<DateTime>? onSaved,\n    VoidCallback? onReset,\n    AutovalidateMode autovalidateMode,\n    String? forceErrorText,\n    Widget Function(BuildContext context, String message) errorBuilder,\n    Key? key,\n  }) = _InputDateField;\n\n  /// Creates a [FDateField] that allows a date to be selected using only a calendar.\n  ///\n  /// The [format] customizes the appearance of the date in the input field. Defaults to the `d MMM y` in the current\n  /// locale.\n  ///\n  /// The [hint] is displayed when the input field is empty. Defaults to the current locale's\n  /// [FLocalizations.dateFieldHint].\n  ///\n  /// The [textAlign] property is used to specify the alignment of the text within the input field.\n  ///\n  /// The [textAlignVertical] property is used to specify the vertical alignment of the text and can be useful when\n  /// used with a prefix or suffix.\n  ///\n  /// The [textDirection] property can be used to specify the directionality of the text input.\n  ///\n  /// If [expands] is true, the input field will expand to fill its parent's height.\n  ///\n  /// The [mouseCursor] can be used to specify the cursor shown when hovering over the input field.\n  ///\n  /// If [canRequestFocus] is false, the input field cannot obtain focus but can still be selected.\n  ///\n  /// If [clearable] is true, the input field will show a clear button when a date is selected. Defaults to false.\n  ///\n  /// The [dayBuilder] customizes the appearance of calendar day cells. Defaults to [FCalendar.defaultDayBuilder].\n  ///\n  /// The [start] and [end] parameters define the date range of selectable dates.\n  ///\n  /// The [today] parameter specifies which date should be considered as \"today\". If not provided,\n  /// uses the current date.\n  ///\n  /// The [initialType] determines the initial calendar view (day, month, year).\n  ///\n  /// When [autoHide] is true, the calendar will automatically hide after a date is selected.\n  ///\n  /// The [anchor] and [inputAnchor] control the alignment points for the calendar popover positioning.\n  /// Defaults to [Alignment.topLeft] and [Alignment.bottomLeft] respectively.\n  ///\n  /// The [spacing] property controls the spacing between the input field and the picker popover. Defaults to\n  /// `FPortalSpacing(4)`.\n  ///\n  /// The [overflow] function controls how the picker repositions when space is constrained. Defaults to\n  /// [FPortalOverflow.flip].\n  ///\n  /// The [offset] property controls the offset of the picker popover. Defaults to [Offset.zero].\n  ///\n  /// [hideRegion] controls the region that can be tapped to hide the popover. Defaults to\n  /// [FPopoverHideRegion.excludeChild].\n  ///\n  /// See also:\n  /// * [FDateField] - Creates a date field with both input field and calendar.\n  /// * [FDateField.input] - Creates a date field with only an input field.\n  factory FDateField.calendar({\n    FDateFieldController? controller,\n    FDateFieldStyle Function(FDateFieldStyle style)? style,\n    DateTime? initialDate,\n    DateFormat? format,\n    TextAlign textAlign,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    bool expands,\n    MouseCursor mouseCursor,\n    bool canRequestFocus,\n    bool clearable,\n    String? hint,\n    bool autofocus,\n    FocusNode? focusNode,\n    ValueWidgetBuilder<FCalendarDayData> dayBuilder,\n    DateTime? start,\n    DateTime? end,\n    DateTime? today,\n    FCalendarPickerType initialType,\n    bool autoHide,\n    Alignment anchor,\n    Alignment inputAnchor,\n    FPortalSpacing spacing,\n    FPortalOverflow overflow,\n    Offset offset,\n    FPopoverHideRegion hideRegion,\n    VoidCallback? onTapHide,\n    FFieldBuilder<FDateFieldStyle> builder,\n    FFieldIconBuilder<FDateFieldStyle>? prefixBuilder,\n    FFieldIconBuilder<FDateFieldStyle>? suffixBuilder,\n    Widget? label,\n    Widget? description,\n    bool enabled,\n    ValueChanged<DateTime?>? onChange,\n    FormFieldSetter<DateTime>? onSaved,\n    VoidCallback? onReset,\n    AutovalidateMode autovalidateMode,\n    String? forceErrorText,\n    Widget Function(BuildContext context, String message) errorBuilder,\n    Key? key,\n  }) = _CalendarDateField;\n\n  /// Creates a date field that wraps a text input field.\n  ///\n  /// The [textInputAction] property can be used to specify the action button on the soft keyboard. The [textAlign]\n  /// property is used to specify the alignment of the text within the input field.\n  ///\n  /// The [textAlignVertical] property is used to specify the vertical alignment of the text and can be useful when\n  /// used with a prefix or suffix.\n  ///\n  /// The [textDirection] property can be used to specify the directionality of the text input.\n  ///\n  /// If [expands] is true, the input field will expand to fill its parent's height.\n  ///\n  /// The [onEditingComplete] callback is called when the user submits the input field, such as by pressing the done\n  /// button on the keyboard.\n  ///\n  /// The [onSubmit] callback is called when the user submits a valid date value.\n  ///\n  /// The [mouseCursor] can be used to specify the cursor shown when hovering over the input field.\n  ///\n  /// If [canRequestFocus] is false, the input field cannot obtain focus but can still be selected.\n  ///\n  /// If [clearable] is true, the input field will show a clear button when a date is selected. Defaults to false.\n  ///\n  /// The [baselineInputYear] is used as a reference point for two-digit year input. Years will be interpreted as\n  /// being within 80 years before or 20 years after this year.\n  ///\n  /// See also:\n  /// * [FDateField] - Creates a date field with both input field and calendar.\n  /// * [FDateField.calendar] - Creates a date field with only a calendar.\n  factory FDateField.input({\n    FDateFieldController? controller,\n    FDateFieldStyle Function(FDateFieldStyle style)? style,\n    DateTime? initialDate,\n    bool autofocus = false,\n    FocusNode? focusNode,\n    FFieldBuilder<FDateFieldStyle> builder = _fieldBuilder,\n    FFieldIconBuilder<FDateFieldStyle>? prefixBuilder = defaultIconBuilder,\n    FFieldIconBuilder<FDateFieldStyle>? suffixBuilder,\n    TextInputAction? textInputAction,\n    TextAlign textAlign = TextAlign.start,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    bool expands = false,\n    VoidCallback? onEditingComplete,\n    ValueChanged<DateTime>? onSubmit,\n    MouseCursor? mouseCursor,\n    bool canRequestFocus = true,\n    bool clearable = false,\n    int baselineInputYear = 2000,\n    Widget? label,\n    Widget? description,\n    bool enabled = true,\n    ValueChanged<DateTime?>? onChange,\n    FormFieldSetter<DateTime>? onSaved,\n    VoidCallback? onReset,\n    AutovalidateMode autovalidateMode = AutovalidateMode.onUnfocus,\n    String? forceErrorText,\n    Widget Function(BuildContext context, String message) errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    Key? key,\n  }) => _InputDateField(\n    controller: controller,\n    style: style,\n    initialDate: initialDate,\n    autofocus: autofocus,\n    focusNode: focusNode,\n    builder: builder,\n    prefixBuilder: prefixBuilder,\n    suffixBuilder: suffixBuilder,\n    clearable: clearable,\n    textInputAction: textInputAction,\n    textAlign: textAlign,\n    textAlignVertical: textAlignVertical,\n    textDirection: textDirection,\n    expands: expands,\n    onEditingComplete: onEditingComplete,\n    onSubmit: onSubmit,\n    mouseCursor: mouseCursor,\n    canRequestFocus: canRequestFocus,\n    baselineInputYear: baselineInputYear,\n    calendar: null,\n    label: label,\n    description: description,\n    enabled: enabled,\n    onChange: onChange,\n    onSaved: onSaved,\n    onReset: onReset,\n    autovalidateMode: autovalidateMode,\n    forceErrorText: forceErrorText,\n    errorBuilder: errorBuilder,\n    key: key,\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('initialDate', initialDate))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(DiagnosticsProperty('builder', builder))\n      ..add(ObjectFlagProperty.has('prefixBuilder', prefixBuilder))\n      ..add(ObjectFlagProperty.has('suffixBuilder', suffixBuilder))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder))\n      ..add(FlagProperty('enabled', value: enabled, ifFalse: 'disabled'))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onSaved', onSaved))\n      ..add(ObjectFlagProperty.has('onReset', onReset))\n      ..add(EnumProperty('autovalidateMode', autovalidateMode))\n      ..add(StringProperty('forceErrorText', forceErrorText));\n  }\n}\n\nabstract class _FDateFieldState<T extends FDateField> extends State<T> with SingleTickerProviderStateMixin {\n  late FDateFieldController _controller =\n      widget.controller ?? FDateFieldController(vsync: this, initialDate: widget.initialDate);\n}\n",
      "date_field_style": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'date_field_style.design.dart';\n\n/// A date field's style.\nclass FDateFieldStyle with Diagnosticable, _$FDateFieldStyleFunctions {\n  /// The date field's textfield style.\n  @override\n  final FTextFieldStyle textFieldStyle;\n\n  /// The date field calendar's popover style.\n  @override\n  final FPopoverStyle popoverStyle;\n\n  /// The date field's calendar style.\n  @override\n  final FCalendarStyle calendarStyle;\n\n  /// The date field icon's style.\n  @override\n  final IconThemeData iconStyle;\n\n  /// Creates a [FDateFieldStyle].\n  const FDateFieldStyle({\n    required this.textFieldStyle,\n    required this.popoverStyle,\n    required this.calendarStyle,\n    required this.iconStyle,\n  });\n\n  /// Creates a [FDateFieldStyle] that inherits its properties.\n  FDateFieldStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        textFieldStyle: FTextFieldStyle.inherit(colors: colors, typography: typography, style: style),\n        popoverStyle: FPopoverStyle.inherit(colors: colors, style: style),\n        calendarStyle: FCalendarStyle.inherit(colors: colors, typography: typography, style: style),\n        iconStyle: IconThemeData(color: colors.mutedForeground, size: 18),\n      );\n}\n"
    },
    "Dialog": {
      "dialog": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/semantics.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/dialog/dialog_content.dart';\n\npart 'dialog.design.dart';\n\n/// Shows a dialog.\n///\n/// [context] is used to look up the [Navigator] and [FDialogStyle] for the dialog. It is only used when the method is\n/// called. Its corresponding widget can be safely removed from the tree before the sheet is closed.\n///\n/// [useRootNavigator] ensures that the root navigator displays the sheet when `true`. This is useful in the case that a\n/// modal sheet needs to be displayed above all other content but the caller is inside another [Navigator].\n///\n/// [routeStyle] defaults to [FDialogStyle] from the closest [FTheme] ancestor.\n///\n/// [barrierLabel] defaults to [FLocalizations.barrierLabel].\n///\n/// Returns a `Future` that resolves to the value (if any) that was passed to [Navigator.pop] when the modal sheet was\n/// closed.\n///\n/// ## CLI\n/// To generate and customize this widget's style:\n///\n/// ```shell\n/// dart run forui style create dialog\n/// ```\n///\n/// See:\n/// * https://forui.dev/docs/overlay/dialog for working examples.\n/// * [showAdaptiveDialog] for displaying a dialog with adaptive transitions depending on the platform.\n/// * [FDialogStyle] for customizing a switch's appearance.\nFuture<T?> showFDialog<T>({\n  required BuildContext context,\n  required Widget Function(BuildContext context, FDialogStyle style, Animation<double> animation) builder,\n  bool useRootNavigator = false,\n  FDialogRouteStyle Function(FDialogRouteStyle style)? routeStyle,\n  FDialogStyle Function(FDialogStyle style)? style,\n  String? barrierLabel,\n  bool barrierDismissible = true,\n  RouteSettings? routeSettings,\n  AnimationController? transitionAnimationController,\n  Offset? anchorPoint,\n  bool useSafeArea = false,\n}) {\n  assert(debugCheckHasMediaQuery(context));\n\n  final navigator = Navigator.of(context, rootNavigator: useRootNavigator);\n  final localizations = FLocalizations.of(context) ?? FDefaultLocalizations();\n  final dialogRouteStyle = routeStyle?.call(context.theme.dialogRouteStyle) ?? context.theme.dialogRouteStyle;\n  final dialogStyle = style?.call(context.theme.dialogStyle) ?? context.theme.dialogStyle;\n\n  return navigator.push(\n    FDialogRoute<T>(\n      style: dialogRouteStyle,\n      builder: (context, animation) => builder(context, dialogStyle, animation),\n      capturedThemes: InheritedTheme.capture(from: context, to: navigator.context),\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel ?? localizations.barrierLabel,\n      barrierOnTapHint: localizations.barrierOnTapHint(localizations.dialogSemanticsLabel),\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n      useSafeArea: useSafeArea,\n    ),\n  );\n}\n\n/// A route that shows a dialog popup.\n///\n/// [showFDialog] should be preferred in most cases.\nclass FDialogRoute<T> extends RawDialogRoute<T> {\n  /// The dialog route's style.\n  final FDialogRouteStyle style;\n\n  @override\n  final bool barrierDismissible;\n\n  @override\n  final String? barrierLabel;\n\n  /// The semantic hint text that informs users what will happen if they tap on the widget. Announced in the format of\n  /// 'Double tap to ...'.\n  final String? barrierOnTapHint;\n\n  /// Creates a [FDialogRoute].\n  FDialogRoute({\n    required this.style,\n    required Widget Function(BuildContext context, Animation<double> animation) builder,\n    this.barrierDismissible = true,\n    this.barrierLabel,\n    this.barrierOnTapHint,\n    CapturedThemes? capturedThemes,\n    bool useSafeArea = true,\n    super.settings,\n    super.requestFocus,\n    super.anchorPoint,\n    super.traversalEdgeBehavior,\n    super.directionalTraversalEdgeBehavior,\n  }) : super(\n         pageBuilder: (context, animation, secondaryAnimation) {\n           final child = Builder(builder: (context) => builder(context, animation));\n           Widget dialog = capturedThemes?.wrap(child) ?? child;\n           if (useSafeArea) {\n             dialog = SafeArea(child: dialog);\n           }\n           return dialog;\n         },\n       );\n\n  @override\n  Widget buildModalBarrier() {\n    if (style.barrierFilter != null && !offstage) {\n      return Builder(\n        builder: (context) => FAnimatedModalBarrier(\n          animation: animation!.drive(CurveTween(curve: barrierCurve)),\n          filter: style.barrierFilter,\n          onDismiss: barrierDismissible ? () => Navigator.pop(context) : null,\n          semanticsLabel: barrierLabel,\n          // changedInternalState is called if barrierLabel updates\n          barrierSemanticsDismissible: semanticsDismissible,\n          semanticsOnTapHint: barrierOnTapHint,\n        ),\n      );\n    } else {\n      return Builder(\n        builder: (context) => FModalBarrier(\n          filter: null,\n          onDismiss: barrierDismissible ? () => Navigator.pop(context) : null,\n          semanticsLabel: barrierLabel,\n          // changedInternalState is called if barrierLabel updates\n          barrierSemanticsDismissible: semanticsDismissible,\n          semanticsOnTapHint: barrierOnTapHint,\n        ),\n      );\n    }\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) => child;\n\n  @override\n  Color? get barrierColor => Colors.transparent;\n\n  @override\n  Curve get barrierCurve => style.motion.barrierCurve;\n\n  @override\n  Duration get transitionDuration => style.motion.entranceDuration;\n\n  @override\n  Duration get reverseTransitionDuration => style.motion.exitDuration;\n}\n\n/// [FDialogRoute]'s style.\nclass FDialogRouteStyle with Diagnosticable, _$FDialogRouteStyleFunctions {\n  /// {@macro forui.widgets.FPopoverStyle.barrierFilter}\n  @override\n  final ImageFilter Function(double animation)? barrierFilter;\n\n  /// Motion-related properties.\n  @override\n  final FDialogRouteMotion motion;\n\n  /// Creates a [FDialogRouteStyle].\n  const FDialogRouteStyle({this.barrierFilter, this.motion = const FDialogRouteMotion()});\n\n  /// Creates a [FDialogRouteStyle] that inherits its properties.\n  FDialogRouteStyle.inherit({required FColors colors})\n    : this(\n        barrierFilter: (v) => ColorFilter.mode(Color.lerp(Colors.transparent, colors.barrier, v)!, BlendMode.srcOver),\n      );\n}\n\n/// Motion-related properties for [FDialogRoute].\nclass FDialogRouteMotion with Diagnosticable, _$FDialogRouteMotionFunctions {\n  /// The amount of time the entrance animation takes. Defaults to 150ms.\n  ///\n  /// The dialog's animation and curve is managed by [FDialogMotion].\n  @override\n  final Duration entranceDuration;\n\n  /// The amount of time the exit animation takes. Defaults to 150ms.\n  ///\n  /// The dialog's animation and curve is managed by [FDialogMotion].\n  @override\n  final Duration exitDuration;\n\n  /// The curve used for the barrier's entrance and exit. Defaults to [Curves.ease].\n  @override\n  final Curve barrierCurve;\n\n  /// Creates a [FDialogRouteMotion].\n  const FDialogRouteMotion({\n    this.entranceDuration = const Duration(milliseconds: 150),\n    this.exitDuration = const Duration(milliseconds: 150),\n    this.barrierCurve = Curves.ease,\n  });\n}\n\n/// A modal dialog.\n///\n/// A dialog interrupts the user with important content and expects a response.\n///\n/// Consider using with\n/// * [showFDialog] if you want to show a dialog with consistent Shadcn/ui-like transitions across platforms.\n/// * [showAdaptiveDialog] if you want to show a dialog with transitions.\n///\n/// See:\n/// * https://forui.dev/docs/overlay/dialog for working examples.\n/// * [FDialogStyle] for customizing a dialog's appearance.\nclass FDialog extends StatefulWidget {\n  /// The dialog's style. Defaults to [FThemeData.dialogStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create dialog\n  /// ```\n  final FDialogStyle Function(FDialogStyle style)? style;\n\n  /// The animation used to animate the dialog's entrance and exit. Settings this to null will disable the animation.\n  ///\n  /// It is the responsibility of the caller to manage & dispose the given [animation].\n  ///\n  /// Defaults to null.\n  final Animation<double>? animation;\n\n  /// The semantic label of the dialog used by accessibility frameworks to announce screen transitions when the dialog\n  /// is opened and closed.\n  ///\n  /// See also:\n  ///  * [SemanticsConfiguration.namesRoute], for a description of how this value is used.\n  final String? semanticsLabel;\n\n  /// The dialog's box constraints. Defaults to `BoxConstraints(minWidth: 280, maxWidth: 560)`.\n  final BoxConstraints constraints;\n\n  /// The builder for the dialog's content.\n  final Widget Function(BuildContext context, FDialogStyle style) builder;\n\n  /// Creates a [FDialog] with a title, subtitle, and possible actions.\n  ///\n  /// The [semanticsLabel] defaults to [title] if it is not provided.\n  ///\n  /// The [direction] determines the layout of the actions. It is recommended to use [Axis.vertical] on smaller devices,\n  /// such as mobile phones, and [Axis.horizontal] on larger devices, such as tablets and desktops.\n  ///\n  /// The [Axis.vertical] layout with two possibles actions is:\n  /// ```diagram\n  /// |--------------------|\n  /// | [title]            |\n  /// |                    |\n  /// | [body]             |\n  /// |                    |\n  /// | [first action]     |\n  /// | [second action]    |\n  /// |--------------------|\n  /// ```\n  ///\n  /// The [Axis.horizontal] layout with two possibles actions is:\n  /// ```diagram\n  /// |--------------------------------------------|\n  /// | [title]                                    |\n  /// |                                            |\n  /// | [body]                                     |\n  /// |                                            |\n  /// |             [first action] [second action] |\n  /// |--------------------------------------------|\n  FDialog({\n    required List<Widget> actions,\n    this.style,\n    this.animation,\n    this.semanticsLabel,\n    this.constraints = const BoxConstraints(minWidth: 280, maxWidth: 560),\n    Widget? title,\n    Widget? body,\n    Axis direction = Axis.vertical,\n    super.key,\n  }) : builder = switch (direction) {\n         Axis.horizontal => (_, style) => HorizontalContent(\n           style: style.horizontalStyle,\n           title: title,\n           body: body,\n           actions: actions,\n         ),\n         Axis.vertical => (_, style) => VerticalContent(\n           style: style.verticalStyle,\n           title: title,\n           body: body,\n           actions: actions,\n         ),\n       };\n\n  /// Creates a adaptive [FDialog] that lays out the [actions] vertically on [FBreakpoints.sm] devices and\n  /// horizontally on larger devices.\n  FDialog.adaptive({\n    required List<Widget> actions,\n    this.style,\n    this.animation,\n    this.semanticsLabel,\n    this.constraints = const BoxConstraints(minWidth: 280, maxWidth: 560),\n    Widget? title,\n    Widget? body,\n    super.key,\n  }) : builder = ((context, style) => switch (MediaQuery.sizeOf(context).width) {\n         final width when width < context.theme.breakpoints.sm => VerticalContent(\n           style: style.verticalStyle,\n           title: title,\n           body: body,\n           actions: actions,\n         ),\n         _ => HorizontalContent(style: style.horizontalStyle, title: title, body: body, actions: actions),\n       });\n\n  /// Creates a [FDialog] with a custom builder.\n  const FDialog.raw({\n    required this.builder,\n    this.style,\n    this.animation,\n    this.semanticsLabel,\n    this.constraints = const BoxConstraints(minWidth: 280, maxWidth: 560),\n    super.key,\n  });\n\n  @override\n  State<FDialog> createState() => _FDialogState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('animation', animation))\n      ..add(StringProperty('semanticsLabel', semanticsLabel))\n      ..add(DiagnosticsProperty('constraints', constraints))\n      ..add(ObjectFlagProperty.has('builder', builder));\n  }\n}\n\nclass _FDialogState extends State<FDialog> {\n  CurvedAnimation? _curvedScale;\n  CurvedAnimation? _curvedFade;\n  Animation<double>? _scale;\n  Animation<double>? _fade;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final style = widget.style?.call(context.theme.dialogStyle) ?? context.theme.dialogStyle;\n\n    if (_curvedScale?.parent != widget.animation || _curvedFade?.parent != widget.animation) {\n      _curvedScale?.dispose();\n      _curvedFade?.dispose();\n\n      if (widget.animation case final animation?) {\n        _curvedScale = CurvedAnimation(\n          parent: animation,\n          curve: style.motion.expandCurve,\n          reverseCurve: style.motion.collapseCurve,\n        );\n        _curvedFade = CurvedAnimation(\n          parent: animation,\n          curve: style.motion.fadeInCurve,\n          reverseCurve: style.motion.fadeOutCurve,\n        );\n        _scale = style.motion.scaleTween.animate(_curvedScale!);\n        _fade = style.motion.fadeTween.animate(_curvedFade!);\n      } else {\n        _curvedScale = null;\n        _curvedFade = null;\n        _scale = null;\n        _fade = null;\n      }\n    }\n  }\n\n  @override\n  void dispose() {\n    _curvedFade?.dispose();\n    _curvedScale?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final theme = context.theme;\n    final style = widget.style?.call(context.theme.dialogStyle) ?? context.theme.dialogStyle;\n    final direction = Directionality.maybeOf(context) ?? TextDirection.ltr;\n\n    Widget dialog = DecoratedBox(decoration: style.decoration, child: widget.builder(context, style));\n\n    // We cannot handle the transition in [FDialogRoute] because of https://github.com/flutter/flutter/issues/31706.\n    if (_fade case final fade?) {\n      dialog = FadeTransition(opacity: fade, child: dialog);\n    }\n\n    if (style.backgroundFilter case final filter?) {\n      dialog = Stack(\n        children: [\n          Positioned.fill(\n            child: ClipRect(\n              child: _fade == null\n                  ? BackdropFilter(filter: filter(1), child: Container())\n                  : AnimatedBuilder(\n                      animation: _fade!,\n                      builder: (_, _) => BackdropFilter(filter: filter(_fade!.value), child: Container()),\n                    ),\n            ),\n          ),\n          dialog,\n        ],\n      );\n    }\n\n    // We want to scale the dialog, including the background filter.\n    if (_scale case final scale?) {\n      dialog = ScaleTransition(scale: scale, child: dialog);\n    }\n\n    return AnimatedPadding(\n      padding: MediaQuery.viewInsetsOf(context) + style.insetPadding.resolve(direction),\n      duration: style.motion.insetDuration,\n      curve: style.motion.insetCurve,\n      child: MediaQuery.removeViewInsets(\n        removeLeft: true,\n        removeTop: true,\n        removeRight: true,\n        removeBottom: true,\n        context: context,\n        child: Align(\n          child: DefaultTextStyle(\n            style: context.theme.typography.base.copyWith(color: theme.colors.foreground),\n            child: Semantics(\n              scopesRoute: true,\n              explicitChildNodes: true,\n              namesRoute: true,\n              label: widget.semanticsLabel,\n              child: ConstrainedBox(constraints: widget.constraints, child: dialog),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// [FDialog]'s style.\nclass FDialogStyle with Diagnosticable, _$FDialogStyleFunctions {\n  /// {@macro forui.widgets.FPopoverStyle.backgroundFilter}\n  ///\n  /// This requires [FDialog.animation] to be non-null.\n  @override\n  final ImageFilter Function(double animation)? backgroundFilter;\n\n  /// The decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// The inset padding. Defaults to `EdgeInsets.symmetric(horizontal: 40, vertical: 24)`.\n  @override\n  final EdgeInsetsGeometry insetPadding;\n\n  /// The horizontal dialog content's style.\n  @override\n  final FDialogContentStyle horizontalStyle;\n\n  /// The vertical dialog content's style.\n  @override\n  final FDialogContentStyle verticalStyle;\n\n  /// Motion-related properties.\n  @override\n  final FDialogMotion motion;\n\n  /// Creates a [FDialogStyle].\n  FDialogStyle({\n    required this.decoration,\n    required this.horizontalStyle,\n    required this.verticalStyle,\n    this.backgroundFilter,\n    this.insetPadding = const EdgeInsets.symmetric(horizontal: 40, vertical: 24),\n    this.motion = const FDialogMotion(),\n  });\n\n  /// Creates a [FDialogStyle] that inherits its properties.\n  factory FDialogStyle.inherit({required FStyle style, required FColors colors, required FTypography typography}) {\n    final title = typography.lg.copyWith(fontWeight: FontWeight.w600, color: colors.foreground);\n    final body = typography.sm.copyWith(color: colors.mutedForeground);\n    return FDialogStyle(\n      decoration: BoxDecoration(borderRadius: style.borderRadius, color: colors.background),\n      horizontalStyle: FDialogContentStyle(\n        titleTextStyle: title,\n        bodyTextStyle: body,\n        padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 25),\n        actionSpacing: 7,\n      ),\n      verticalStyle: FDialogContentStyle(\n        titleTextStyle: title,\n        bodyTextStyle: body,\n        padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 25),\n        actionSpacing: 8,\n      ),\n    );\n  }\n}\n\n/// Motion-related properties for [FDialog].\n///\n/// These fields are only used when [FDialog.animation] is non-null.\n///\n/// The actual animation duration is controlled by the route used to display the dialog, such as [FDialogRoute]. When\n/// using [showFDialog], the duration can be customized via [FDialogRouteStyle.motion].\nclass FDialogMotion with Diagnosticable, _$FDialogMotionFunctions {\n  /// The curve used for the dialog's expansion animation when entering. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve expandCurve;\n\n  /// The curve used for the dialog's collapse animation when exiting. Defaults to [Curves.easeInCubic].\n  @override\n  final Curve collapseCurve;\n\n  /// The curve used for the dialog's fade-in animation when entering. Defaults to [Curves.linear].\n  @override\n  final Curve fadeInCurve;\n\n  /// The curve used for the dialog's fade-out animation when exiting. Defaults to [Curves.linear].\n  @override\n  final Curve fadeOutCurve;\n\n  /// The tween used to animate the dialog's scale in and out. Defaults to `[0.95, 1]`.\n  @override\n  final Animatable<double> scaleTween;\n\n  /// The tween used to animate the dialog's fade in and out. Defaults to `[0, 1]`.\n  @override\n  final Animatable<double> fadeTween;\n\n  /// The duration of the animation to show when the system keyboard intrudes into the space that the dialog is placed in.\n  /// Defaults to 100ms.\n  @override\n  final Duration insetDuration;\n\n  /// The curve to use for the animation shown when the system keyboard intrudes into the space that the dialog is\n  /// placed in. Defaults to [Curves.decelerate].\n  @override\n  final Curve insetCurve;\n\n  /// Creates a [FDialogMotion].\n  const FDialogMotion({\n    this.expandCurve = Curves.easeOutCubic,\n    this.collapseCurve = Curves.easeInCubic,\n    this.fadeInCurve = Curves.linear,\n    this.fadeOutCurve = Curves.linear,\n    this.scaleTween = const FImmutableTween(begin: 0.95, end: 1.0),\n    this.fadeTween = const FImmutableTween(begin: 0.0, end: 1.0),\n    this.insetDuration = const Duration(milliseconds: 100),\n    this.insetCurve = Curves.decelerate,\n  });\n}\n",
      "dialog_content": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'dialog_content.design.dart';\n\n@internal\nsealed class Content extends StatelessWidget {\n  final FDialogContentStyle style;\n  final CrossAxisAlignment alignment;\n  final Widget? title;\n  final TextAlign titleTextAlign;\n  final Widget? body;\n  final TextAlign bodyTextAlign;\n  final List<Widget> actions;\n\n  const Content({\n    required this.style,\n    required this.alignment,\n    required this.title,\n    required this.titleTextAlign,\n    required this.body,\n    required this.bodyTextAlign,\n    required this.actions,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) => Padding(\n    padding: style.padding,\n    child: Column(\n      mainAxisSize: MainAxisSize.min,\n      crossAxisAlignment: alignment,\n      children: [\n        if (title case final title?)\n          Padding(\n            padding: const EdgeInsets.only(bottom: 4),\n            child: Semantics(\n              container: true,\n              child: DefaultTextStyle.merge(textAlign: titleTextAlign, style: style.titleTextStyle, child: title),\n            ),\n          ),\n        if (body case final body?)\n          Flexible(\n            child: Padding(\n              padding: const EdgeInsets.only(bottom: 4),\n              child: Semantics(\n                container: true,\n                child: DefaultTextStyle.merge(textAlign: bodyTextAlign, style: style.bodyTextStyle, child: body),\n              ),\n            ),\n          ),\n        if (title != null && body != null) const SizedBox(height: 8),\n        _actions(context),\n      ],\n    ),\n  );\n\n  Widget _actions(BuildContext context);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(EnumProperty('alignment', alignment))\n      ..add(EnumProperty('titleTextAlign', titleTextAlign))\n      ..add(EnumProperty('bodyTextAlign', bodyTextAlign))\n      ..add(IterableProperty('actions', actions));\n  }\n}\n\n@internal\nclass HorizontalContent extends Content {\n  const HorizontalContent({\n    required super.style,\n    required super.title,\n    required super.body,\n    required super.actions,\n    super.key,\n  }) : super(alignment: CrossAxisAlignment.start, titleTextAlign: TextAlign.start, bodyTextAlign: TextAlign.start);\n\n  @override\n  Widget _actions(BuildContext context) =>\n      Row(mainAxisAlignment: MainAxisAlignment.end, spacing: style.actionSpacing, children: actions);\n}\n\n@internal\nclass VerticalContent extends Content {\n  const VerticalContent({\n    required super.style,\n    required super.title,\n    required super.body,\n    required super.actions,\n    super.key,\n  }) : super(alignment: CrossAxisAlignment.center, titleTextAlign: TextAlign.center, bodyTextAlign: TextAlign.center);\n\n  @override\n  Widget _actions(BuildContext context) =>\n      Column(mainAxisSize: MainAxisSize.min, spacing: style.actionSpacing, children: actions);\n}\n\n/// [FDialog] content's style.\nclass FDialogContentStyle with Diagnosticable, _$FDialogContentStyleFunctions {\n  /// The title's [TextStyle].\n  @override\n  final TextStyle titleTextStyle;\n\n  /// The body's [TextStyle].\n  @override\n  final TextStyle bodyTextStyle;\n\n  /// The padding surrounding the content.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The space between actions.\n  @override\n  final double actionSpacing;\n\n  /// Creates a [FDialogContentStyle].\n  FDialogContentStyle({\n    required this.titleTextStyle,\n    required this.bodyTextStyle,\n    required this.padding,\n    required this.actionSpacing,\n  });\n}\n"
    },
    "Header": {
      "header": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\nimport 'package:forui/src/foundation/rendering.dart';\n\npart 'header.design.dart';\n\npart 'header_action.dart';\n\npart 'root_header.dart';\n\npart 'nested_header.dart';\n\n/// A header contains the page's title and actions.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/header for working examples.\n/// * [FHeaderStyle] for customizing a header's appearance.\nsealed class FHeader extends StatelessWidget {\n  /// The title.\n  final Widget title;\n\n  const FHeader._({this.title = const SizedBox(), super.key});\n\n  /// Creates a header whose title is aligned to the start.\n  ///\n  /// It is typically used on pages at the root of the navigation stack.\n  ///\n  /// ## CLI\n  /// To generate and customize this widget's style:\n  ///\n  /// ```shell\n  /// dart run forui style create headers\n  /// ```\n  const factory FHeader({\n    Widget title,\n    FHeaderStyle Function(FHeaderStyle style)? style,\n    List<Widget> suffixes,\n    Key? key,\n  }) = _FRootHeader;\n\n  /// Creates a nested header whose title is aligned to the center.\n  ///\n  /// It is typically used on pages NOT at the root of the navigation stack.\n  ///\n  /// ## CLI\n  /// To generate and customize this widget's style:\n  ///\n  /// ```shell\n  /// dart run forui style create headers\n  /// ```\n  const factory FHeader.nested({\n    Widget title,\n    AlignmentGeometry titleAlignment,\n    FHeaderStyle Function(FHeaderStyle style)? style,\n    List<Widget> prefixes,\n    List<Widget> suffixes,\n    Key? key,\n  }) = _FNestedHeader;\n}\n\n/// A header's data.\nclass FHeaderData extends InheritedWidget {\n  /// Returns the [FHeaderData] of the [FHeader] in the given [context].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if there is no ancestor [FHeader] in the given [context].\n  @useResult\n  static FHeaderData of(BuildContext context) {\n    assert(debugCheckHasAncestor<FHeaderData>('$FHeader', context));\n    return context.dependOnInheritedWidgetOfExactType<FHeaderData>()!;\n  }\n\n  /// The action's style.\n  final FHeaderActionStyle actionStyle;\n\n  /// Creates a [FHeaderData].\n  const FHeaderData({required this.actionStyle, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(FHeaderData oldWidget) => actionStyle != oldWidget.actionStyle;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('actionStyle', actionStyle));\n  }\n}\n\n/// [FHeader]'s styles.\nclass FHeaderStyles with Diagnosticable, _$FHeaderStylesFunctions {\n  /// The root header's style.\n  @override\n  final FHeaderStyle rootStyle;\n\n  /// The nested header's style.\n  @override\n  final FHeaderStyle nestedStyle;\n\n  /// Creates a [FHeaderStyles].\n  const FHeaderStyles({required this.rootStyle, required this.nestedStyle});\n\n  /// Creates a [FHeaderStyles] that inherits its properties.\n  FHeaderStyles.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : rootStyle = FHeaderStyle(\n        systemOverlayStyle: colors.systemOverlayStyle,\n        titleTextStyle: typography.xl3.copyWith(color: colors.foreground, fontWeight: FontWeight.w700, height: 1),\n        actionStyle: FHeaderActionStyle.inherit(colors: colors, style: style, size: 30),\n        padding: style.pagePadding.copyWith(bottom: 15),\n      ),\n      nestedStyle = FHeaderStyle(\n        systemOverlayStyle: colors.systemOverlayStyle,\n        titleTextStyle: typography.xl.copyWith(color: colors.foreground, fontWeight: FontWeight.w600, height: 1),\n        actionStyle: FHeaderActionStyle.inherit(colors: colors, style: style, size: 25),\n        padding: style.pagePadding.copyWith(bottom: 15),\n      );\n}\n\n/// A header's style.\nclass FHeaderStyle with Diagnosticable, _$FHeaderStyleFunctions {\n  /// The system overlay style.\n  @override\n  final SystemUiOverlayStyle systemOverlayStyle;\n\n  /// The decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// An optional background filter. This only takes effect if the [decoration] has a transparent or translucent\n  /// background color.\n  ///\n  /// This is typically combined with a transparent/translucent background to create a glassmorphic effect.\n  ///\n  /// ## Examples\n  /// ```dart\n  /// // Blurred\n  /// ImageFilter.blur(sigmaX: 5, sigmaY: 5);\n  ///\n  /// // Solid color\n  /// ColorFilter.mode(Colors.white, BlendMode.srcOver);\n  ///\n  /// // Tinted\n  /// ColorFilter.mode(Colors.white.withValues(alpha: 0.5), BlendMode.srcOver);\n  ///\n  /// // Blurred & tinted\n  /// ImageFilter.compose(\n  ///   outer: ImageFilter.blur(sigmaX: 5, sigmaY: 5),\n  ///   inner: ColorFilter.mode(Colors.white.withValues(alpha: 0.5), BlendMode.srcOver),\n  /// );\n  /// ```\n  @override\n  final ImageFilter? backgroundFilter;\n\n  /// The padding.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The spacing between [FHeaderAction]s. Defaults to 10.\n  @override\n  final double actionSpacing;\n\n  /// The title's [TextStyle].\n  @override\n  final TextStyle titleTextStyle;\n\n  /// The [FHeaderAction]s' style.\n  @override\n  final FHeaderActionStyle actionStyle;\n\n  /// Creates a [FHeaderStyle].\n  const FHeaderStyle({\n    required this.systemOverlayStyle,\n    required this.titleTextStyle,\n    required this.actionStyle,\n    required this.padding,\n    this.decoration = const BoxDecoration(),\n    this.backgroundFilter,\n    this.actionSpacing = 10,\n  });\n}\n",
      "header_action": "part of 'header.dart';\n\n/// A [FHeader] action.\n///\n/// If the [onPress] and [onLongPress] callbacks are null, then this action will be disabled, it will not react to touch.\nclass FHeaderAction extends StatelessWidget {\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create header-action\n  /// ```\n  final FHeaderActionStyle? style;\n\n  /// {@macro forui.foundation.doc_templates.semanticsLabel}\n  final String? semanticsLabel;\n\n  /// The icon, wrapped in a [IconThemeData].\n  final Widget icon;\n\n  /// True if this action is currently selected. Defaults to false.\n  final bool selected;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// {@macro forui.foundation.FTappable.onHoverChange}\n  final ValueChanged<bool>? onHoverChange;\n\n  /// {@macro forui.foundation.FTappable.onStateChange}\n  final ValueChanged<FWidgetStatesDelta>? onStateChange;\n\n  /// {@macro forui.foundation.FTappable.onPress}\n  final VoidCallback? onPress;\n\n  /// {@macro forui.foundation.FTappable.onLongPress}\n  final VoidCallback? onLongPress;\n\n  /// {@macro forui.foundation.FTappable.onSecondaryPress}\n  final VoidCallback? onSecondaryPress;\n\n  /// {@macro forui.foundation.FTappable.onSecondaryLongPress}\n  final VoidCallback? onSecondaryLongPress;\n\n  /// {@macro forui.foundation.FTappable.shortcuts}\n  final Map<ShortcutActivator, Intent>? shortcuts;\n\n  /// {@macro forui.foundation.FTappable.actions}\n  final Map<Type, Action<Intent>>? actions;\n\n  /// Creates a [FHeaderAction] from the given SVG [icon].\n  const FHeaderAction({\n    required this.icon,\n    required this.onPress,\n    this.style,\n    this.semanticsLabel,\n    this.selected = false,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.shortcuts,\n    this.actions,\n    super.key,\n  });\n\n  /// Creates a [FHeaderAction] with `FIcons.arrowLeft`.\n  factory FHeaderAction.back({\n    required VoidCallback? onPress,\n    FHeaderActionStyle? style,\n    String? semanticsLabel,\n    bool autofocus = false,\n    FocusNode? focusNode,\n    ValueChanged<bool>? onFocusChange,\n    ValueChanged<bool>? onHoverChange,\n    ValueChanged<FWidgetStatesDelta>? onStateChange,\n    VoidCallback? onLongPress,\n    VoidCallback? onSecondaryPress,\n    VoidCallback? onSecondaryLongPress,\n    Map<ShortcutActivator, Intent>? shortcuts,\n    Map<Type, Action<Intent>>? actions,\n    Key? key,\n  }) => FHeaderAction(\n    icon: const Icon(FIcons.arrowLeft),\n    onPress: onPress,\n    style: style,\n    semanticsLabel: semanticsLabel,\n    autofocus: autofocus,\n    focusNode: focusNode,\n    onFocusChange: onFocusChange,\n    onHoverChange: onHoverChange,\n    onStateChange: onStateChange,\n    onLongPress: onLongPress,\n    onSecondaryPress: onSecondaryPress,\n    onSecondaryLongPress: onSecondaryLongPress,\n    shortcuts: shortcuts,\n    actions: actions,\n    key: key,\n  );\n\n  /// Creates a [FHeaderAction] with `FIcons.x`.\n  factory FHeaderAction.x({\n    required VoidCallback? onPress,\n    FHeaderActionStyle? style,\n    bool autofocus = false,\n    FocusNode? focusNode,\n    ValueChanged<bool>? onFocusChange,\n    ValueChanged<bool>? onHoverChange,\n    ValueChanged<FWidgetStatesDelta>? onStateChange,\n    VoidCallback? onLongPress,\n    VoidCallback? onSecondaryPress,\n    VoidCallback? onSecondaryLongPress,\n    Map<ShortcutActivator, Intent>? shortcuts,\n    Map<Type, Action<Intent>>? actions,\n    Key? key,\n  }) => FHeaderAction(\n    icon: const Icon(FIcons.x),\n    onPress: onPress,\n    style: style,\n    autofocus: autofocus,\n    focusNode: focusNode,\n    onFocusChange: onFocusChange,\n    onHoverChange: onHoverChange,\n    onStateChange: onStateChange,\n    onLongPress: onLongPress,\n    onSecondaryPress: onSecondaryPress,\n    onSecondaryLongPress: onSecondaryLongPress,\n    shortcuts: shortcuts,\n    actions: actions,\n    key: key,\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    final style = this.style ?? FHeaderData.of(context).actionStyle;\n    return FTappable(\n      style: style.tappableStyle,\n      autofocus: autofocus,\n      focusNode: focusNode,\n      onFocusChange: onFocusChange,\n      onHoverChange: onHoverChange,\n      onStateChange: onStateChange,\n      focusedOutlineStyle: style.focusedOutlineStyle,\n      semanticsLabel: semanticsLabel,\n      onPress: onPress,\n      onLongPress: onLongPress,\n      onSecondaryPress: onSecondaryPress,\n      onSecondaryLongPress: onSecondaryLongPress,\n      shortcuts: shortcuts,\n      actions: actions,\n      builder: (_, states, child) => IconTheme(data: style.iconStyle.resolve(states), child: child!),\n      child: icon,\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(StringProperty('semanticsLabel', semanticsLabel))\n      ..add(DiagnosticsProperty('icon', icon))\n      ..add(FlagProperty('selected', value: selected, ifTrue: 'selected'))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onStateChange', onStateChange))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(ObjectFlagProperty.has('onLongPress', onLongPress))\n      ..add(ObjectFlagProperty.has('onSecondaryPress', onSecondaryPress))\n      ..add(ObjectFlagProperty.has('onSecondaryLongPress', onSecondaryLongPress))\n      ..add(DiagnosticsProperty('shortcuts', shortcuts))\n      ..add(DiagnosticsProperty('actions', actions));\n  }\n}\n\n/// [FHeaderAction]'s style.\nclass FHeaderActionStyle with Diagnosticable, _$FHeaderActionStyleFunctions {\n  /// The icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.tappable}\n  @override\n  final FWidgetStateMap<IconThemeData> iconStyle;\n\n  /// The outline style when this action is focused.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// The tappable's style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// Creates a [FHeaderActionStyle].\n  FHeaderActionStyle({required this.iconStyle, required this.focusedOutlineStyle, required this.tappableStyle});\n\n  /// Creates a [FHeaderActionStyle] that inherits its properties.\n  FHeaderActionStyle.inherit({required FColors colors, required FStyle style, required double size})\n    : iconStyle = FWidgetStateMap({\n        WidgetState.disabled: IconThemeData(color: colors.disable(colors.foreground), size: size),\n        WidgetState.any: IconThemeData(color: colors.foreground, size: size),\n      }),\n      focusedOutlineStyle = style.focusedOutlineStyle,\n      tappableStyle = style.tappableStyle;\n}\n",
      "nested_header": "part of 'header.dart';\n\n/// A nested header.\n///\n/// A nested header contains the page's title and actions (including pop navigation).\n/// It is typically used on pages that are not at the root of the navigation stack.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/header for working examples.\n/// * [FHeaderStyle] for customizing a header's appearance.\nclass _FNestedHeader extends FHeader {\n  /// The style.\n  final FHeaderStyle Function(FHeaderStyle style)? style;\n\n  /// The actions, aligned to the left in LTR locales. Defaults to an empty list.\n  ///\n  /// They are aligned to the right in RTL locales.\n  final List<Widget> prefixes;\n\n  /// The actions, aligned to the right. Defaults to an empty list.\n  ///\n  /// They are aligned to the left in RTL locales.\n  final List<Widget> suffixes;\n\n  /// The title's alignment.\n  final AlignmentGeometry titleAlignment;\n\n  /// Creates a [_FNestedHeader].\n  const _FNestedHeader({\n    this.style,\n    this.prefixes = const [],\n    this.suffixes = const [],\n    this.titleAlignment = Alignment.center,\n    super.title = const SizedBox(),\n    super.key,\n  }) : super._();\n\n  @override\n  Widget build(BuildContext context) {\n    final style = this.style?.call(context.theme.headerStyles.nestedStyle) ?? context.theme.headerStyles.nestedStyle;\n    final alignment = titleAlignment.resolve(Directionality.maybeOf(context) ?? TextDirection.ltr);\n\n    Widget header = SafeArea(\n      bottom: false,\n      child: Semantics(\n        header: true,\n        child: DecoratedBox(\n          decoration: style.decoration,\n          child: Padding(\n            padding: style.padding,\n            child: FHeaderData(\n              actionStyle: style.actionStyle,\n              child: _NestedHeader(\n                alignment: alignment,\n                prefixes: Row(mainAxisSize: MainAxisSize.min, spacing: style.actionSpacing, children: prefixes),\n                title: Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 10.0),\n                  child: DefaultTextStyle.merge(\n                    overflow: TextOverflow.ellipsis,\n                    maxLines: 1,\n                    softWrap: false,\n                    style: style.titleTextStyle,\n                    textHeightBehavior: const TextHeightBehavior(\n                      applyHeightToFirstAscent: false,\n                      applyHeightToLastDescent: false,\n                    ),\n                    child: title,\n                  ),\n                ),\n                suffixes: Row(mainAxisSize: MainAxisSize.min, spacing: style.actionSpacing, children: suffixes),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n\n    if (style.backgroundFilter case final filter?) {\n      header = Stack(\n        children: [\n          Positioned.fill(\n            child: ClipRect(\n              child: BackdropFilter(filter: filter, child: Container()),\n            ),\n          ),\n          header,\n        ],\n      );\n    }\n\n    return AnnotatedRegion<SystemUiOverlayStyle>(value: style.systemOverlayStyle, child: header);\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('titleAlignment', titleAlignment));\n  }\n}\n\nclass _NestedHeader extends MultiChildRenderObjectWidget {\n  final Alignment alignment;\n\n  _NestedHeader({required this.alignment, required Widget prefixes, required Widget title, required Widget suffixes})\n    : super(children: [prefixes, title, suffixes]);\n\n  @override\n  RenderObject createRenderObject(BuildContext context) =>\n      _RenderNestedHeader(alignment: alignment, textDirection: Directionality.of(context));\n\n  @override\n  void updateRenderObject(BuildContext context, covariant _RenderNestedHeader renderObject) => renderObject\n    ..alignment = alignment\n    ..direction = Directionality.of(context);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('alignment', alignment));\n  }\n}\n\nclass _RenderNestedHeader extends RenderBox\n    with ContainerRenderObjectMixin<RenderBox, DefaultData>, RenderBoxContainerDefaultsMixin<RenderBox, DefaultData> {\n  Alignment _alignment;\n  TextDirection _direction;\n\n  _RenderNestedHeader({required Alignment alignment, required TextDirection textDirection})\n    : _alignment = alignment,\n      _direction = textDirection;\n\n  @override\n  void setupParentData(RenderBox child) => child.parentData = DefaultData();\n\n  @override\n  void performLayout() {\n    if (childCount == 0) {\n      size = constraints.smallest;\n      return;\n    }\n\n    final prefixes = firstChild!;\n    final title = childAfter(prefixes)!;\n    final suffixes = childAfter(title)!;\n\n    // We prioritize the prefixes and suffixes since they are interactive.\n    prefixes.layout(constraints, parentUsesSize: true);\n    suffixes.layout(constraints, parentUsesSize: true);\n    title.layout(\n      constraints.copyWith(maxWidth: constraints.maxWidth - prefixes.size.width - suffixes.size.width),\n      parentUsesSize: true,\n    );\n\n    final height = [title.size.height, prefixes.size.height, suffixes.size.height].reduce(max);\n    size = constraints.constrain(Size(constraints.maxWidth, height));\n\n    final (left, right) = _direction == TextDirection.ltr ? (prefixes, suffixes) : (suffixes, prefixes);\n    left.data.offset = Offset(0, (size.height - left.size.height) / 2);\n    right.data.offset = Offset(size.width - right.size.width, (size.height - right.size.height) / 2);\n\n    // Position title based on Alignment (-1 to 1) on each axis where 0 is center.\n    // Title x-axis is relative to the center of the NestedHeader container\n    final titleX = (size.width - title.size.width) / 2 * (alignment.x + 1);\n    final titleY = (size.height - title.size.height) * (alignment.y + 1) / 2;\n    title.data.offset = Offset(titleX.clamp(left.size.width, size.width - right.size.width - title.size.width), titleY);\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) => defaultPaint(context, offset);\n\n  @override\n  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) =>\n      defaultHitTestChildren(result, position: position);\n\n  Alignment get alignment => _alignment;\n\n  set alignment(Alignment value) {\n    if (_alignment == value) {\n      return;\n    }\n    _alignment = value;\n    markNeedsLayout();\n  }\n\n  TextDirection get direction => _direction;\n\n  set direction(TextDirection value) {\n    if (_direction == value) {\n      return;\n    }\n    _direction = value;\n    markNeedsLayout();\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('alignment', alignment))\n      ..add(EnumProperty('direction', direction));\n  }\n}\n",
      "root_header": "part of 'header.dart';\n\n/// A root header.\n///\n/// A root header contains the page's title and actions.\n/// It is typically used on pages at the root of the navigation stack.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/header for working examples.\nclass _FRootHeader extends FHeader {\n  /// The header's style.\n  final FHeaderStyle Function(FHeaderStyle style)? style;\n\n  /// The actions, aligned to the right in LTR locales. Defaults to an empty list.\n  ///\n  /// They are aligned to the left in RTL locales.\n  final List<Widget> suffixes;\n\n  /// Creates a [FHeader].\n  const _FRootHeader({this.style, this.suffixes = const [], super.title, super.key}) : super._();\n\n  @override\n  Widget build(BuildContext context) {\n    final style = this.style?.call(context.theme.headerStyles.rootStyle) ?? context.theme.headerStyles.rootStyle;\n    Widget header = SafeArea(\n      bottom: false,\n      child: Semantics(\n        header: true,\n        child: Padding(\n          padding: style.padding,\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceBetween,\n            children: [\n              Expanded(\n                child: DefaultTextStyle.merge(\n                  overflow: TextOverflow.ellipsis,\n                  maxLines: 1,\n                  softWrap: false,\n                  style: style.titleTextStyle,\n                  textHeightBehavior: const TextHeightBehavior(\n                    applyHeightToFirstAscent: false,\n                    applyHeightToLastDescent: false,\n                  ),\n                  child: title,\n                ),\n              ),\n              FHeaderData(\n                actionStyle: style.actionStyle,\n                child: Row(\n                  children: suffixes.expand((action) => [SizedBox(width: style.actionSpacing), action]).toList(),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n\n    if (style.backgroundFilter case final filter?) {\n      header = Stack(\n        children: [\n          Positioned.fill(\n            child: ClipRect(\n              child: BackdropFilter(filter: filter, child: Container()),\n            ),\n          ),\n          header,\n        ],\n      );\n    }\n\n    return AnnotatedRegion<SystemUiOverlayStyle>(value: style.systemOverlayStyle, child: header);\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n"
    },
    "Item": {
      "item": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/item/item_content.dart';\nimport 'package:forui/src/widgets/item/raw_item_content.dart';\n\npart 'item.design.dart';\n\n/// A marker interface which denotes that mixed-in widgets is an item.\nmixin FItemMixin on Widget {}\n\n/// An item that is typically used to group related information together.\n///\n/// ## Using [FItem] in a [FPopover] when wrapped in a [FItemGroup]\n/// When a [FPopover] is used inside an [FItemGroup], items inside the popover will inherit styling from the parent group.\n/// This happens because [FPopover]'s content shares the same `BuildContext` as its child, causing data inheritance\n/// that may lead to unexpected rendering issues.\n///\n/// To prevent this styling inheritance, wrap the popover in a [FInheritedItemData] with null data to reset the\n/// inherited data:\n/// ```dart\n/// FItemGroup(\n///   children: [\n///     FItem(title: Text('Item with popover')),\n///     FPopoverWrapperItem(\n///       popoverBuilder: (_, _) => FInheritedItemData(\n///         child: FItemGroup(\n///           children: [\n///             FItem(title: Text('Popover Item 1')),\n///             FItem(title: Text('Popover Item 2')),\n///           ],\n///         ),\n///       ),\n///       child: FButton(child: Text('Open Popover')),\n///     ),\n///   ],\n/// );\n/// ```\n///\n/// See:\n/// * https://forui.dev/docs/data/item for working examples.\n/// * [FTile] for a specialized item for touch devices.\n/// * [FItemStyle] for customizing an item's appearance.\nclass FItem extends StatelessWidget with FItemMixin {\n  /// The item's style. Defaults to [FItemData.style] if present.\n  ///\n  /// Provide a style to prevent inheritance from [FInheritedItemData].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create item\n  /// ```\n  final FItemStyle Function(FItemStyle style)? style;\n\n  /// Whether the item is enabled. Defaults to true.\n  final bool? enabled;\n\n  /// True if this item is currently selected. Defaults to false.\n  final bool selected;\n\n  /// {@macro forui.foundation.doc_templates.semanticsLabel}\n  final String? semanticsLabel;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// {@macro forui.foundation.FTappable.onHoverChange}\n  final ValueChanged<bool>? onHoverChange;\n\n  /// {@macro forui.foundation.FTappable.onStateChange}\n  final ValueChanged<FWidgetStatesDelta>? onStateChange;\n\n  /// A callback for when the item is pressed.\n  ///\n  /// The item is not interactable if the following are all null:\n  /// * [onPress]\n  /// * [onLongPress]\n  /// * [onSecondaryPress]\n  /// * [onSecondaryLongPress]\n  final VoidCallback? onPress;\n\n  /// A callback for when the item is long pressed.\n  ///\n  /// The item is not interactable if the following are all null:\n  /// * [onPress]\n  /// * [onLongPress]\n  /// * [onSecondaryPress]\n  /// * [onSecondaryLongPress]\n  final VoidCallback? onLongPress;\n\n  /// A callback for when the widget is pressed with a secondary button (usually right-click on desktop).\n  ///\n  /// The item is not interactable if the following are all null:\n  /// * [onPress]\n  /// * [onLongPress]\n  /// * [onSecondaryPress]\n  /// * [onSecondaryLongPress]\n  final VoidCallback? onSecondaryPress;\n\n  /// A callback for when the widget is pressed with a secondary button (usually right-click on desktop).\n  ///\n  /// The item is not interactable if the following are all null:\n  /// * [onPress]\n  /// * [onLongPress]\n  /// * [onSecondaryPress]\n  /// * [onSecondaryLongPress]\n  final VoidCallback? onSecondaryLongPress;\n\n  /// {@macro forui.foundation.FTappable.shortcuts}\n  final Map<ShortcutActivator, Intent>? shortcuts;\n\n  /// {@macro forui.foundation.FTappable.actions}\n  final Map<Type, Action<Intent>>? actions;\n\n  final Widget Function(\n    BuildContext context,\n    FItemStyle style,\n    double top,\n    double bottom,\n    Set<WidgetState> states,\n    FWidgetStateMap<Color>? color,\n    double? width,\n    FItemDivider divider,\n  )\n  _builder;\n\n  /// Creates a [FItem].\n  ///\n  /// Assuming LTR locale:\n  /// ```diagram\n  /// -----------------------------------------------------\n  /// | [prefix] [title]       [details] [suffix]         |\n  /// |          [subtitle]                               |\n  /// -----------------------------------------------------\n  /// ```\n  ///\n  /// The order is reversed for RTL locales.\n  ///\n  /// ## Overflow behavior\n  /// [FItem] has custom layout behavior to handle overflow of its content. If [details] is text, it is truncated,\n  /// else [title] and [subtitle] are truncated.\n  ///\n  /// ## Why isn't my [title] [subtitle], or [details] rendered?\n  /// Using widgets that try to fill the available space, such as [Expanded] or [FTextField], as [details] will cause\n  /// the [title] and [subtitle] to never be rendered.\n  ///\n  /// Use [FItem.raw] in these cases.\n  FItem({\n    required Widget title,\n    this.style,\n    this.enabled,\n    this.selected = false,\n    this.semanticsLabel,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.onPress,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.shortcuts,\n    this.actions,\n    Widget? prefix,\n    Widget? subtitle,\n    Widget? details,\n    Widget? suffix,\n    super.key,\n  }) : _builder = ((context, style, top, bottom, states, color, width, divider) => ItemContent(\n         style: style.contentStyle,\n         margin: style.margin,\n         top: top,\n         bottom: bottom,\n         states: states,\n         dividerColor: color,\n         dividerWidth: width,\n         dividerType: divider,\n         prefix: prefix,\n         title: title,\n         subtitle: subtitle,\n         details: details,\n         suffix: suffix,\n       ));\n\n  /// Creates a [FItem] without custom layout behavior.\n  ///\n  /// Assuming LTR locale:\n  /// ```diagram\n  /// ----------------------------------------\n  /// | [prefix] [child]                     |\n  /// ----------------------------------------\n  /// ```\n  ///\n  /// The order is reversed for RTL locales.\n  FItem.raw({\n    required Widget child,\n    this.style,\n    this.enabled,\n    this.selected = false,\n    this.semanticsLabel,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.onPress,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.shortcuts,\n    this.actions,\n    Widget? prefix,\n    super.key,\n  }) : _builder = ((context, style, top, bottom, states, color, width, divider) => RawItemContent(\n         style: style.rawItemContentStyle,\n         margin: style.margin,\n         top: top,\n         bottom: bottom,\n         states: states,\n         dividerColor: color,\n         dividerWidth: width,\n         dividerType: divider,\n         prefix: prefix,\n         child: child,\n       ));\n\n  @override\n  Widget build(BuildContext context) {\n    final data = FInheritedItemData.maybeOf(context) ?? const FItemData();\n    final inheritedStyle = data.style ?? context.theme.itemStyle;\n\n    final style = this.style?.call(inheritedStyle) ?? inheritedStyle;\n    final enabled = this.enabled ?? data.enabled;\n    final states = {if (!enabled) WidgetState.disabled};\n    final divider = data.divider;\n\n    // We increase the bottom margin to draw the divider.\n    final top = data.index == 0 ? data.spacing : 0.0;\n    final bottom = data.last ? data.spacing : 0.0;\n\n    var margin = style.margin.resolve(Directionality.maybeOf(context) ?? TextDirection.ltr);\n    margin = margin.copyWith(\n      top: margin.top + top,\n      bottom: margin.bottom + bottom + (divider == FItemDivider.none ? 0 : data.dividerWidth),\n    );\n\n    if (onPress == null && onLongPress == null && onSecondaryPress == null && onSecondaryLongPress == null) {\n      return ColoredBox(\n        color: style.backgroundColor.resolve(states) ?? Colors.transparent,\n        child: Padding(\n          padding: margin,\n          child: DecoratedBox(\n            decoration: style.decoration.resolve(states) ?? const BoxDecoration(),\n            child: _builder(context, style, top, bottom, states, data.dividerColor, data.dividerWidth, divider),\n          ),\n        ),\n      );\n    }\n\n    return ColoredBox(\n      color: style.backgroundColor.resolve(states) ?? Colors.transparent,\n      child: Padding(\n        padding: margin,\n        child: FTappable(\n          style: style.tappableStyle,\n          semanticsLabel: semanticsLabel,\n          autofocus: autofocus,\n          focusNode: focusNode,\n          onFocusChange: onFocusChange,\n          onHoverChange: onHoverChange,\n          onStateChange: onStateChange,\n          selected: selected,\n          onPress: enabled ? (onPress ?? () {}) : null,\n          onLongPress: enabled ? (onLongPress ?? () {}) : null,\n          onSecondaryPress: enabled ? (onSecondaryPress ?? () {}) : null,\n          onSecondaryLongPress: enabled ? (onSecondaryLongPress ?? () {}) : null,\n          shortcuts: shortcuts,\n          actions: actions,\n          builder: (context, states, _) => DecoratedBox(\n            position: DecorationPosition.foreground,\n            decoration: switch (style.focusedOutlineStyle) {\n              final outline? when states.contains(WidgetState.focused) => BoxDecoration(\n                border: Border.all(color: outline.color, width: outline.width),\n                borderRadius: outline.borderRadius,\n              ),\n              _ => const BoxDecoration(),\n            },\n            child: DecoratedBox(\n              decoration: style.decoration.maybeResolve(states) ?? const BoxDecoration(),\n              child: _builder(context, style, top, bottom, states, data.dividerColor, data.dividerWidth, divider),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(FlagProperty('selected', value: selected, ifTrue: 'selected'))\n      ..add(StringProperty('semanticsLabel', semanticsLabel))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onChange', onStateChange))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(ObjectFlagProperty.has('onLongPress', onLongPress))\n      ..add(ObjectFlagProperty.has('onSecondaryPress', onSecondaryPress))\n      ..add(ObjectFlagProperty.has('onSecondaryLongPress', onSecondaryLongPress))\n      ..add(DiagnosticsProperty('shortcuts', shortcuts))\n      ..add(DiagnosticsProperty('actions', actions));\n  }\n}\n\n/// A [FItem]'s style.\nclass FItemStyle with Diagnosticable, _$FItemStyleFunctions {\n  /// The item's background color.\n  ///\n  /// It is applied to the entire item, including [margin]. Since it is applied before [decoration] in the z-layer,\n  /// it is not visible if [decoration] has a background color.\n  ///\n  /// This is useful for setting a background color when [margin] is not zero.\n  ///\n  /// Supported states:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<Color?> backgroundColor;\n\n  /// The margin around the item, including the [decoration].\n  ///\n  /// Defaults to `const EdgeInsets.symmetric(vertical: 2, horizontal: 4)`.\n  @override\n  final EdgeInsetsGeometry margin;\n\n  /// The item's decoration.\n  ///\n  /// An [FItem] is considered tappable if [FItem.onPress] or [FItem.onLongPress] is not null.\n  ///\n  /// The supported states if the item is tappable:\n  /// * [WidgetState.focused]\n  /// * [WidgetState.hovered]\n  /// * [WidgetState.pressed]\n  /// * [WidgetState.disabled]\n  ///\n  /// The supported states if the item is untappable:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<BoxDecoration?> decoration;\n\n  /// The default item content's style.\n  @override\n  final FItemContentStyle contentStyle;\n\n  /// THe default raw item content's style.\n  @override\n  final FRawItemContentStyle rawItemContentStyle;\n\n  /// The tappable style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle? focusedOutlineStyle;\n\n  /// Creates a [FItemStyle].\n  FItemStyle({\n    required this.backgroundColor,\n    required this.decoration,\n    required this.contentStyle,\n    required this.rawItemContentStyle,\n    required this.tappableStyle,\n    required this.focusedOutlineStyle,\n    this.margin = const EdgeInsets.symmetric(vertical: 2, horizontal: 4),\n  });\n\n  /// Creates a [FTileGroupStyle] that inherits from the given arguments.\n  FItemStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        backgroundColor: FWidgetStateMap({\n          WidgetState.disabled: colors.disable(colors.secondary),\n          WidgetState.any: colors.background,\n        }),\n        decoration: FWidgetStateMap({\n          WidgetState.disabled: BoxDecoration(\n            color: colors.disable(colors.secondary),\n            borderRadius: style.borderRadius,\n          ),\n          WidgetState.hovered | WidgetState.pressed: BoxDecoration(\n            color: colors.secondary,\n            borderRadius: style.borderRadius,\n          ),\n          WidgetState.any: BoxDecoration(color: colors.background, borderRadius: style.borderRadius),\n        }),\n        contentStyle: FItemContentStyle.inherit(colors: colors, typography: typography),\n        rawItemContentStyle: FRawItemContentStyle.inherit(colors: colors, typography: typography),\n        tappableStyle: style.tappableStyle.copyWith(\n          motion: FTappableMotion.none,\n          pressedEnterDuration: Duration.zero,\n          pressedExitDuration: const Duration(milliseconds: 25),\n        ),\n        focusedOutlineStyle: style.focusedOutlineStyle,\n      );\n}\n",
      "item_content": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/item/render_item_content.dart';\n\npart 'item_content.design.dart';\n\n@internal\nclass ItemContent extends StatelessWidget {\n  final FItemContentStyle style;\n  final EdgeInsetsGeometry margin;\n  final double top;\n  final double bottom;\n  final Set<WidgetState> states;\n  final FWidgetStateMap<Color>? dividerColor;\n  final double? dividerWidth;\n  final FItemDivider dividerType;\n  final Widget? prefix;\n  final Widget title;\n  final Widget? subtitle;\n  final Widget? details;\n  final Widget? suffix;\n\n  const ItemContent({\n    required this.style,\n    required this.margin,\n    required this.bottom,\n    required this.top,\n    required this.states,\n    required this.dividerColor,\n    required this.dividerWidth,\n    required this.dividerType,\n    required this.title,\n    required this.prefix,\n    required this.subtitle,\n    required this.details,\n    required this.suffix,\n    super.key,\n  }) : assert(\n         (dividerColor != null && dividerWidth != null) || dividerType == FItemDivider.none,\n         'dividerColor and dividerWidth must be provided if dividerType is not FItemDivider.none. This is a bug unless '\n         \"you're creating your own custom item container.\",\n       );\n\n  @override\n  Widget build(BuildContext context) => ItemContentLayout(\n    margin: margin,\n    padding: style.padding,\n    top: top,\n    bottom: bottom,\n    dividerColor: dividerColor?.resolve(states),\n    dividerWidth: dividerWidth,\n    dividerType: dividerType,\n    children: [\n      if (prefix case final prefix?)\n        Padding(\n          padding: EdgeInsetsDirectional.only(end: style.prefixIconSpacing),\n          child: IconTheme(data: style.prefixIconStyle.resolve(states), child: prefix),\n        )\n      else\n        const SizedBox(),\n      Padding(\n        padding: EdgeInsetsDirectional.only(end: style.middleSpacing),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          mainAxisAlignment: MainAxisAlignment.center,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          spacing: style.titleSpacing,\n          children: [\n            DefaultTextStyle.merge(\n              style: style.titleTextStyle.resolve(states),\n              textHeightBehavior: const TextHeightBehavior(\n                applyHeightToFirstAscent: false,\n                applyHeightToLastDescent: false,\n              ),\n              overflow: TextOverflow.ellipsis,\n              child: title,\n            ),\n            if (subtitle case final subtitle?)\n              DefaultTextStyle.merge(\n                style: style.subtitleTextStyle.resolve(states),\n                textHeightBehavior: const TextHeightBehavior(\n                  applyHeightToFirstAscent: false,\n                  applyHeightToLastDescent: false,\n                ),\n                overflow: TextOverflow.ellipsis,\n                child: subtitle,\n              ),\n          ],\n        ),\n      ),\n      if (details case final details?)\n        DefaultTextStyle.merge(\n          style: style.detailsTextStyle.resolve(states),\n          textHeightBehavior: const TextHeightBehavior(\n            applyHeightToFirstAscent: false,\n            applyHeightToLastDescent: false,\n          ),\n          overflow: TextOverflow.ellipsis,\n          child: details,\n        )\n      else\n        const SizedBox(),\n      if (suffix case final suffixIcon?)\n        Padding(\n          padding: EdgeInsetsDirectional.only(start: style.suffixIconSpacing),\n          child: IconTheme(data: style.suffixIconStyle.resolve(states), child: suffixIcon),\n        )\n      else\n        const SizedBox(),\n    ],\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('margin', margin))\n      ..add(DoubleProperty('top', top))\n      ..add(DoubleProperty('bottom', bottom))\n      ..add(IterableProperty('states', states))\n      ..add(DiagnosticsProperty('dividerColor', dividerColor))\n      ..add(DoubleProperty('dividerWidth', dividerWidth))\n      ..add(DiagnosticsProperty('dividerType', dividerType));\n  }\n}\n\n/// An [FItem] content's style.\nclass FItemContentStyle with Diagnosticable, _$FItemContentStyleFunctions {\n  /// The content's padding. Defaults to `const EdgeInsetsDirectional.only(start: 11, top: 7.5, bottom: 7.5, end: 6)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The prefix icon style.\n  @override\n  final FWidgetStateMap<IconThemeData> prefixIconStyle;\n\n  /// The horizontal spacing between the prefix icon and title and the subtitle. Defaults to 10.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [prefixIconSpacing] is negative.\n  @override\n  final double prefixIconSpacing;\n\n  /// The title's text style.\n  @override\n  final FWidgetStateMap<TextStyle> titleTextStyle;\n\n  /// The vertical spacing between the title and the subtitle. Defaults to 4.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [titleSpacing] is negative.\n  @override\n  final double titleSpacing;\n\n  /// The subtitle's text style.\n  @override\n  final FWidgetStateMap<TextStyle> subtitleTextStyle;\n\n  /// The minimum horizontal spacing between the title, subtitle, combined, and the details. Defaults to 4.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [middleSpacing] is negative.\n  @override\n  final double middleSpacing;\n\n  /// The details text style.\n  @override\n  final FWidgetStateMap<TextStyle> detailsTextStyle;\n\n  /// The suffix icon style.\n  @override\n  final FWidgetStateMap<IconThemeData> suffixIconStyle;\n\n  /// The horizontal spacing between the details and suffix icon. Defaults to 10.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [suffixIconSpacing] is negative.\n  @override\n  final double suffixIconSpacing;\n\n  /// Creates a [FItemContentStyle].\n  FItemContentStyle({\n    required this.prefixIconStyle,\n    required this.titleTextStyle,\n    required this.subtitleTextStyle,\n    required this.detailsTextStyle,\n    required this.suffixIconStyle,\n    this.padding = const EdgeInsetsDirectional.only(start: 11, top: 7.5, bottom: 7.5, end: 6),\n    this.prefixIconSpacing = 10,\n    this.titleSpacing = 3,\n    this.middleSpacing = 4,\n    this.suffixIconSpacing = 5,\n  }) : assert(0 <= prefixIconSpacing, 'prefixIconSpacing ($prefixIconSpacing) must be >= 0'),\n       assert(0 <= titleSpacing, 'titleSpacing ($titleSpacing) must be >= 0'),\n       assert(0 <= middleSpacing, 'middleSpacing ($middleSpacing) must be >= 0'),\n       assert(0 <= suffixIconSpacing, 'suffixIconSpacing ($suffixIconSpacing) must be >= 0');\n\n  /// Creates a [FItemContentStyle] that inherits its properties.\n  FItemContentStyle.inherit({required FColors colors, required FTypography typography})\n    : this(\n        prefixIconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 15),\n          WidgetState.any: IconThemeData(color: colors.primary, size: 15),\n        }),\n        titleTextStyle: FWidgetStateMap({\n          WidgetState.disabled: typography.sm.copyWith(color: colors.disable(colors.primary)),\n          WidgetState.any: typography.sm,\n        }),\n        subtitleTextStyle: FWidgetStateMap({\n          WidgetState.disabled: typography.xs.copyWith(color: colors.disable(colors.mutedForeground)),\n          WidgetState.any: typography.xs.copyWith(color: colors.mutedForeground),\n        }),\n        detailsTextStyle: FWidgetStateMap({\n          WidgetState.disabled: typography.xs.copyWith(color: colors.disable(colors.mutedForeground)),\n          WidgetState.any: typography.xs.copyWith(color: colors.mutedForeground),\n        }),\n        suffixIconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: colors.disable(colors.mutedForeground), size: 15),\n          WidgetState.any: IconThemeData(color: colors.mutedForeground, size: 15),\n        }),\n      );\n}\n",
      "item_data": "import 'dart:math';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:forui/forui.dart';\n\n/// The divider between items in a group.\nenum FItemDivider {\n  /// Represents a divider that horizontally spans the entire item.\n  full,\n\n  /// Represents a divider that partially spans the item horizontally.\n  ///\n  /// An item is always responsible for the divider directly below it.\n  ///\n  /// For [FItem.new], the divider spans from the title's left edge to the item's right edge. It is always aligned to\n  /// the title of the item above the divider.\n  /// ```diagram\n  /// -----------------------------\n  /// | [prefix] [title]          | <- Item A\n  /// |          ---------------- |\n  /// | [title]                   | <- Item B\n  /// -----------------------------\n  /// ```\n  ///\n  /// For [FItem.raw], the divider spans from the child's left edge to the item's right edge. It is always aligned to\n  /// the child of the item above the divider.\n  /// ```diagram\n  /// -----------------------------\n  /// | [prefix] [child]          | <- Item A\n  /// |          ---------------- |\n  /// | [child]                   | <- Item B\n  /// -----------------------------\n  indented,\n\n  /// No divider between items.\n  none,\n}\n\n/// An [FInheritedItemData] is used to provide data about the item's position in the current nesting level, i.e. [FTileGroup].\n///\n/// Users that wish to create their own custom group should pass additional data to the children using a separate\n/// inherited widget.\nfinal class FInheritedItemData extends InheritedWidget {\n  /// Returns the [FItemData] in the given [context].\n  static FItemData? maybeOf(BuildContext context) =>\n      context.dependOnInheritedWidgetOfExactType<FInheritedItemData>()?.data;\n\n  /// The item's properties.\n  final FItemData? data;\n\n  /// Creates a [FInheritedItemData].\n  const FInheritedItemData({required super.child, this.data, super.key});\n\n  /// Creates a [FInheritedItemData] that merges the given fields with the current [FInheritedItemData].\n  static Widget merge({\n    required bool last,\n    required Widget child,\n    FItemStyle? style,\n    double? spacing,\n    FItemDivider? divider,\n    FWidgetStateMap<Color>? dividerColor,\n    double? dividerWidth,\n    bool? enabled,\n    int? index,\n  }) => Builder(\n    builder: (context) {\n      final parent = maybeOf(context);\n      final globalLast = last && (parent?.globalLast ?? true);\n\n      return FInheritedItemData(\n        data: FItemData(\n          style: style ?? parent?.style,\n          spacing: max(spacing ?? 0, parent?.spacing ?? 0),\n          dividerColor: dividerColor ?? parent?.dividerColor ?? FWidgetStateMap.all(Colors.transparent),\n          dividerWidth: dividerWidth ?? parent?.dividerWidth ?? 0,\n          divider: switch ((last, globalLast)) {\n            // The first/middle items of a group.\n            (false, false) => divider ?? FItemDivider.none,\n            // Last of a group which itself isn't the last.\n            // propagatedLast can only be false if parent?.last is false since last must always be true.\n            // Hence, parent!.divider can never be null.\n            (true, false) => parent!.divider,\n            // The last item in the last group.\n            (_, true) => FItemDivider.none,\n          },\n          enabled: enabled ?? parent?.enabled ?? true,\n          index: index ?? parent?.index ?? 0,\n          last: last,\n          globalLast: globalLast,\n        ),\n        child: child,\n      );\n    },\n  );\n\n  @override\n  bool updateShouldNotify(FInheritedItemData old) => data != old.data;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('data', data));\n  }\n}\n\n/// The item's data.\nfinal class FItemData with Diagnosticable {\n  /// The item's style.\n  final FItemStyle? style;\n\n  /// The vertical spacing at the top and bottom of each level.\n  final double spacing;\n\n  /// The divider's style.\n  final FWidgetStateMap<Color> dividerColor;\n\n  /// The divider's width.\n  final double dividerWidth;\n\n  /// The divider used to visually separate the different items.\n  final FItemDivider divider;\n\n  /// True if enabled.\n  final bool enabled;\n\n  /// The item's index in the current nesting level.\n  final int index;\n\n  /// True if the item is the last item in the current nesting level.\n  final bool last;\n\n  /// True if the item is the last item across all levels.\n  final bool globalLast;\n\n  /// Creates a new [FItemData].\n  const FItemData({\n    this.style,\n    this.spacing = 0,\n    this.dividerColor = const FWidgetStateMap({WidgetState.any: Colors.transparent}),\n    this.dividerWidth = 0,\n    this.divider = FItemDivider.none,\n    this.enabled = true,\n    this.index = 0,\n    this.last = true,\n    this.globalLast = true,\n  });\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DoubleProperty('spacing', spacing))\n      ..add(DiagnosticsProperty('dividerColor', dividerColor))\n      ..add(DoubleProperty('dividerWidth', dividerWidth))\n      ..add(EnumProperty('divider', divider))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(IntProperty('index', index))\n      ..add(FlagProperty('last', value: last, ifTrue: 'last'))\n      ..add(FlagProperty('globalLast', value: globalLast, ifTrue: 'globalLast'));\n  }\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is FItemData &&\n          runtimeType == other.runtimeType &&\n          style == other.style &&\n          spacing == other.spacing &&\n          dividerColor == other.dividerColor &&\n          dividerWidth == other.dividerWidth &&\n          divider == other.divider &&\n          enabled == other.enabled &&\n          index == other.index &&\n          last == other.last &&\n          globalLast == other.globalLast;\n\n  @override\n  int get hashCode =>\n      Object.hash(style, spacing, dividerColor, dividerWidth, divider, enabled, index, last, globalLast);\n}\n",
      "item_group": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'item_group.design.dart';\n\n/// A marker interface which denotes that mixed-in widgets can group items and be used in a [FItemGroup.merge].\nmixin FItemGroupMixin on Widget {}\n\n/// An item group that groups multiple [FItemMixin]s together.\n///\n/// Items grouped together will be separated by a divider, specified by [divider].\n///\n/// ## Using [FItemGroup] in a [FPopover] when wrapped in a [FItemGroup]\n/// When a [FPopover] is used inside an [FItemGroup], items & groups inside the popover will inherit styling from the\n/// parent group. This happens because [FPopover]'s content shares the same `BuildContext` as its child, causing data\n/// inheritance that may lead to unexpected rendering issues.\n///\n/// To prevent this styling inheritance, wrap the popover in a [FInheritedItemData] with null data to reset the\n/// inherited data:\n/// ```dart\n/// FItemGroup(\n///   children: [\n///     FItem(title: Text('Item with popover')),\n///     FPopoverWrapperItem(\n///       popoverBuilder: (_, _) => FInheritedItemData(\n///         child: FItemGroup(\n///           children: [\n///             FItem(title: Text('Popover Item 1')),\n///             FItem(title: Text('Popover Item 2')),\n///           ],\n///         ),\n///       ),\n///       child: FButton(child: Text('Open Popover')),\n///     ),\n///   ],\n/// );\n/// ```\n///\n///\n/// See:\n/// * https://forui.dev/docs/data/item-group for working examples.\n/// * [FItemGroupStyle] for customizing a item group's appearance.\nclass FItemGroup extends StatelessWidget with FItemGroupMixin {\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create item-group\n  /// ```\n  final FItemGroupStyle Function(FItemGroupStyle style)? style;\n\n  /// {@template forui.widgets.FItemGroup.scrollController}\n  /// The scroll controller used to control the position to which this group is scrolled.\n  ///\n  /// Scrolling past the end of the group using the controller will result in undefined behavior.\n  ///\n  /// It is ignored if the group is part of a merged [FItemGroup].\n  /// {@endtemplate}\n  final ScrollController? scrollController;\n\n  /// {@template forui.widgets.FItemGroup.cacheExtent}\n  /// The scrollable area's cache extent in logical pixels.\n  ///\n  /// Items that fall in this cache area are laid out even though they are not (yet) visible on screen. It describes\n  /// how many pixels the cache area extends before the leading edge and after the trailing edge of the viewport.\n  ///\n  /// It is ignored if the group is part of a merged [FItemGroup].\n  /// {@endtemplate}\n  final double? cacheExtent;\n\n  /// {@template forui.widgets.FItemGroup.maxHeight}\n  /// The max height, in logical pixels. Defaults to infinity.\n  ///\n  /// It is ignored if the group is part of a merged [FItemGroup].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [maxHeight] is not positive.\n  /// {@endtemplate}\n  final double maxHeight;\n\n  /// {@template forui.widgets.FItemGroup.dragStartBehavior}\n  /// Determines the way that drag start behavior is handled. Defaults to [DragStartBehavior.start].\n  ///\n  /// It is ignored if the group is part of a merged [FItemGroup].\n  /// {@endtemplate}\n  final DragStartBehavior dragStartBehavior;\n\n  /// {@template forui.widgets.FItemGroup.physics}\n  /// The scroll physics of the group. Defaults to [ClampingScrollPhysics].\n  /// {@endtemplate}\n  final ScrollPhysics physics;\n\n  /// {@template forui.widgets.FItemGroup.divider}\n  /// The divider between items.\n  /// {@endtemplate}\n  ///\n  /// Defaults to [FItemDivider.indented].\n  final FItemDivider divider;\n\n  /// True if the group is enabled. Defaults to true.\n  final bool? enabled;\n\n  /// The group's semantic label.\n  ///\n  /// It is ignored if the group is part of a merged [FItemGroup].\n  final String? semanticsLabel;\n\n  /// The delegate that builds the sliver children.\n  // ignore: avoid_positional_boolean_parameters\n  final Widget Function(FItemGroupStyle style, bool enabled) _builder;\n\n  /// Creates a [FItemGroup].\n  FItemGroup({\n    required List<FItemMixin> children,\n    this.style,\n    this.scrollController,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.enabled,\n    this.divider = FItemDivider.none,\n    this.semanticsLabel,\n    super.key,\n  }) : assert(0 < maxHeight, 'maxHeight ($maxHeight) must be > 0'),\n       _builder = ((style, enabled) => SliverList.list(\n         children: [\n           for (final (index, child) in children.indexed)\n             FInheritedItemData.merge(\n               style: style.itemStyle,\n               spacing: style.spacing,\n               enabled: enabled,\n               dividerColor: style.dividerColor,\n               dividerWidth: style.dividerWidth,\n               divider: divider,\n               index: index,\n               last: index == children.length - 1,\n               child: child,\n             ),\n         ],\n       ));\n\n  /// Creates a [FItemGroup] that lazily builds its children.\n  ///\n  /// {@template forui.widgets.FItemGroup.builder}\n  /// The [itemBuilder] is called for each item that should be built. The current level's [FInheritedItemData] is **not**\n  /// visible to `itemBuilder`.\n  /// * It may return null to signify the end of the group.\n  /// * It may be called more than once for the same index.\n  /// * It will be called only for indices <= [count] if [count] is given.\n  ///\n  /// The [count] is the number of items to build. If null, [itemBuilder] will be called until it returns null.\n  ///\n  /// ## Notes\n  /// May result in an infinite loop or run out of memory if:\n  /// * Placed in a parent widget that does not constrain its size, i.e. [Column].\n  /// * [count] is null and [itemBuilder] always provides a zero-size widget, i.e. SizedBox(). If possible, provide\n  ///   items with non-zero size, return null from builder, or set [count] to non-null.\n  /// {@endtemplate}\n  FItemGroup.builder({\n    required NullableIndexedWidgetBuilder itemBuilder,\n    int? count,\n    this.style,\n    this.scrollController,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.enabled,\n    this.divider = FItemDivider.none,\n    this.semanticsLabel,\n    super.key,\n  }) : assert(0 < maxHeight, 'maxHeight ($maxHeight) must be > 0'),\n       assert(count == null || 0 <= count, 'count ($count) must be >= 0'),\n       _builder = ((style, enabled) => SliverList.builder(\n         itemCount: count,\n         itemBuilder: (context, index) {\n           if (itemBuilder(context, index) case final item?) {\n             return FInheritedItemData.merge(\n               style: style.itemStyle,\n               spacing: style.spacing,\n               enabled: enabled,\n               dividerColor: style.dividerColor,\n               dividerWidth: style.dividerWidth,\n               divider: divider,\n               index: index,\n               last: (count != null && index == count - 1) || itemBuilder(context, index + 1) == null,\n               child: item,\n             );\n           }\n\n           return null;\n         },\n       ));\n\n  /// Creates a [FItemGroup] that merges multiple [FItemGroupMixin]s together.\n  ///\n  /// All group labels will be ignored.\n  FItemGroup.merge({\n    required List<FItemGroupMixin> children,\n    this.style,\n    this.scrollController,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.enabled,\n    this.divider = FItemDivider.full,\n    this.semanticsLabel,\n    super.key,\n  }) : assert(0 < maxHeight, 'maxHeight ($maxHeight) must be > 0'),\n       _builder = ((style, enabled) => SliverMainAxisGroup(\n         slivers: [\n           for (final (index, child) in children.indexed)\n             FInheritedItemData.merge(\n               style: style.itemStyle,\n               spacing: style.spacing,\n               enabled: enabled,\n               dividerColor: style.dividerColor,\n               dividerWidth: style.dividerWidth,\n               divider: divider,\n               index: index,\n               last: index == children.length - 1,\n               child: child,\n             ),\n         ],\n       ));\n\n  @override\n  Widget build(BuildContext context) {\n    final data = FInheritedItemData.maybeOf(context);\n    final inheritedStyle = FItemGroupStyleData.of(context);\n    final style = this.style?.call(inheritedStyle) ?? inheritedStyle;\n    final enabled = this.enabled ?? data?.enabled ?? true;\n\n    final sliver = _builder(style, enabled);\n    if (data != null) {\n      return sliver;\n    }\n\n    return Semantics(\n      container: true,\n      label: semanticsLabel,\n      child: ConstrainedBox(\n        constraints: BoxConstraints(maxHeight: maxHeight),\n        // We use a Container instead of DecoratedBox as using a DecoratedBox will cause the border to be clipped.\n        // ignore: use_decorated_box\n        child: Container(\n          decoration: style.decoration,\n          child: ClipRRect(\n            borderRadius:\n                style.decoration.borderRadius?.resolve(Directionality.maybeOf(context) ?? TextDirection.ltr) ??\n                BorderRadius.zero,\n            child: FItemGroupStyleData(\n              style: style,\n              child: CustomScrollView(\n                controller: scrollController,\n                cacheExtent: cacheExtent,\n                dragStartBehavior: dragStartBehavior,\n                shrinkWrap: true,\n                physics: physics,\n                slivers: [sliver],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('controller', scrollController))\n      ..add(DoubleProperty('cacheExtent', cacheExtent))\n      ..add(DoubleProperty('maxHeight', maxHeight))\n      ..add(EnumProperty('dragStartBehavior', dragStartBehavior))\n      ..add(DiagnosticsProperty('physics', physics))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(EnumProperty('divider', divider))\n      ..add(StringProperty('semanticsLabel', semanticsLabel));\n  }\n}\n\n/// An inherited widget that provides the [FItemGroupStyle] to its descendants.\nclass FItemGroupStyleData extends InheritedWidget {\n  /// Returns the [FItemGroupStyle] in the given [context], or null if none is found.\n  static FItemGroupStyle? maybeOf(BuildContext context) =>\n      context.dependOnInheritedWidgetOfExactType<FItemGroupStyleData>()?.style;\n\n  /// Returns the [FItemGroupStyle] in the given [context].\n  static FItemGroupStyle of(BuildContext context) =>\n      context.dependOnInheritedWidgetOfExactType<FItemGroupStyleData>()?.style ?? context.theme.itemGroupStyle;\n\n  /// The style of the group.\n  final FItemGroupStyle style;\n\n  /// Creates a [FItemGroupStyleData].\n  const FItemGroupStyleData({required this.style, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(FItemGroupStyleData old) => style != old.style;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// An [FItemGroup]'s style.\nclass FItemGroupStyle with Diagnosticable, _$FItemGroupStyleFunctions {\n  /// The group's decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// The vertical spacing at the top and bottom of each group. Defaults to 4.\n  @override\n  final double spacing;\n\n  /// The divider's style.\n  ///\n  /// Supported states:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<Color> dividerColor;\n\n  /// The divider's width.\n  @override\n  final double dividerWidth;\n\n  /// The item's style.\n  @override\n  final FItemStyle itemStyle;\n\n  /// Creates a [FItemGroupStyle].\n  FItemGroupStyle({\n    required this.dividerColor,\n    required this.dividerWidth,\n    required this.itemStyle,\n    this.decoration = const BoxDecoration(),\n    this.spacing = 4,\n  });\n\n  /// Creates a [FItemGroupStyle] that inherits from the given arguments.\n  FItemGroupStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        itemStyle: FItemStyle.inherit(colors: colors, typography: typography, style: style),\n        dividerColor: FWidgetStateMap.all(colors.border),\n        dividerWidth: style.borderWidth,\n      );\n}\n",
      "raw_item_content": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/item/render_item_content.dart';\n\npart 'raw_item_content.design.dart';\n\n@internal\nclass RawItemContent extends StatelessWidget {\n  final FRawItemContentStyle style;\n  final EdgeInsetsGeometry margin;\n\n  final double top;\n  final double bottom;\n  final Set<WidgetState> states;\n  final FWidgetStateMap<Color>? dividerColor;\n  final double? dividerWidth;\n  final FItemDivider dividerType;\n  final Widget? prefix;\n  final Widget child;\n\n  const RawItemContent({\n    required this.style,\n    required this.margin,\n    required this.bottom,\n    required this.top,\n    required this.states,\n    required this.dividerColor,\n    required this.dividerWidth,\n    required this.dividerType,\n    required this.prefix,\n    required this.child,\n    super.key,\n  }) : assert(\n         (dividerColor != null && dividerWidth != null) || dividerType == FItemDivider.none,\n         'dividerColor and dividerWidth must be provided if dividerType is not FItemDivider.none. This is a bug unless '\n         \"you're creating your own custom item container.\",\n       );\n\n  @override\n  Widget build(BuildContext context) => ItemContentLayout(\n    margin: margin,\n    padding: style.padding,\n    top: top,\n    bottom: bottom,\n    dividerColor: dividerColor?.resolve(states),\n    dividerWidth: dividerWidth,\n    dividerType: dividerType,\n    children: [\n      if (prefix case final prefix?)\n        Padding(\n          padding: EdgeInsetsDirectional.only(end: style.prefixIconSpacing),\n          child: IconTheme(data: style.prefixIconStyle.resolve(states), child: prefix),\n        )\n      else\n        const SizedBox(),\n      DefaultTextStyle.merge(\n        style: style.childTextStyle.resolve(states),\n        textHeightBehavior: const TextHeightBehavior(applyHeightToFirstAscent: false, applyHeightToLastDescent: false),\n        overflow: TextOverflow.ellipsis,\n        child: child,\n      ),\n      const SizedBox(),\n      const SizedBox(),\n    ],\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('margin', margin))\n      ..add(IterableProperty('states', states))\n      ..add(DoubleProperty('top', top))\n      ..add(DoubleProperty('bottom', bottom))\n      ..add(DiagnosticsProperty('dividerColor', dividerColor))\n      ..add(DoubleProperty('dividerWidth', dividerWidth))\n      ..add(DiagnosticsProperty('dividerType', dividerType));\n  }\n}\n\n/// An [FItem] raw content's style.\nclass FRawItemContentStyle with Diagnosticable, _$FRawItemContentStyleFunctions {\n  /// The content's padding. Defaults to `EdgeInsetsDirectional.only(15, 13, 10, 13)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The prefix icon style.\n  @override\n  final FWidgetStateMap<IconThemeData> prefixIconStyle;\n\n  /// The horizontal spacing between the prefix icon and child. Defaults to 10.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [prefixIconSpacing] is negative.\n  @override\n  final double prefixIconSpacing;\n\n  /// The child's text style.\n  @override\n  final FWidgetStateMap<TextStyle> childTextStyle;\n\n  /// Creates a [FRawItemContentStyle].\n  FRawItemContentStyle({\n    required this.prefixIconStyle,\n    required this.childTextStyle,\n    this.padding = const EdgeInsetsDirectional.only(start: 15, top: 7.5, bottom: 7.5, end: 10),\n    this.prefixIconSpacing = 10,\n  }) : assert(0 <= prefixIconSpacing, 'prefixIconSpacing ($prefixIconSpacing) must be >= 0');\n\n  /// Creates a [FRawItemContentStyle] that inherits its properties.\n  FRawItemContentStyle.inherit({required FColors colors, required FTypography typography})\n    : this(\n        prefixIconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 15),\n          WidgetState.any: IconThemeData(color: colors.primary, size: 15),\n        }),\n        childTextStyle: FWidgetStateMap({\n          WidgetState.disabled: typography.sm.copyWith(color: colors.disable(colors.primary)),\n          WidgetState.any: typography.sm,\n        }),\n      );\n}\n",
      "render_item_content": "import 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:collection/collection.dart';\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/rendering.dart';\n\n@internal\nclass ItemContentLayout extends MultiChildRenderObjectWidget {\n  final EdgeInsetsGeometry margin;\n  final EdgeInsetsGeometry padding;\n  final double top;\n  final double bottom;\n  final Color? dividerColor;\n  final double? dividerWidth;\n  final FItemDivider dividerType;\n\n  const ItemContentLayout({\n    required this.margin,\n    required this.padding,\n    required this.top,\n    required this.bottom,\n    required this.dividerColor,\n    required this.dividerWidth,\n    required this.dividerType,\n    super.children,\n    super.key,\n  });\n\n  @override\n  RenderObject createRenderObject(BuildContext context) {\n    final direction = Directionality.maybeOf(context) ?? TextDirection.ltr;\n    return _RenderItemContent(\n      margin.resolve(direction),\n      padding.resolve(direction),\n      top,\n      bottom,\n      dividerColor,\n      dividerWidth,\n      dividerType,\n      direction,\n    );\n  }\n\n  @override\n  // ignore: library_private_types_in_public_api\n  void updateRenderObject(BuildContext context, covariant _RenderItemContent content) {\n    final direction = Directionality.maybeOf(context) ?? TextDirection.ltr;\n    content\n      ..margin = margin.resolve(direction)\n      ..padding = padding.resolve(direction)\n      ..top = top\n      ..bottom = bottom\n      ..dividerColor = dividerColor\n      ..dividerWidth = dividerWidth\n      ..dividerType = dividerType\n      ..textDirection = direction;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('padding', padding))\n      ..add(DiagnosticsProperty('margin', margin))\n      ..add(DoubleProperty('top', top))\n      ..add(DoubleProperty('bottom', bottom))\n      ..add(ColorProperty('dividerColor', dividerColor))\n      ..add(DoubleProperty('dividerWidth', dividerWidth))\n      ..add(EnumProperty('dividerType', dividerType));\n  }\n}\n\nclass _RenderItemContent extends RenderBox\n    with ContainerRenderObjectMixin<RenderBox, DefaultData>, RenderBoxContainerDefaultsMixin<RenderBox, DefaultData> {\n  EdgeInsets _margin;\n  EdgeInsets _padding;\n  double _top;\n  double _bottom;\n  Color? _dividerColor;\n  double? _dividerWidth;\n  FItemDivider _dividerType;\n  TextDirection _textDirection;\n\n  _RenderItemContent(\n    this._margin,\n    this._padding,\n    this._top,\n    this._bottom,\n    this._dividerColor,\n    this._dividerWidth,\n    this._dividerType,\n    this._textDirection,\n  );\n\n  @override\n  void setupParentData(covariant RenderObject child) => child.parentData = DefaultData();\n\n  @override\n  void performLayout() {\n    final EdgeInsets(:left, :top, :right, :bottom) = _padding;\n    final prefix = firstChild!;\n    final column = childAfter(prefix)!;\n    final details = childAfter(column)!;\n    final suffix = childAfter(details)!;\n\n    // Layout children.\n    var contentConstraints = constraints.loosen().copyWith(maxWidth: constraints.maxWidth - left - right);\n\n    prefix.layout(contentConstraints, parentUsesSize: true);\n    contentConstraints = contentConstraints.copyWith(maxWidth: contentConstraints.maxWidth - prefix.size.width);\n\n    suffix.layout(contentConstraints, parentUsesSize: true);\n    contentConstraints = contentConstraints.copyWith(maxWidth: contentConstraints.maxWidth - suffix.size.width);\n\n    // Column takes priority if details is text, and vice-versa.\n    final (first, last) = details is RenderParagraph ? (column, details) : (details, column);\n\n    first.layout(contentConstraints, parentUsesSize: true);\n    contentConstraints = contentConstraints.copyWith(maxWidth: contentConstraints.maxWidth - first.size.width);\n    last.layout(contentConstraints, parentUsesSize: true);\n\n    final height = [prefix.size.height, suffix.size.height, column.size.height, details.size.height].max;\n    size = Size(constraints.maxWidth, height + top + bottom);\n\n    // Position children.\n    final (l, ml, mr, r) = _textDirection == TextDirection.ltr\n        ? (prefix, column, details, suffix)\n        : (suffix, details, column, prefix);\n\n    l.data.offset = Offset(left, top + (height - l.size.height) / 2);\n    ml.data.offset = Offset(left + l.size.width, top + (height - ml.size.height) / 2);\n    mr.data.offset = Offset(\n      constraints.maxWidth - right - r.size.width - mr.size.width,\n      top + (height - mr.size.height) / 2,\n    );\n    r.data.offset = Offset(constraints.maxWidth - right - r.size.width, top + (height - r.size.height) / 2);\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    defaultPaint(context, offset);\n    if (dividerType == FItemDivider.none) {\n      return;\n    }\n\n    final EdgeInsets(:left, :top, :right, :bottom) = _padding;\n    // The divider is offset by 0.5 instead of 1.0 due to some weird rendering bug/oddity where part of the line is\n    // clipped when rendered exactly on the edge. This is reproducible on an iOS simulator & in golden tests.\n    //\n    // The divider's width doesn't need to be added as it isn't reflected in _margin but is is reflected in the FItem's\n    // margin.\n    final y = offset.dy + size.height + _margin.bottom + _bottom + 0.5;\n\n    final paint = Paint()\n      ..isAntiAlias = false\n      ..color = _dividerColor!\n      ..strokeWidth = _dividerWidth!;\n\n    if (_dividerType == FItemDivider.indented) {\n      final prefix = firstChild!;\n      final spacing = _textDirection == TextDirection.ltr ? left : right;\n\n      if (_textDirection == TextDirection.ltr) {\n        context.canvas.drawLine(\n          Offset(offset.dx + spacing + prefix.size.width, y),\n          Offset(offset.dx + size.width + _margin.right, y),\n          paint,\n        );\n      } else {\n        context.canvas.drawLine(\n          Offset(offset.dx - _margin.left, y),\n          Offset(offset.dx + size.width - spacing - prefix.size.width, y),\n          paint,\n        );\n      }\n    } else {\n      context.canvas.drawLine(\n        Offset(offset.dx - _margin.left, y),\n        Offset(offset.dx + size.width + _margin.right, y),\n        paint,\n      );\n    }\n  }\n\n  @override\n  Rect get paintBounds =>\n      Offset(_margin.left, _margin.top + _top) &\n      Size(size.width + _margin.horizontal, size.height + _margin.vertical + _top + _bottom + (dividerWidth ?? 0));\n\n  @override\n  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) =>\n      defaultHitTestChildren(result, position: position);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('margin', margin))\n      ..add(DiagnosticsProperty('padding', padding))\n      ..add(DoubleProperty('top', top))\n      ..add(DoubleProperty('bottom', bottom))\n      ..add(ColorProperty('dividerColor', dividerColor))\n      ..add(DoubleProperty('dividerWidth', dividerWidth))\n      ..add(EnumProperty('dividerType', dividerType))\n      ..add(EnumProperty('textDirection', textDirection));\n  }\n\n  EdgeInsets get padding => _padding;\n\n  set padding(EdgeInsets value) {\n    if (_padding != value) {\n      _padding = value;\n      markNeedsLayout();\n    }\n  }\n\n  EdgeInsets get margin => _margin;\n\n  set margin(EdgeInsets value) {\n    if (_margin != value) {\n      _margin = value;\n      markNeedsPaint();\n    }\n  }\n\n  double get top => _top;\n\n  set top(double value) {\n    if (_top != value) {\n      _top = value;\n      markNeedsPaint();\n    }\n  }\n\n  double get bottom => _bottom;\n\n  set bottom(double value) {\n    if (_bottom != value) {\n      _bottom = value;\n      markNeedsPaint();\n    }\n  }\n\n  Color? get dividerColor => _dividerColor;\n\n  set dividerColor(Color? value) {\n    if (_dividerColor != value) {\n      _dividerColor = value;\n      markNeedsPaint();\n    }\n  }\n\n  double? get dividerWidth => _dividerWidth;\n\n  set dividerWidth(double? value) {\n    if (_dividerWidth != value) {\n      _dividerWidth = value;\n      markNeedsPaint();\n    }\n  }\n\n  FItemDivider get dividerType => _dividerType;\n\n  set dividerType(FItemDivider value) {\n    if (_dividerType != value) {\n      _dividerType = value;\n      markNeedsPaint();\n    }\n  }\n\n  TextDirection get textDirection => _textDirection;\n\n  set textDirection(TextDirection value) {\n    if (_textDirection != value) {\n      _textDirection = value;\n      markNeedsLayout();\n    }\n  }\n}\n"
    },
    "LineCalendar": {
      "calendar_layout": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:sugar/sugar.dart' hide Offset;\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/rendering.dart';\nimport 'package:forui/src/widgets/line_calendar/line_calendar_item.dart';\n\n@internal\nclass CalendarLayout extends StatefulWidget {\n  final FCalendarController<DateTime?>? controller;\n  final FLineCalendarStyle style;\n  final AlignmentDirectional alignment;\n  final ScrollPhysics? physics;\n  final double? cacheExtent;\n  final ScrollViewKeyboardDismissBehavior keyboardDismissBehavior;\n  final TextScaler scale;\n  final TextStyle textStyle;\n  final ValueWidgetBuilder<FLineCalendarItemData> builder;\n  final ValueChanged<DateTime?>? onChange;\n  final bool toggleable;\n  final LocalDate start;\n  final LocalDate? end;\n  final LocalDate? initialScroll;\n  final LocalDate? initialSelection;\n  final LocalDate today;\n  final BoxConstraints constraints;\n\n  const CalendarLayout({\n    required this.controller,\n    required this.style,\n    required this.alignment,\n    required this.physics,\n    required this.cacheExtent,\n    required this.keyboardDismissBehavior,\n    required this.scale,\n    required this.textStyle,\n    required this.builder,\n    required this.onChange,\n    required this.toggleable,\n    required this.start,\n    required this.end,\n    required this.initialScroll,\n    required this.initialSelection,\n    required this.today,\n    required this.constraints,\n    super.key,\n  });\n\n  @override\n  State<CalendarLayout> createState() => _CalendarLayoutState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('alignment', alignment))\n      ..add(DiagnosticsProperty('physics', physics))\n      ..add(DoubleProperty('cacheExtent', cacheExtent))\n      ..add(DiagnosticsProperty('keyboardDismissBehavior', keyboardDismissBehavior))\n      ..add(DiagnosticsProperty('scaler', scale))\n      ..add(DiagnosticsProperty('textStyle', textStyle))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(FlagProperty('toggleable', value: toggleable, ifTrue: 'toggleable'))\n      ..add(DiagnosticsProperty('start', start))\n      ..add(DiagnosticsProperty('end', end))\n      ..add(DiagnosticsProperty('initialScroll', initialScroll))\n      ..add(DiagnosticsProperty('initialSelection', initialSelection))\n      ..add(DiagnosticsProperty('today', today))\n      ..add(DiagnosticsProperty('constraints', constraints));\n  }\n}\n\nclass _CalendarLayoutState extends State<CalendarLayout> {\n  late FCalendarController<DateTime?> _controller;\n  late ScrollController _scrollController;\n  late double _width;\n\n  @override\n  void initState() {\n    super.initState();\n    _width = _estimateWidth();\n\n    _controller =\n        widget.controller ??\n        FCalendarController.date(initialSelection: widget.initialSelection?.toNative(), toggleable: widget.toggleable);\n    _controller.addValueListener(_onChange);\n\n    final start = ((widget.initialScroll ?? widget.today).difference(widget.start).inDays) * _width;\n    _scrollController = ScrollController(\n      initialScrollOffset: switch (widget.alignment.start) {\n        -1 => start,\n        1 => start - widget.constraints.maxWidth + _width,\n        _ => start - (widget.constraints.maxWidth - _width) / 2,\n      },\n    );\n  }\n\n  @override\n  void didUpdateWidget(covariant CalendarLayout old) {\n    super.didUpdateWidget(old);\n    if (widget.style != old.style || widget.scale != old.scale || widget.textStyle != old.textStyle) {\n      _width = _estimateWidth();\n    }\n\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        _controller.removeValueListener(_onChange);\n      }\n\n      _controller =\n          widget.controller ??\n          FCalendarController.date(initialSelection: _controller.value, toggleable: widget.toggleable);\n      _controller.addValueListener(_onChange);\n    }\n  }\n\n  double _estimateWidth() {\n    final scale = widget.scale;\n    final textStyle = widget.textStyle;\n\n    double height(FLineCalendarStyle style, Set<WidgetState> states) {\n      final dateHeight = scale.scale(style.dateTextStyle.resolve(states).fontSize ?? textStyle.fontSize ?? 0);\n      final weekdayHeight = scale.scale(style.weekdayTextStyle.resolve(states).fontSize ?? textStyle.fontSize ?? 0);\n      final otherHeight = widget.style.contentSpacing + (widget.style.contentEdgeSpacing * 2);\n\n      return dateHeight + weekdayHeight + otherHeight;\n    }\n\n    // We use the height to estimate the width.\n    return [\n      height(widget.style, const {WidgetState.selected}),\n      height(widget.style, const {WidgetState.selected, WidgetState.hovered}),\n      height(widget.style, const {WidgetState.hovered}),\n      height(widget.style, const {}),\n    ].max!;\n  }\n\n  void _onChange(DateTime? date) => widget.onChange?.call(date);\n\n  @override\n  Widget build(BuildContext _) {\n    final placeholder = widget.today.toNative();\n    return SpeculativeLayout(\n      children: [\n        ItemContent(style: widget.style, states: const {WidgetState.selected}, date: placeholder),\n        ItemContent(style: widget.style, states: const {WidgetState.selected, WidgetState.hovered}, date: placeholder),\n        ItemContent(style: widget.style, states: const {}, date: placeholder),\n        ItemContent(style: widget.style, states: const {WidgetState.hovered}, date: placeholder),\n        ListView.builder(\n          controller: _scrollController,\n          scrollDirection: Axis.horizontal,\n          padding: EdgeInsets.zero,\n          physics: widget.physics,\n          cacheExtent: widget.cacheExtent,\n          keyboardDismissBehavior: widget.keyboardDismissBehavior,\n          itemExtent: _width,\n          itemCount: widget.end == null ? null : widget.end!.difference(widget.start).inDays + 1,\n          itemBuilder: (_, index) {\n            final date = widget.start.plus(days: index);\n            return Padding(\n              padding: widget.style.padding,\n              child: Item(\n                controller: _controller,\n                style: widget.style,\n                date: date.toNative(),\n                today: widget.today == date,\n                builder: widget.builder,\n              ),\n            );\n          },\n        ),\n      ],\n    );\n  }\n\n  @override\n  void dispose() {\n    _scrollController.dispose();\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeValueListener(_onChange);\n    }\n    super.dispose();\n  }\n}\n\n@internal\nclass SpeculativeLayout extends MultiChildRenderObjectWidget {\n  const SpeculativeLayout({required super.children, super.key});\n\n  @override\n  RenderObject createRenderObject(BuildContext _) => _SpeculativeBox();\n}\n\nclass _SpeculativeBox extends RenderBox\n    with ContainerRenderObjectMixin<RenderBox, DefaultData>, RenderBoxContainerDefaultsMixin<RenderBox, DefaultData> {\n  @override\n  void setupParentData(RenderObject child) => child.parentData = DefaultData();\n\n  @override\n  void performLayout() {\n    final selected = firstChild!;\n    final selectedHovered = childAfter(selected)!;\n    final unselected = childAfter(selectedHovered)!;\n    final unselectedHovered = childAfter(unselected)!;\n\n    final maxHeight = [\n      selected.getDryLayout(constraints).height,\n      selectedHovered.getDryLayout(constraints).height,\n      unselected.getDryLayout(constraints).height,\n      unselectedHovered.getDryLayout(constraints).height,\n    ].max!;\n\n    final heightConstraints = constraints.copyWith(maxHeight: maxHeight);\n    final viewport = childAfter(unselectedHovered)!..layout(heightConstraints, parentUsesSize: true);\n    size = constraints.constrain(viewport.size);\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) => context.paintChild(lastChild!, offset);\n\n  @override\n  bool hitTest(BoxHitTestResult result, {required Offset position}) {\n    final viewport = lastChild!;\n    return result.addWithPaintOffset(\n      offset: viewport.data.offset,\n      position: position,\n      hitTest: (result, transformed) => viewport.hitTest(result, position: transformed),\n    );\n  }\n\n  @override\n  void visitChildrenForSemantics(RenderObjectVisitor visitor) => visitor(lastChild!);\n}\n",
      "line_calendar": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\nimport 'package:sugar/sugar.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/line_calendar/calendar_layout.dart';\n\npart 'line_calendar.design.dart';\n\n/// A line calendar displays dates in a single horizontal, scrollable line.\n///\n/// ## Desktop and web note\n/// As the dates scroll on the horizontal axis (left to right or right to left), hold Shift while using the mouse\n/// scroll wheel to scroll the list.\n///\n/// See:\n/// * https://forui.dev/docs/data/line-calendar for working examples.\n/// * [FLineCalendarStyle] for customizing a line calendar's style.\nclass FLineCalendar extends StatelessWidget {\n  static Widget _builder(BuildContext _, FLineCalendarItemData _, Widget? child) => child!;\n\n  /// The controller.\n  final FCalendarController<DateTime?>? controller;\n\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create line-calendar\n  /// ```\n  final FLineCalendarStyle Function(FLineCalendarStyle style)? style;\n\n  /// The alignment to which the initially scrolled date will be aligned. Defaults to [Alignment.center].\n  final AlignmentDirectional initialScrollAlignment;\n\n  /// How the scroll view should respond to user input.\n  ///\n  /// Defaults to matching platform conventions.\n  final ScrollPhysics? physics;\n\n  /// {@macro forui.foundation.doc_templates.cacheExtent}\n  final double? cacheExtent;\n\n  /// [ScrollViewKeyboardDismissBehavior] the defines how this [FLineCalendar] will dismiss the keyboard automatically.\n  ///\n  /// Defaults to [ScrollViewKeyboardDismissBehavior.manual].\n  final ScrollViewKeyboardDismissBehavior keyboardDismissBehavior;\n\n  /// The builder used to build a line calendar item. Defaults to returning the given child.\n  ///\n  /// The `child` is the default content with no alterations. Consider wrapping the `child` and other custom decoration\n  /// in a [Stack] to avoid re-creating the custom content from scratch.\n  final ValueWidgetBuilder<FLineCalendarItemData> builder;\n\n  /// The callback that is called when the date changes.\n  final ValueChanged<DateTime?>? onChange;\n\n  final bool _toggleable;\n  final LocalDate _start;\n  final LocalDate? _end;\n  final LocalDate? _initialScroll;\n  final LocalDate? _initialSelection;\n  final LocalDate _today;\n\n  /// Creates a [FLineCalendar].\n  ///\n  /// [toggleable] represents whether the calendar is togglable, meaning that it can be selected and unselected.\n  /// Defaults to false.\n  ///\n  /// [start] represents the start date, inclusive. It is truncated to the nearest date. Defaults to the\n  /// [DateTime.utc(1900)].\n  ///\n  /// [end] represents the end date, exclusive. It is truncated to the nearest date.\n  ///\n  /// [initialScroll] represents the initial date to which the line calendar is scrolled. It is aligned based on\n  /// [initialScrollAlignment]. It is truncated to the nearest date. Defaults to [today] if not provided.\n  ///\n  /// [initialSelection] represents the initial date which is selected. It is truncated to the nearest date.\n  ///\n  /// [today] represents the current date. It is truncated to the nearest date. Defaults to the [DateTime.now].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * [controller] and [initialSelection] are both non-null.\n  /// * [controller] and [toggleable] are both non-null.\n  /// * [end] <= [start].\n  /// * [initialScroll] < [start] or [end] <= [initialScroll].\n  /// * [initialSelection] < [start] or [end] <= [initialSelection].\n  /// * [today] < [start] or [end] <= [today].\n  FLineCalendar({\n    this.controller,\n    this.style,\n    this.initialScrollAlignment = AlignmentDirectional.center,\n    this.physics,\n    this.cacheExtent,\n    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\n    this.builder = _builder,\n    this.onChange,\n    bool? toggleable,\n    DateTime? start,\n    DateTime? end,\n    DateTime? initialScroll,\n    DateTime? initialSelection,\n    DateTime? today,\n    super.key,\n  }) : _toggleable = toggleable ?? false,\n       _start = (start ?? DateTime.utc(1900)).toLocalDate(),\n       _end = end?.toLocalDate(),\n       _initialScroll = initialScroll?.toLocalDate(),\n       _initialSelection = initialSelection?.toLocalDate(),\n       _today = (today ?? DateTime.now()).toLocalDate(),\n       assert(\n         controller == null || toggleable == null,\n         'controller and toggleable cannot both be non-null. To fix, set the toggleable field directly in the controller.',\n       ),\n       assert(\n         start == null || end == null || start.toLocalDate() < end.toLocalDate(),\n         'start ($start) must be < end ($end)',\n       ),\n       assert(\n         initialScroll == null ||\n             start == null ||\n             (initialScroll.toLocalDate() >= start.toLocalDate() && initialScroll.toLocalDate() < end!.toLocalDate()),\n         'initialScroll ($initialScroll) must be >= start ($start)',\n       ),\n       assert(\n         controller == null || initialSelection == null,\n         'controller and initial selection cannot be both non-null. To fix, set the date field directly in the controller.',\n       ),\n       assert(\n         initialSelection == null ||\n             start == null ||\n             (initialSelection.toLocalDate() >= start.toLocalDate() &&\n                 initialSelection.toLocalDate() < end!.toLocalDate()),\n         'initialSelection ($initialSelection) must be >= start ($start) and < end ($end)',\n       ),\n       assert(\n         today == null ||\n             start == null ||\n             (today.toLocalDate() >= start.toLocalDate() && today.toLocalDate() < end!.toLocalDate()),\n         'today ($today) must be >= start ($start) and < end ($end)',\n       );\n\n  @override\n  Widget build(BuildContext context) => LayoutBuilder(\n    builder: (context, constraints) => CalendarLayout(\n      controller: controller,\n      style: style?.call(context.theme.lineCalendarStyle) ?? context.theme.lineCalendarStyle,\n      physics: physics,\n      cacheExtent: cacheExtent,\n      keyboardDismissBehavior: keyboardDismissBehavior,\n      scale: MediaQuery.textScalerOf(context),\n      textStyle: DefaultTextStyle.of(context).style,\n      onChange: onChange,\n      builder: builder,\n      toggleable: _toggleable,\n      start: _start,\n      end: _end,\n      initialScroll: _initialScroll,\n      initialSelection: _initialSelection,\n      today: _today,\n      constraints: constraints,\n      alignment: initialScrollAlignment,\n    ),\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('initialScrollAlignment', initialScrollAlignment))\n      ..add(DiagnosticsProperty('physics', physics))\n      ..add(DoubleProperty('cacheExtent', cacheExtent))\n      ..add(DiagnosticsProperty('keyboardDismissBehavior', keyboardDismissBehavior))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n\n/// [FLineCalendar]'s style.\nclass FLineCalendarStyle with Diagnosticable, _$FLineCalendarStyleFunctions {\n  /// The horizontal padding around each calendar item. Defaults to `EdgeInsets.symmetric(horizontal: 6.5)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The vertical height between the content and the edges. Defaults to 15.5.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if negative.\n  @override\n  final double contentEdgeSpacing;\n\n  /// The vertical height between the date and weekday. Defaults to 2.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if negative.\n  @override\n  final double contentSpacing;\n\n  /// The decoration.\n  ///\n  /// @macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<BoxDecoration> decoration;\n\n  /// The color of the today indicator.\n  ///\n  /// @macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<Color> todayIndicatorColor;\n\n  /// The text style for the date.\n  ///\n  /// @macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<TextStyle> dateTextStyle;\n\n  /// The text style for the day of the week.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<TextStyle> weekdayTextStyle;\n\n  /// The tappable style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// Creates a [FLineCalendarStyle].\n  FLineCalendarStyle({\n    required this.decoration,\n    required this.todayIndicatorColor,\n    required this.dateTextStyle,\n    required this.weekdayTextStyle,\n    required this.tappableStyle,\n    this.padding = const EdgeInsets.symmetric(horizontal: 6.5),\n    this.contentEdgeSpacing = 15.5,\n    this.contentSpacing = 2,\n  });\n\n  /// Creates a [FLineCalendarStyle] that inherits its properties.\n  factory FLineCalendarStyle.inherit({\n    required FColors colors,\n    required FTypography typography,\n    required FStyle style,\n  }) {\n    final focusedBorder = Border.all(color: colors.primary, width: style.borderWidth);\n    return FLineCalendarStyle(\n      decoration: FWidgetStateMap({\n        WidgetState.selected & (WidgetState.hovered | WidgetState.pressed) & WidgetState.focused: BoxDecoration(\n          color: colors.hover(colors.primary),\n          border: focusedBorder,\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.selected & (WidgetState.hovered | WidgetState.pressed): BoxDecoration(\n          color: colors.hover(colors.primary),\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.selected & WidgetState.focused: BoxDecoration(\n          color: colors.primary,\n          border: focusedBorder,\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.selected: BoxDecoration(color: colors.primary, borderRadius: style.borderRadius),\n        (WidgetState.hovered | WidgetState.pressed) & WidgetState.focused: BoxDecoration(\n          color: colors.secondary,\n          border: focusedBorder,\n          borderRadius: style.borderRadius,\n        ),\n        (WidgetState.hovered | WidgetState.pressed): BoxDecoration(\n          color: colors.secondary,\n          border: Border.all(color: colors.border),\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.focused: BoxDecoration(\n          color: colors.background,\n          border: focusedBorder,\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.any: BoxDecoration(\n          color: colors.background,\n          border: Border.all(color: colors.border),\n          borderRadius: style.borderRadius,\n        ),\n      }),\n      todayIndicatorColor: FWidgetStateMap({\n        WidgetState.selected & (WidgetState.hovered | WidgetState.pressed): colors.hover(colors.primaryForeground),\n        WidgetState.selected: colors.primaryForeground,\n        (WidgetState.hovered | WidgetState.pressed): colors.hover(colors.primary),\n        WidgetState.any: colors.primary,\n      }),\n      dateTextStyle: FWidgetStateMap({\n        WidgetState.selected: typography.xl.copyWith(\n          color: colors.primaryForeground,\n          fontWeight: FontWeight.w500,\n          height: 0,\n        ),\n        WidgetState.any: typography.xl.copyWith(color: colors.primary, fontWeight: FontWeight.w500, height: 0),\n      }),\n      weekdayTextStyle: FWidgetStateMap({\n        WidgetState.selected: typography.xs.copyWith(\n          color: colors.primaryForeground,\n          fontWeight: FontWeight.w500,\n          height: 0,\n        ),\n        WidgetState.any: typography.xs.copyWith(color: colors.mutedForeground, fontWeight: FontWeight.w500, height: 0),\n      }),\n      tappableStyle: style.tappableStyle,\n    );\n  }\n}\n",
      "line_calendar_item": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\n\n/// The state of a line calendar item used to build a line calendar item.\ntypedef FLineCalendarItemData = ({FLineCalendarStyle style, DateTime date, bool today, Set<WidgetState> states});\n\n@internal\nclass Item extends StatelessWidget {\n  final FCalendarController<DateTime?> controller;\n  final FLineCalendarStyle style;\n  final DateTime date;\n  final bool today;\n  final ValueWidgetBuilder<FLineCalendarItemData> builder;\n\n  const Item({\n    required this.controller,\n    required this.style,\n    required this.date,\n    required this.today,\n    required this.builder,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) => ValueListenableBuilder(\n    valueListenable: controller,\n    builder: (context, selected, _) => FTappable(\n      style: style.tappableStyle,\n      semanticsLabel: (FLocalizations.of(context) ?? FDefaultLocalizations()).fullDate(date),\n      selected: selected == date,\n      onPress: () => controller.select(date),\n      builder: (context, states, _) => builder(\n        context,\n        (style: style, date: date, today: today, states: states),\n        Stack(\n          children: [\n            Positioned.fill(\n              child: ItemContent(style: style, date: date, states: states),\n            ),\n            if (today)\n              Positioned(\n                top: 6,\n                right: 6,\n                child: Container(\n                  height: 4,\n                  width: 4,\n                  decoration: BoxDecoration(color: style.todayIndicatorColor.resolve(states), shape: BoxShape.circle),\n                ),\n              ),\n          ],\n        ),\n      ),\n    ),\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('date', date))\n      ..add(FlagProperty('today', value: today, ifTrue: 'today'))\n      ..add(ObjectFlagProperty.has('builder', builder));\n  }\n}\n\n@internal\nclass ItemContent extends StatelessWidget {\n  final FLineCalendarStyle style;\n  final DateTime date;\n  final Set<WidgetState> states;\n\n  const ItemContent({required this.style, required this.date, required this.states, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final localizations = FLocalizations.of(context) ?? FDefaultLocalizations();\n    return DecoratedBox(\n      decoration: style.decoration.resolve(states),\n      child: Padding(\n        padding: EdgeInsets.symmetric(vertical: style.contentEdgeSpacing),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          mainAxisSize: MainAxisSize.min,\n          spacing: style.contentSpacing,\n          children: [\n            DefaultTextStyle.merge(\n              textHeightBehavior: const TextHeightBehavior(\n                applyHeightToFirstAscent: false,\n                applyHeightToLastDescent: false,\n              ),\n              style: style.dateTextStyle.resolve(states),\n              child: Text(localizations.day(date)),\n            ),\n            DefaultTextStyle.merge(\n              textHeightBehavior: const TextHeightBehavior(\n                applyHeightToFirstAscent: false,\n                applyHeightToLastDescent: false,\n              ),\n              style: style.weekdayTextStyle.resolve(states),\n              child: Text(localizations.shortWeekDays[date.weekday % 7]),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('date', date))\n      ..add(IterableProperty('states', states));\n  }\n}\n"
    },
    "Pagination": {
      "pagination": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\nimport 'package:forui/src/widgets/pagination/pagination_controller.dart';\n\n/// A pagination allows the user to select a specific page from a range of pages.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/pagination for working examples.\n/// * [FPaginationController] for customizing the pagination's behavior.\n/// * [FPaginationStyle] for customizing the pagination's appearance.\nclass FPagination extends StatefulWidget {\n  /// The controller.\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if:\n  /// * Both [controller] and [initialPage] are provided.\n  /// * Both [controller] and [pages] are provided.\n  final FPaginationController? controller;\n\n  /// The pagination's style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create pagination\n  /// ```\n  final FPaginationStyle Function(FPaginationStyle style)? style;\n\n  /// The previous button placed at the beginning of the pagination.\n  ///\n  /// Defaults to an `FIcons.chevronLeft` icon.\n  final Widget? previous;\n\n  /// The next button placed at the end of the pagination.\n  ///\n  /// Defaults to an `FIcons.chevronRight` icon.\n  final Widget? next;\n\n  /// The initial page to be displayed.\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if:\n  /// * Both [controller] and [initialPage] are provided.\n  /// * [initialPage] is < 0.\n  /// * [initialPage] is >= [pages]\n  final int? initialPage;\n\n  /// The total number of pages.\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if:\n  /// * [controller] and [pages] are provided.\n  /// * [pages] is < 0.\n  /// * [pages] is >= [initialPage]\n  final int? pages;\n\n  /// A callback triggered when the current page changes.\n  final ValueChanged<int>? onChange;\n\n  /// Creates an [FPagination].\n  const FPagination({\n    this.controller,\n    this.style,\n    this.previous,\n    this.next,\n    this.initialPage,\n    this.pages,\n    this.onChange,\n    super.key,\n  }) : assert(\n         controller == null || initialPage == null,\n         'Cannot provide both controller and initialPage. To fix, set the page directly in the controller.',\n       ),\n       assert(\n         controller == null || pages == null,\n         'Cannot provide both controller and pages. To fix, set the pages directly in the controller.',\n       ),\n       assert(initialPage == null || initialPage >= 0, 'initialPage ($initialPage) must be >= 0'),\n       assert(\n         initialPage == null || pages == null || initialPage < pages,\n         'initialPage ($initialPage) must be < pages ($pages)',\n       ),\n       assert(pages == null || pages > 0, 'pages ($pages) must be > 0');\n\n  @override\n  State<FPagination> createState() => _FPaginationState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(IntProperty('initialPage', initialPage))\n      ..add(IntProperty('pages', pages))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n\nclass _FPaginationState extends State<FPagination> {\n  late FPaginationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller =\n        widget.controller ?? FPaginationController(initialPage: widget.initialPage ?? 0, pages: widget.pages ?? 1);\n    _controller.addListener(_onChange);\n  }\n\n  @override\n  void didUpdateWidget(covariant FPagination old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        old.controller?.removeListener(_onChange);\n      }\n\n      _controller =\n          widget.controller ?? FPaginationController(initialPage: widget.initialPage ?? 0, pages: widget.pages ?? 1);\n      _controller.addListener(_onChange);\n    }\n  }\n\n  void _onChange() => widget.onChange?.call(_controller.page);\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.paginationStyle) ?? context.theme.paginationStyle;\n    final localizations = FLocalizations.of(context) ?? FDefaultLocalizations();\n\n    final previous =\n        widget.previous ??\n        Action(\n          style: style,\n          semanticsLabel: localizations.paginationPreviousSemanticsLabel,\n          onPress: _controller.previous,\n          child: const Icon(FIcons.chevronLeft),\n        );\n    final next =\n        widget.next ??\n        Action(\n          style: style,\n          semanticsLabel: localizations.paginationNextSemanticsLabel,\n          onPress: _controller.next,\n          child: const Icon(FIcons.chevronRight),\n        );\n\n    final lastPage = _controller.pages - 1;\n\n    final ellipsis = Padding(\n      padding: style.itemPadding,\n      child: ConstrainedBox(\n        constraints: style.itemConstraints,\n        child: DefaultTextStyle(\n          style: style.ellipsisTextStyle,\n          child: const Center(child: Text('...')),\n        ),\n      ),\n    );\n\n    return ListenableBuilder(\n      listenable: _controller,\n      builder: (context, _) {\n        final (start, end) = _controller.siblingRange;\n\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            previous,\n            if (_controller.page > _controller.minPagesDisplayedAtEdges) ...[\n              if (_controller.showEdges)\n                FPaginationItemData(page: 0, style: style, controller: _controller, child: const _Page()),\n              ellipsis,\n            ],\n            for (int i = start; i <= end; i++)\n              FPaginationItemData(page: i, style: style, controller: _controller, child: const _Page()),\n            if (_controller.page < (lastPage - _controller.minPagesDisplayedAtEdges)) ...[\n              ellipsis,\n              if (_controller.showEdges)\n                FPaginationItemData(page: lastPage, style: style, controller: _controller, child: const _Page()),\n            ],\n            next,\n          ],\n        );\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeListener(_onChange);\n    }\n    super.dispose();\n  }\n}\n\n@internal\nclass FPaginationItemData extends InheritedWidget {\n  @useResult\n  static FPaginationItemData of(BuildContext context) {\n    assert(debugCheckHasAncestor<FPaginationItemData>('$FPagination', context));\n    return context.dependOnInheritedWidgetOfExactType<FPaginationItemData>()!;\n  }\n\n  final int page;\n  final FPaginationController controller;\n  final FPaginationStyle style;\n\n  const FPaginationItemData({\n    required this.page,\n    required this.controller,\n    required this.style,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(covariant FPaginationItemData old) =>\n      page != old.page || controller != old.controller || style != old.style;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(IntProperty('page', page))\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style));\n  }\n}\n\n@internal\nclass Action extends StatelessWidget {\n  final FPaginationStyle style;\n  final String semanticsLabel;\n  final VoidCallback onPress;\n  final Widget child;\n\n  const Action({\n    required this.style,\n    required this.semanticsLabel,\n    required this.onPress,\n    required this.child,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) => Padding(\n    padding: style.itemPadding,\n    child: FTappable(\n      style: style.actionTappableStyle,\n      semanticsLabel: semanticsLabel,\n      focusedOutlineStyle: context.theme.style.focusedOutlineStyle,\n      onPress: onPress,\n      builder: (context, states, child) => DecoratedBox(\n        decoration: style.itemDecoration.resolve(states),\n        child: ConstrainedBox(\n          constraints: style.itemConstraints,\n          child: DefaultTextStyle(\n            style: style.itemTextStyle.resolve(states),\n            child: Center(\n              child: IconTheme(data: style.itemIconStyle.resolve(states), child: child!),\n            ),\n          ),\n        ),\n      ),\n      child: child,\n    ),\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(StringProperty('semanticsLabel', semanticsLabel));\n  }\n}\n\nclass _Page extends StatelessWidget {\n  const _Page();\n\n  @override\n  Widget build(BuildContext context) {\n    final FPaginationItemData(:page, :controller, :style) = FPaginationItemData.of(context);\n    return Padding(\n      padding: style.itemPadding,\n      child: ListenableBuilder(\n        listenable: controller,\n        builder: (_, _) => FTappable(\n          style: style.pageTappableStyle,\n          focusedOutlineStyle: style.focusedOutlineStyle,\n          selected: controller.page == page,\n          onPress: () => controller.page = page,\n          builder: (_, states, _) => DecoratedBox(\n            decoration: style.itemDecoration.resolve(states),\n            child: ConstrainedBox(\n              constraints: style.itemConstraints,\n              child: DefaultTextStyle(\n                style: style.itemTextStyle.resolve(states),\n                child: Center(child: Text('${page + 1}')),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
      "pagination_controller": "import 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\n/// A controller that controls which page is selected.\nclass FPaginationController extends FChangeNotifier {\n  /// The number of sibling pages displayed beside the current page number. Defaults to 1.\n  ///\n  /// This value determines how many pages are shown on either side of the currently selected page in the pagination.\n  /// For example, if `siblings` is 2 and the current page is 5, the displayed pages would be 3, 4, 5, 6, and 7.\n  ///\n  /// # Contract:\n  /// * Throws [AssertionError] if [siblings] < 0.\n  final int siblings;\n\n  /// Whether to show the first and last pages in the pagination. Defaults to `true`.\n  ///\n  /// If `true`, the pagination will always display the first and last page, regardless of the current page.\n  /// This can be useful for allowing users to quickly navigate to the beginning or end of the paginated content.\n  final bool showEdges;\n\n  /// The total number of pages in the pagination.\n  final int pages;\n  int _page;\n\n  /// Creates a [FPaginationController].\n  ///\n  /// # Contract:\n  /// * Throws [AssertionError] if 0 <= [initialPage] and [initialPage] < [pages].\n  FPaginationController({required this.pages, int initialPage = 0, this.showEdges = true, this.siblings = 1})\n    : assert(0 < pages, 'pages ($pages) should be > 0'),\n      assert(0 <= siblings, 'siblings ($siblings) >= 0'),\n      assert(\n        0 <= initialPage && initialPage < pages,\n        'initialPage ($initialPage) must be between 0 and pages ($pages), exclusive.',\n      ),\n      _page = initialPage;\n\n  /// The current page index.\n  int get page => _page;\n\n  set page(int index) {\n    if (index >= pages || index < 0) {\n      throw StateError('The index must be within the allowed range.');\n    }\n    _page = index;\n    notifyListeners();\n  }\n\n  /// Moves to the previous page if the current page is greater than 1.\n  void previous() {\n    if (0 < _page) {\n      _page = _page - 1;\n      notifyListeners();\n    }\n  }\n\n  /// Moves to the next page if the current page is less than the total number of pages.\n  void next() {\n    if (_page < pages - 1) {\n      _page = _page + 1;\n      notifyListeners();\n    }\n  }\n\n  /// The start and end pages to display around the current page.\n  (int, int) get siblingRange {\n    final int rangeStart;\n    final int rangeEnd;\n    if (pages.isFinite) {\n      final last = pages - 1;\n      if (pages <= minPagesDisplayedAtEdges) {\n        return (0, last);\n      }\n      rangeStart = switch (_page) {\n        _ when _page - siblings < 0 => 0,\n        _ when _page > (last - minPagesDisplayedAtEdges) => (last - minPagesDisplayedAtEdges) - siblings,\n        _ when _page <= minPagesDisplayedAtEdges => 0,\n        _ => _page - siblings,\n      };\n\n      rangeEnd = switch (_page) {\n        _ when _page + siblings > last => last,\n        _ when _page < minPagesDisplayedAtEdges + 1 => minPagesDisplayedAtEdges + siblings,\n        _ when _page >= (last - minPagesDisplayedAtEdges) => last,\n        _ => _page + siblings,\n      };\n    } else {\n      rangeStart = switch (_page) {\n        _ when _page - siblings < 0 => 0,\n        _ when _page <= minPagesDisplayedAtEdges => 0,\n        _ => _page - siblings,\n      };\n\n      rangeEnd = switch (_page) {\n        _ when _page < minPagesDisplayedAtEdges + 1 => minPagesDisplayedAtEdges,\n        _ => _page + siblings,\n      };\n    }\n    return (rangeStart, rangeEnd);\n  }\n}\n\n@internal\nextension MinPagesDisplayedAtEdges on FPaginationController {\n  /// The minimum number of pages to display at both the start and end of the pagination.\n  ///\n  /// If the total number of pages is too small to accommodate both the edge pages\n  /// and the full set of sibling pages around the current page, all pages are displayed instead.\n  int get minPagesDisplayedAtEdges {\n    if (pages.isFinite) {\n      final minDisplayedAtEnds = siblings + 1 + (showEdges ? 1 : 0);\n      return pages <= (minDisplayedAtEnds + (siblings * 2 + 2)) ? pages : minDisplayedAtEnds;\n    }\n    return siblings + 1 + (showEdges ? 1 : 0);\n  }\n}\n",
      "pagination_style": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'pagination_style.design.dart';\n\n/// The [FPagination] styles.\nclass FPaginationStyle with Diagnosticable, _$FPaginationStyleFunctions {\n  /// The padding around each item. Defaults to EdgeInsets.symmetric(horizontal: 2)`.\n  @override\n  final EdgeInsets itemPadding;\n\n  /// The item's constraints. Defaults to `BoxConstraints(maxWidth: 40, minWidth: 40, maxHeight: 40, minHeight: 40)`.\n  @override\n  final BoxConstraints itemConstraints;\n\n  /// The icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<IconThemeData> itemIconStyle;\n\n  /// The decoration applied to the pagination item.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<BoxDecoration> itemDecoration;\n\n  /// The default text style applied to the pagination item.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<TextStyle> itemTextStyle;\n\n  /// The ellipsis's text style.\n  @override\n  final TextStyle ellipsisTextStyle;\n\n  /// The action's tappable style.\n  @override\n  final FTappableStyle actionTappableStyle;\n\n  /// The pagination item's tappable style.\n  @override\n  final FTappableStyle pageTappableStyle;\n\n  /// The pagination item's focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// Creates a [FPaginationStyle].\n  FPaginationStyle({\n    required this.itemIconStyle,\n    required this.itemDecoration,\n    required this.itemTextStyle,\n    required this.ellipsisTextStyle,\n    required this.actionTappableStyle,\n    required this.pageTappableStyle,\n    required this.focusedOutlineStyle,\n    this.itemPadding = const EdgeInsets.symmetric(horizontal: 2),\n    this.itemConstraints = const BoxConstraints.tightFor(width: 40.0, height: 40.0),\n  });\n\n  /// Creates a [FPaginationStyle] that inherits its properties.\n  FPaginationStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        itemIconStyle: FWidgetStateMap.all(IconThemeData(color: colors.primary, size: 18)),\n        itemDecoration: FWidgetStateMap({\n          WidgetState.selected & (WidgetState.hovered | WidgetState.pressed): BoxDecoration(\n            borderRadius: style.borderRadius,\n            color: colors.hover(colors.primary),\n          ),\n          WidgetState.selected: BoxDecoration(borderRadius: style.borderRadius, color: colors.primary),\n          WidgetState.hovered: BoxDecoration(borderRadius: style.borderRadius, color: colors.border),\n          WidgetState.any: BoxDecoration(borderRadius: style.borderRadius, color: colors.background),\n        }),\n        itemTextStyle: FWidgetStateMap({\n          WidgetState.selected: typography.sm.copyWith(color: colors.primaryForeground),\n          WidgetState.any: typography.sm.copyWith(color: colors.primary),\n        }),\n        ellipsisTextStyle: typography.sm.copyWith(color: colors.primary),\n        actionTappableStyle: style.tappableStyle,\n        pageTappableStyle: style.tappableStyle,\n        focusedOutlineStyle: style.focusedOutlineStyle,\n      );\n}\n"
    },
    "Picker": {
      "picker": "import 'dart:math';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n/// A picker's controller.\n///\n/// The [value] contains the index of the selected item in each wheel. The indexes are ordered:\n/// * from left to right if the current text direction is LTR\n/// * from right to left if the current text direction is RTL\nclass FPickerController extends FValueNotifier<List<int>> {\n  /// The picker wheels' initial indexes.\n  final List<int> initialIndexes;\n\n  /// The controllers for the individual picker wheels.\n  ///\n  /// The controllers are ordered:\n  /// * from left to right if the current text direction is LTR\n  /// * from right to left if the current text direction is RTL\n  ///\n  /// ## Contract\n  /// Reading the controllers before this FPickerController is attached to a [FPicker] is undefined behavior.\n  ///\n  /// Modifying [wheels] is undefined behavior.\n  final List<FixedExtentScrollController> wheels = [];\n\n  /// Creates a [FPickerController].\n  FPickerController({required this.initialIndexes}) : super([...initialIndexes]);\n\n  @override\n  List<int> get value => [...super.value];\n\n  @override\n  set value(List<int> value) {\n    assert(\n      wheels.isEmpty || value.length == wheels.length,\n      'The value must have the same length as the number of wheels.',\n    );\n\n    if (wheels.isNotEmpty) {\n      for (final (i, index) in value.indexed) {\n        wheels[i].jumpToItem(index);\n      }\n    }\n    super.value = value;\n  }\n\n  @override\n  void dispose() {\n    for (final wheel in wheels) {\n      wheel.dispose();\n    }\n    super.dispose();\n  }\n\n  // ignore: avoid_setters_without_getters\n  set _value(List<int> value) => super.value = value;\n}\n\n/// A generic picker that allows an item to be selected. It is composed of one or more [FPickerWheel]s, optionally,\n/// with separators between those wheels.\n///\n/// Recommended for touch devices.\n///\n/// The picker supports arrow key navigation:\n/// * Up/Down arrows: Increment/decrement selected value\n/// * Left/Right arrows: Move between wheels\n///\n/// See:\n/// * https://forui.dev/docs/form/picker for working examples.\n/// * [FPickerController] for controlling a picker.\n/// * [FPickerWheel] for customizing a picker's individual wheel.\n/// * [FPickerStyle] for customizing a picker's appearance.\nclass FPicker extends StatefulWidget {\n  /// The controller.\n  final FPickerController? controller;\n\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create picker\n  /// ```\n  final FPickerStyle Function(FPickerStyle style)? style;\n\n  /// Handler called when the picker indexes change.\n  ///\n  /// The given indexes are not automatically wrap around the wheel's length. This means that the indexes may be greater\n  /// than the wheel's length or even negative.\n  final ValueChanged<List<int>>? onChange;\n\n  /// The individual wheels and separators.\n  ///\n  /// ## Contract\n  /// A picker wheel must mix-in [FAccordionItemMixin]. Not doing so will result in the wheel being treated as a\n  /// separator and cause undefined behavior.\n  final List<Widget> children;\n\n  /// Creates a [FPicker] with several wheels, and optionally, separators.\n  const FPicker({required this.children, this.controller, this.style, this.onChange, super.key});\n\n  @override\n  State<FPicker> createState() => _FPickerState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n\nclass _FPickerState extends State<FPicker> {\n  late FPickerController _controller;\n\n  /// Prevents the controller's value from being updated when the wheels are scrolling.\n  int _scrolling = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _createController();\n    _controller.addValueListener(_onChange);\n  }\n\n  @override\n  void didUpdateWidget(covariant FPicker old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        old.controller?.removeValueListener(_onChange);\n      }\n\n      _createController();\n      _controller.addValueListener(_onChange);\n    }\n  }\n\n  void _createController() {\n    _controller =\n        widget.controller ??\n        FPickerController(initialIndexes: List.filled(widget.children.whereType<FPickerWheel>().length, 0));\n\n    for (final wheel in _controller.wheels) {\n      wheel.dispose();\n    }\n    _controller.wheels.clear();\n\n    for (final (index, item) in _controller.value.indexed) {\n      _controller.wheels.add(\n        FixedExtentScrollController(\n          initialItem: item,\n          onAttach: (position) {\n            if (position.hasContentDimensions) {\n              final copy = _controller.value;\n              // This is evil but it's the only way to get the item index as it's hidden in a private class.\n              copy[index] = (position as dynamic).itemIndex;\n              _controller._value = copy;\n            }\n          },\n        ),\n      );\n    }\n  }\n\n  void _onChange(List<int> value) => widget.onChange?.call(value);\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.pickerStyle) ?? context.theme.pickerStyle;\n    final selectionExtent =\n        FPickerWheel.estimateExtent(style, context) * style.magnification + style.selectionHeightAdjustment;\n\n    var wheelIndex = 0;\n    return Stack(\n      alignment: Alignment.center,\n      children: [\n        Container(\n          height: selectionExtent,\n          decoration: BoxDecoration(color: style.selectionColor, borderRadius: style.selectionBorderRadius),\n        ),\n        // Syncs the controller's value with the wheel's scroll controller when the widget is updated.\n        NotificationListener<ScrollMetricsNotification>(\n          onNotification: (_) {\n            if (_scrolling == 0) {\n              _controller._value = [for (final wheel in _controller.wheels) wheel.selectedItem];\n            }\n\n            return false;\n          },\n          child: NotificationListener<ScrollStartNotification>(\n            onNotification: (_) {\n              _scrolling++;\n              return false;\n            },\n            child: NotificationListener<ScrollEndNotification>(\n              onNotification: (_) {\n                _scrolling = max(_scrolling - 1, 0);\n                if (_scrolling == 0) {\n                  _controller._value = [for (final wheel in _controller.wheels) wheel.selectedItem];\n                }\n\n                return false;\n              },\n              child: Row(\n                mainAxisSize: MainAxisSize.min,\n                mainAxisAlignment: MainAxisAlignment.center,\n                spacing: style.spacing,\n                children: [\n                  for (final child in widget.children)\n                    if (child is FPickerWheelMixin)\n                      PickerData(controller: _controller.wheels[wheelIndex++], style: style, child: child)\n                    else\n                      Center(\n                        child: DefaultTextStyle.merge(\n                          textHeightBehavior: style.textHeightBehavior,\n                          style: style.textStyle,\n                          child: child,\n                        ),\n                      ),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeValueListener(_onChange);\n    }\n    super.dispose();\n  }\n}\n\n@internal\nclass PickerData extends InheritedWidget {\n  static PickerData of(BuildContext context) {\n    assert(debugCheckHasAncestor<PickerData>('$FPicker', context));\n    return context.dependOnInheritedWidgetOfExactType<PickerData>()!;\n  }\n\n  final FixedExtentScrollController controller;\n  final FPickerStyle style;\n\n  const PickerData({required this.controller, required this.style, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(PickerData old) => controller != old.controller || style != old.style;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style));\n  }\n}\n",
      "picker_style": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'picker_style.design.dart';\n\n/// [FPickerStyle]'s style.\nclass FPickerStyle with Diagnosticable, _$FPickerStyleFunctions {\n  /// A ratio between the diameter of the cylinder and the viewport's size.\n  @override\n  final double diameterRatio;\n\n  /// The angular compactness of the children on the wheel.\n  @override\n  final double squeeze;\n\n  /// The zoomed-in rate of the magnifier.\n  @override\n  final double magnification;\n\n  /// The opacity value applied to the wheel above and below the magnifier.\n  @override\n  final double overAndUnderCenterOpacity;\n\n  /// The spacing between the picker's wheels. Defaults to 5.\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if the spacing is less than 0.\n  @override\n  final double spacing;\n\n  /// The picker's default text style.\n  @override\n  final TextStyle textStyle;\n\n  /// The picker's default text height behavior.\n  @override\n  final TextHeightBehavior textHeightBehavior;\n\n  /// An amount to add to the height of the selection.\n  @override\n  final double selectionHeightAdjustment;\n\n  /// The selection's border radius.\n  @override\n  final BorderRadiusGeometry selectionBorderRadius;\n\n  /// The selection's color.\n  @override\n  final Color selectionColor;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// Creates a [FPickerStyle].\n  const FPickerStyle({\n    required this.textStyle,\n    required this.selectionBorderRadius,\n    required this.selectionColor,\n    required this.focusedOutlineStyle,\n    this.diameterRatio = 1.07,\n    this.squeeze = 1,\n    this.magnification = 1,\n    this.overAndUnderCenterOpacity = 0.25,\n    this.spacing = 5,\n    this.textHeightBehavior = const TextHeightBehavior(\n      applyHeightToFirstAscent: false,\n      applyHeightToLastDescent: false,\n    ),\n    this.selectionHeightAdjustment = 0,\n  }) : assert(0 < diameterRatio, 'diameterRatio ($diameterRatio) must be > 0'),\n       assert(0 < squeeze, 'squeeze ($squeeze) must be > 0'),\n       assert(0 < magnification, 'magnification ($magnification) must be > 0'),\n       assert(\n         0 <= overAndUnderCenterOpacity && overAndUnderCenterOpacity <= 1,\n         'overAndUnderCenterOpacity ($overAndUnderCenterOpacity) must be between 0 and 1',\n       ),\n       assert(spacing >= 0, 'spacing ($spacing) must be >= 0');\n\n  /// Creates a [FPickerStyle] that inherits its properties.\n  FPickerStyle.inherit({required FColors colors, required FStyle style, required FTypography typography})\n    : this(\n        textStyle: typography.base.copyWith(fontWeight: FontWeight.w500),\n        selectionBorderRadius: style.borderRadius,\n        selectionColor: colors.muted,\n        focusedOutlineStyle: style.focusedOutlineStyle,\n      );\n}\n",
      "picker_wheel": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/picker/picker.dart';\n\nclass _ScrollBehavior extends ScrollBehavior {\n  static final _devices = PointerDeviceKind.values.toSet();\n\n  const _ScrollBehavior();\n\n  @override\n  Set<PointerDeviceKind> get dragDevices => _devices;\n}\n\n/// A marker interface that indicates that a widget is a picker wheel.\nmixin FPickerWheelMixin on Widget {}\n\n/// A picker wheel that displays a list of items that can be scrolled vertically.\n///\n/// It should only be used in a [FPicker].\nabstract class FPickerWheel extends StatefulWidget with FPickerWheelMixin {\n  /// Estimates the extent of each item in the picker based on the given [style] and [context].\n  static double estimateExtent(FPickerStyle style, BuildContext context) {\n    final defaultTextStyle = DefaultTextStyle.of(context);\n    final scale = MediaQuery.textScalerOf(context);\n\n    final height = style.textStyle.height ?? defaultTextStyle.style.height;\n    final fontSize = style.textStyle.fontSize ?? defaultTextStyle.style.fontSize ?? 0;\n    return scale.scale(height == null ? fontSize : height * fontSize);\n  }\n\n  /// The flex factor to use for this child.\n  ///\n  /// If zero, the child is inflexible and determines its own size. If non-zero, the amount of space the child can\n  /// occupy in the main axis is determined by dividing the free space (after placing the inflexible children) according\n  /// to the flex factors of the flexible children.\n  ///\n  /// Defaults to 1.\n  final int flex;\n\n  /// The extent of each item in the picker. Defaults to the height of the picker's text style, scaled by the current\n  /// [TextScaler].\n  final double? itemExtent;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// Creates a picker wheel with the given children.\n  const factory FPickerWheel({\n    required List<Widget> children,\n    bool loop,\n    int flex,\n    double? itemExtent,\n    bool autofocus,\n    FocusNode? focusNode,\n    ValueChanged<bool>? onFocusChange,\n    Key? key,\n  }) = ListWheel;\n\n  /// Creates a picker wheel with the given builder.\n  const factory FPickerWheel.builder({\n    required IndexedWidgetBuilder builder,\n    int flex,\n    double? itemExtent,\n    bool autofocus,\n    FocusNode? focusNode,\n    ValueChanged<bool>? onFocusChange,\n    Key? key,\n  }) = BuilderWheel;\n\n  const FPickerWheel._({\n    this.flex = 1,\n    this.itemExtent,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    super.key,\n  });\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(IntProperty('flex', flex))\n      ..add(DoubleProperty('itemExtent', itemExtent))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange));\n  }\n}\n\nabstract class _State<T extends FPickerWheel> extends State<T> {\n  bool _focused = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _focused = widget.autofocus;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final PickerData(:controller, :style) = PickerData.of(context);\n    final extent = widget.itemExtent ?? FPickerWheel.estimateExtent(style, context);\n    return Flexible(\n      flex: widget.flex,\n      child: FocusableActionDetector(\n        descendantsAreFocusable: false,\n        autofocus: widget.autofocus,\n        focusNode: widget.focusNode,\n        onFocusChange: (focused) {\n          widget.onFocusChange?.call(focused);\n          if (_focused != focused) {\n            setState(() => _focused = focused);\n          }\n        },\n        shortcuts: const {\n          SingleActivator(LogicalKeyboardKey.arrowUp): ScrollIntent(direction: AxisDirection.up),\n          SingleActivator(LogicalKeyboardKey.arrowDown): ScrollIntent(direction: AxisDirection.down),\n        },\n        actions: {\n          ScrollIntent: CallbackAction<ScrollIntent>(\n            onInvoke: (intent) {\n              controller.animateToItem(\n                controller.selectedItem + (intent.direction == AxisDirection.up ? -1 : 1),\n                duration: const Duration(milliseconds: 100),\n                curve: Curves.decelerate,\n              );\n\n              return null;\n            },\n          ),\n        },\n        child: Stack(\n          alignment: Alignment.center,\n          children: [\n            if (_focused)\n              Container(\n                height: extent,\n                decoration: BoxDecoration(\n                  border: Border.all(color: style.focusedOutlineStyle.color, width: style.focusedOutlineStyle.width),\n                  borderRadius: style.focusedOutlineStyle.borderRadius,\n                ),\n              ),\n            ScrollConfiguration(\n              behavior: const _ScrollBehavior(),\n              child: ListWheelScrollView.useDelegate(\n                controller: controller,\n                physics: const FixedExtentScrollPhysics(),\n                itemExtent: extent,\n                diameterRatio: style.diameterRatio,\n                magnification: style.magnification,\n                squeeze: style.squeeze,\n                overAndUnderCenterOpacity: style.overAndUnderCenterOpacity,\n                childDelegate: delegate(style),\n                onSelectedItemChanged: (_) => HapticFeedback.selectionClick(),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  ListWheelChildDelegate delegate(FPickerStyle style);\n}\n\n@internal\nclass ListWheel extends FPickerWheel {\n  final bool loop;\n  final List<Widget> children;\n\n  const ListWheel({\n    required this.children,\n    this.loop = false,\n    super.flex = 1,\n    super.itemExtent,\n    super.autofocus,\n    super.focusNode,\n    super.onFocusChange,\n    super.key,\n  }) : super._();\n\n  @override\n  State<StatefulWidget> createState() => _ListState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(FlagProperty('loop', value: loop, ifTrue: 'loop'));\n  }\n}\n\nclass _ListState extends _State<ListWheel> {\n  @override\n  ListWheelChildDelegate delegate(FPickerStyle style) {\n    final children = [\n      for (final child in widget.children)\n        Center(\n          child: DefaultTextStyle.merge(\n            textHeightBehavior: style.textHeightBehavior,\n            style: style.textStyle,\n            child: Semantics(inMutuallyExclusiveGroup: true, child: child),\n          ),\n        ),\n    ];\n\n    return widget.loop\n        ? ListWheelChildLoopingListDelegate(children: children)\n        : ListWheelChildListDelegate(children: children);\n  }\n}\n\n@internal\nclass BuilderWheel extends FPickerWheel {\n  final IndexedWidgetBuilder builder;\n\n  const BuilderWheel({\n    required this.builder,\n    super.flex,\n    super.itemExtent,\n    super.autofocus,\n    super.focusNode,\n    super.onFocusChange,\n    super.key,\n  }) : super._();\n\n  @override\n  State<BuilderWheel> createState() => _BuilderState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(ObjectFlagProperty.has('builder', builder));\n  }\n}\n\nclass _BuilderState extends _State<BuilderWheel> {\n  @override\n  ListWheelChildDelegate delegate(FPickerStyle style) => ListWheelChildBuilderDelegate(\n    builder: (context, index) => Center(\n      child: DefaultTextStyle.merge(\n        textHeightBehavior: style.textHeightBehavior,\n        style: style.textStyle,\n        child: widget.builder(context, index),\n      ),\n    ),\n  );\n}\n"
    },
    "Progresses": {
      "circular_progress": "import 'dart:math' as math;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'circular_progress.design.dart';\n\n/// An indeterminate circular progress indicator.\n///\n/// See:\n/// * https://forui.dev/docs/feedback/circular-progress for working examples.\n/// * [FCircularProgressStyle] for customizing a circular progress's appearance.\n/// * [FProgress] for for an indeterminate linear progress indicator.\nclass FCircularProgress extends StatefulWidget {\n  /// The style.\n  final FCircularProgressStyle Function(FCircularProgressStyle style)? style;\n\n  /// The semantics label. Defaults to [FLocalizations.progressSemanticsLabel].\n  final String? semanticsLabel;\n\n  /// The icon.\n  final IconData icon;\n\n  /// Creates a [FCircularProgress] that uses [FIcons.loaderCircle].\n  const FCircularProgress({this.style, this.semanticsLabel, this.icon = FIcons.loaderCircle, super.key});\n\n  /// Creates a [FCircularProgress] that uses [FIcons.loader].\n  const FCircularProgress.loader({this.style, this.semanticsLabel, this.icon = FIcons.loader, super.key});\n\n  /// Creates a [FCircularProgress] that uses [FIcons.loaderPinwheel].\n  const FCircularProgress.pinwheel({this.style, this.semanticsLabel, this.icon = FIcons.loaderPinwheel, super.key});\n\n  @override\n  State<FCircularProgress> createState() => _CircularState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(StringProperty('semanticsLabel', semanticsLabel))\n      ..add(IconDataProperty('icon', icon));\n  }\n}\n\nclass _CircularState extends State<FCircularProgress> with SingleTickerProviderStateMixin {\n  FCircularProgressStyle? _style;\n  late final AnimationController _controller = AnimationController(vsync: this);\n  late final CurvedAnimation _curveRotation = CurvedAnimation(parent: _controller, curve: Curves.linear);\n  late Animation<double> _rotation;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _setup();\n  }\n\n  @override\n  void didUpdateWidget(covariant FCircularProgress old) {\n    super.didUpdateWidget(old);\n    _setup();\n  }\n\n  void _setup() {\n    final inherited = FInheritedCircularProgressStyle.of(context);\n    final style = widget.style?.call(inherited) ?? inherited;\n    if (_style != style) {\n      _style = style;\n      _controller\n        ..duration = style.motion.duration\n        ..repeat();\n      _curveRotation.curve = style.motion.curve;\n      _rotation = style.motion.tween.animate(_curveRotation);\n    }\n  }\n\n  @override\n  void dispose() {\n    _curveRotation.dispose();\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final semanticsLabel =\n        widget.semanticsLabel ?? (FLocalizations.of(context) ?? FDefaultLocalizations()).progressSemanticsLabel;\n    return AnimatedBuilder(\n      animation: _rotation,\n      builder: (_, child) => Transform.rotate(angle: _rotation.value * 2 * math.pi, child: child),\n      child: IconTheme(\n        data: _style!.iconStyle,\n        child: Icon(widget.icon, semanticLabel: semanticsLabel),\n      ),\n    );\n  }\n}\n\n/// An inherited widget that provides [FCircularProgressStyle] to its descendants.\nclass FInheritedCircularProgressStyle extends InheritedWidget {\n  /// The circular progress's style.\n  final FCircularProgressStyle style;\n\n  /// Returns the current [FCircularProgressStyle].\n  static FCircularProgressStyle of(BuildContext context) =>\n      context.dependOnInheritedWidgetOfExactType<FInheritedCircularProgressStyle>()?.style ??\n      context.theme.circularProgressStyle;\n\n  /// Creates a [FInheritedCircularProgressStyle].\n  const FInheritedCircularProgressStyle({required this.style, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(FInheritedCircularProgressStyle old) => style != old.style;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// The style for [FCircularProgress].\nclass FCircularProgressStyle with Diagnosticable, _$FCircularProgressStyleFunctions {\n  /// The circular progress's style.\n  @override\n  final IconThemeData iconStyle;\n\n  /// The motion-related properties.\n  @override\n  final FCircularProgressMotion motion;\n\n  /// Creates a [FCircularProgressStyle].\n  FCircularProgressStyle({required this.iconStyle, this.motion = const FCircularProgressMotion()});\n\n  /// Creates a [FCircularProgressStyle].\n  FCircularProgressStyle.inherit({required FColors colors})\n    : this(iconStyle: IconThemeData(color: colors.mutedForeground, size: 20));\n}\n\n/// Motion-related properties for [FCircularProgress].\nclass FCircularProgressMotion with Diagnosticable, _$FCircularProgressMotionFunctions {\n  /// The duration of one full rotation. Defaults to 1s.\n  @override\n  final Duration duration;\n\n  /// The animation curve. Defaults to [Curves.linear].\n  @override\n  final Curve curve;\n\n  /// The rotation's tween. Defaults to `FImmutableTween(begin: 0.0, end: 1.0)`. Reverse to rotate counter-clockwise.\n  @override\n  final Animatable<double> tween;\n\n  /// Creates a [FCircularProgressMotion].\n  const FCircularProgressMotion({\n    this.duration = const Duration(seconds: 1),\n    this.curve = Curves.linear,\n    this.tween = const FImmutableTween(begin: 0.0, end: 1.0),\n  });\n}\n",
      "determinate_progress": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'determinate_progress.design.dart';\n\n/// A determinate linear progress indicator.\n///\n/// See:\n/// * https://forui.dev/docs/feedback/progress for working examples.\n/// * [FDeterminateProgressStyle] for customizing a progress's appearance.\n/// * [FProgress] for for an indeterminate linear progress indicator.\n/// * [FCircularProgress] for for an indeterminate circular progress indicator.\nclass FDeterminateProgress extends StatefulWidget {\n  /// The style.\n  final FDeterminateProgressStyle Function(FDeterminateProgressStyle style)? style;\n\n  /// The semantics label. Defaults to [FLocalizations.progressSemanticsLabel].\n  final String? semanticsLabel;\n\n  /// The progress value. Defaults to null.\n  ///\n  /// ## Contract\n  /// Throw [AssertionError] if value is not between 0.0 and 1.0.\n  final double value;\n\n  /// Creates a determinate [FDeterminateProgress].\n  const FDeterminateProgress({required this.value, this.style, this.semanticsLabel, super.key})\n    : assert((0.0 <= value && value <= 1.0), 'value ($value) must be between 0.0 and 1.0');\n\n  @override\n  State<FDeterminateProgress> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(StringProperty('semanticsLabel', semanticsLabel))\n      ..add(PercentProperty('value', value));\n  }\n}\n\nclass _State extends State<FDeterminateProgress> with SingleTickerProviderStateMixin {\n  FDeterminateProgressStyle? _style;\n  late final AnimationController _controller = AnimationController(vsync: this);\n  late final CurvedAnimation _animation = CurvedAnimation(parent: _controller, curve: Curves.linear);\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _setup();\n  }\n\n  @override\n  void didUpdateWidget(covariant FDeterminateProgress old) {\n    super.didUpdateWidget(old);\n    _setup();\n  }\n\n  void _setup() {\n    final style = widget.style?.call(context.theme.determinateProgressStyle) ?? context.theme.determinateProgressStyle;\n\n    if (_style != style) {\n      _style = style;\n      _controller\n        ..value = _controller.value\n        ..duration = style.motion.duration;\n      _animation.curve = style.motion.curve;\n    }\n\n    if (widget.value != _controller.value) {\n      _controller.animateTo(widget.value, duration: style.motion.duration * (widget.value - _controller.value).abs());\n    }\n  }\n\n  @override\n  void dispose() {\n    _animation.dispose();\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => ConstrainedBox(\n    constraints: _style!.constraints,\n    child: Semantics(\n      label: widget.semanticsLabel ?? (FLocalizations.of(context) ?? FDefaultLocalizations()).progressSemanticsLabel,\n      child: DecoratedBox(\n        decoration: _style!.trackDecoration,\n        child: Align(\n          alignment: AlignmentDirectional.centerStart,\n          child: AnimatedBuilder(\n            animation: _animation,\n            builder: (_, child) => FractionallySizedBox(widthFactor: _animation.value, child: child!),\n            child: Container(decoration: _style!.fillDecoration),\n          ),\n        ),\n      ),\n    ),\n  );\n}\n\n/// A [FDeterminateProgress]'s style.\nclass FDeterminateProgressStyle with Diagnosticable, _$FDeterminateProgressStyleFunctions {\n  /// The linear progress's constraints. Defaults to a height of 10.0 and no horizontal constraint.\n  @override\n  final BoxConstraints constraints;\n\n  /// The track's decoration.\n  @override\n  final BoxDecoration trackDecoration;\n\n  /// The fill's decoration.\n  @override\n  final BoxDecoration fillDecoration;\n\n  /// The motion-related properties for an indeterminate [FDeterminateProgress].\n  @override\n  final FDeterminateProgressMotion motion;\n\n  /// Creates a [FDeterminateProgressStyle].\n  const FDeterminateProgressStyle({\n    required this.trackDecoration,\n    required this.fillDecoration,\n    this.constraints = const BoxConstraints.tightFor(height: 10.0),\n    this.motion = const FDeterminateProgressMotion(),\n  });\n\n  /// Creates a [FDeterminateProgressStyle] that inherits its properties.\n  FDeterminateProgressStyle.inherit({required FColors colors, required FStyle style})\n    : this(\n        trackDecoration: BoxDecoration(borderRadius: style.borderRadius, color: colors.secondary),\n        fillDecoration: BoxDecoration(borderRadius: style.borderRadius, color: colors.primary),\n      );\n}\n\n/// Motion-related properties for a [FDeterminateProgress].\nclass FDeterminateProgressMotion with Diagnosticable, _$FDeterminateProgressMotionFunctions {\n  /// The animation's duration for a full progress from 0.0 to 1.0. Defaults to 1s.\n  @override\n  final Duration duration;\n\n  /// The animation curve. Defaults to [Curves.linear].\n  @override\n  final Curve curve;\n\n  /// Creates a [FDeterminateProgressMotion].\n  const FDeterminateProgressMotion({this.duration = const Duration(milliseconds: 1000), this.curve = Curves.linear});\n}\n",
      "progress": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'progress.design.dart';\n\n/// Am indeterminate linear progress indicator.\n///\n/// See:\n/// * https://forui.dev/docs/feedback/progress for working examples.\n/// * [FProgressStyle] for customizing a progress's appearance.\n/// * [FDeterminateProgress] for a determinate progress indicator.\n/// * [FCircularProgress] for for a circular progress indicator.\nclass FProgress extends StatefulWidget {\n  /// The style.\n  final FProgressStyle Function(FProgressStyle style)? style;\n\n  /// The semantics label. Defaults to [FLocalizations.progressSemanticsLabel].\n  final String? semanticsLabel;\n\n  /// Creates a determinate [FProgress].\n  const FProgress({this.style, this.semanticsLabel, super.key});\n\n  @override\n  State<FProgress> createState() => _ProgressState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(StringProperty('semanticsLabel', semanticsLabel));\n  }\n}\n\nclass _ProgressState extends State<FProgress> with SingleTickerProviderStateMixin {\n  FProgressStyle? _style;\n  late final AnimationController _controller = AnimationController(vsync: this);\n  late final CurvedAnimation _curved = CurvedAnimation(parent: _controller, curve: Curves.linear);\n  late Animation<double> _animation;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _setup();\n  }\n\n  @override\n  void didUpdateWidget(covariant FProgress old) {\n    super.didUpdateWidget(old);\n    _setup();\n  }\n\n  void _setup() {\n    final style = widget.style?.call(context.theme.progressStyle) ?? context.theme.progressStyle;\n    if (_style != style) {\n      _style = style;\n\n      final total = style.motion.period + style.motion.interval;\n      final curve = Interval(0, style.motion.period.inMilliseconds / total.inMilliseconds, curve: style.motion.curve);\n\n      _controller\n        ..duration = total\n        ..repeat();\n      _curved.curve = curve;\n      _animation = Tween<double>(begin: -style.motion.value, end: 1).animate(_curved);\n    }\n  }\n\n  @override\n  void dispose() {\n    _curved.dispose();\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => ConstrainedBox(\n    constraints: _style!.constraints,\n    child: Semantics(\n      label: widget.semanticsLabel ?? (FLocalizations.of(context) ?? FDefaultLocalizations()).progressSemanticsLabel,\n      child: Container(\n        clipBehavior: Clip.antiAlias,\n        decoration: _style!.trackDecoration,\n        child: LayoutBuilder(\n          builder: (context, constraints) => AnimatedBuilder(\n            animation: _animation,\n            builder: (_, child) => Stack(\n              children: [\n                PositionedDirectional(\n                  start: constraints.maxWidth * (_animation.value),\n                  width: constraints.maxWidth * _style!.motion.value,\n                  top: 0,\n                  bottom: 0,\n                  child: child!,\n                ),\n              ],\n            ),\n            child: DecoratedBox(decoration: _style!.fillDecoration),\n          ),\n        ),\n      ),\n    ),\n  );\n}\n\n/// A [FProgress]'s style.\nclass FProgressStyle with Diagnosticable, _$FProgressStyleFunctions {\n  /// The linear progress's constraints. Defaults to a height of 10.0 and no horizontal constraint.\n  @override\n  final BoxConstraints constraints;\n\n  /// The track's decoration.\n  @override\n  final BoxDecoration trackDecoration;\n\n  /// The fill's decoration.\n  @override\n  final BoxDecoration fillDecoration;\n\n  /// The motion-related properties for an indeterminate [FProgress].\n  @override\n  final FProgressMotion motion;\n\n  /// Creates a [FProgressStyle].\n  const FProgressStyle({\n    required this.trackDecoration,\n    required this.fillDecoration,\n    this.constraints = const BoxConstraints.tightFor(height: 10.0),\n    this.motion = const FProgressMotion(),\n  });\n\n  /// Creates a [FProgressStyle] that inherits its properties.\n  FProgressStyle.inherit({required FColors colors, required FStyle style})\n    : this(\n        trackDecoration: BoxDecoration(borderRadius: style.borderRadius, color: colors.secondary),\n        fillDecoration: BoxDecoration(borderRadius: style.borderRadius, color: colors.primary),\n      );\n}\n\n/// Motion-related properties for an indeterminate [FProgress].\nclass FProgressMotion with Diagnosticable, _$FProgressMotionFunctions {\n  /// The animation's period. Defaults to 1s.\n  @override\n  final Duration period;\n\n  /// The interval between animations. Defaults to 500ms.\n  @override\n  final Duration interval;\n\n  /// The animation curve. Defaults to [Curves.ease].\n  @override\n  final Curve curve;\n\n  /// The percentage of the filled progress. Defaults to 0.4.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if outside the range of 0.0 to 1.0.\n  @override\n  final double value;\n\n  /// Creates a [FProgressMotion].\n  const FProgressMotion({\n    this.period = const Duration(milliseconds: 1000),\n    this.interval = const Duration(milliseconds: 500),\n    this.curve = Curves.ease,\n    this.value = 0.4,\n  }) : assert(value >= 0.0 && value <= 1.0, 'value ($value) must be between 0.0 and 1.0');\n}\n"
    },
    "Resizable": {
      "divider": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'divider.design.dart';\n\nclass _Up extends Intent {\n  const _Up();\n}\n\nclass _Down extends Intent {\n  const _Down();\n}\n\n@internal\nsealed class Divider extends StatefulWidget {\n  final FResizableController controller;\n  final FResizableDividerStyle style;\n  final FResizableDivider type;\n  final int left;\n  final int right;\n  final double? crossAxisExtent;\n  final double hitRegionExtent;\n  final double resizePercentage;\n  final MouseCursor cursor;\n  final String Function(FResizableRegionData first, FResizableRegionData second) semanticFormatterCallback;\n\n  const Divider({\n    required this.controller,\n    required this.style,\n    required this.type,\n    required this.left,\n    required this.right,\n    required this.crossAxisExtent,\n    required this.hitRegionExtent,\n    required this.resizePercentage,\n    required this.cursor,\n    required this.semanticFormatterCallback,\n    super.key,\n  }) : assert(0 <= left, 'left ($left) must be >= 0'),\n       assert(left + 1 == right, 'Left and right should be next to each other.');\n\n  Widget focusableActionDetector({\n    required Map<ShortcutActivator, Intent> shortcuts,\n    required List<Widget> children,\n    required bool focused,\n    required ValueChanged<bool> onFocusChange,\n  }) => Semantics(\n    value: semanticFormatterCallback(controller.regions[left], controller.regions[right]),\n    child: FocusableActionDetector(\n      mouseCursor: cursor,\n      shortcuts: shortcuts,\n      onFocusChange: onFocusChange,\n      actions: {\n        _Up: CallbackAction(\n          onInvoke: (_) => controller.update(left, right, -resizePercentage * (controller.regions[left].extent.total)),\n        ),\n        _Down: CallbackAction(\n          onInvoke: (_) => controller.update(left, right, resizePercentage * (controller.regions[left].extent.total)),\n        ),\n      },\n      child: FFocusedOutline(\n        focused: focused,\n        child: Stack(alignment: AlignmentDirectional.center, children: children),\n      ),\n    ),\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(EnumProperty('type', type))\n      ..add(IntProperty('left', left))\n      ..add(IntProperty('right', right))\n      ..add(DoubleProperty('crossAxisExtent', crossAxisExtent))\n      ..add(DoubleProperty('hitRegionExtent', hitRegionExtent))\n      ..add(PercentProperty('resizePercentage', resizePercentage))\n      ..add(DiagnosticsProperty('cursor', cursor))\n      ..add(ObjectFlagProperty.has('semanticFormatterCallback', semanticFormatterCallback));\n  }\n}\n\n@internal\nclass HorizontalDivider extends Divider {\n  const HorizontalDivider({\n    required super.controller,\n    required super.style,\n    required super.type,\n    required super.left,\n    required super.right,\n    required super.crossAxisExtent,\n    required super.hitRegionExtent,\n    required super.resizePercentage,\n    required super.cursor,\n    required super.semanticFormatterCallback,\n    super.key,\n  });\n\n  @override\n  State<StatefulWidget> createState() => _HorizontalDividerState();\n}\n\nclass _HorizontalDividerState extends State<HorizontalDivider> {\n  bool _focused = false;\n\n  @override\n  Widget build(BuildContext context) => Positioned(\n    left: widget.controller.regions[widget.left].offset.max - (widget.hitRegionExtent / 2),\n    child: widget.focusableActionDetector(\n      shortcuts: const {\n        SingleActivator(LogicalKeyboardKey.arrowLeft): _Up(),\n        SingleActivator(LogicalKeyboardKey.arrowRight): _Down(),\n      },\n      onFocusChange: (focused) => setState(() => _focused = focused),\n      focused: _focused,\n      children: [\n        if (widget.type == FResizableDivider.divider || widget.type == FResizableDivider.dividerWithThumb)\n          ColoredBox(\n            color: widget.style.color,\n            child: SizedBox(height: widget.crossAxisExtent, width: widget.style.width),\n          ),\n        if (widget.type == FResizableDivider.dividerWithThumb)\n          _Thumb(style: widget.style.thumbStyle, icon: FIcons.gripVertical),\n        SizedBox(\n          height: widget.crossAxisExtent,\n          width: widget.hitRegionExtent,\n          child: GestureDetector(\n            onHorizontalDragUpdate: (details) {\n              if (details.delta.dx == 0.0) {\n                return;\n              }\n\n              widget.controller.update(widget.left, widget.right, details.delta.dx);\n              // TODO: haptic feedback\n            },\n            onHorizontalDragEnd: (_) => widget.controller.end(widget.left, widget.right),\n          ),\n        ),\n      ],\n    ),\n  );\n}\n\n@internal\nclass VerticalDivider extends Divider {\n  const VerticalDivider({\n    required super.controller,\n    required super.style,\n    required super.type,\n    required super.left,\n    required super.right,\n    required super.crossAxisExtent,\n    required super.hitRegionExtent,\n    required super.resizePercentage,\n    required super.cursor,\n    required super.semanticFormatterCallback,\n    super.key,\n  });\n\n  @override\n  State<StatefulWidget> createState() => _VerticalDividerState();\n}\n\nclass _VerticalDividerState extends State<VerticalDivider> {\n  bool _focused = false;\n\n  @override\n  Widget build(BuildContext context) => Positioned(\n    top: widget.controller.regions[widget.left].offset.max - (widget.hitRegionExtent / 2),\n    child: widget.focusableActionDetector(\n      shortcuts: const {\n        SingleActivator(LogicalKeyboardKey.arrowUp): _Up(),\n        SingleActivator(LogicalKeyboardKey.arrowDown): _Down(),\n      },\n      onFocusChange: (focused) => setState(() => _focused = focused),\n      focused: _focused,\n      children: [\n        if (widget.type == FResizableDivider.divider || widget.type == FResizableDivider.dividerWithThumb)\n          ColoredBox(\n            color: widget.style.color,\n            child: SizedBox(height: widget.style.width, width: widget.crossAxisExtent),\n          ),\n        if (widget.type == FResizableDivider.dividerWithThumb)\n          _Thumb(style: widget.style.thumbStyle, icon: FIcons.gripHorizontal),\n        SizedBox(\n          height: widget.hitRegionExtent,\n          width: widget.crossAxisExtent,\n          child: GestureDetector(\n            onVerticalDragUpdate: (details) {\n              if (details.delta.dy == 0.0) {\n                return;\n              }\n\n              widget.controller.update(widget.left, widget.right, details.delta.dy);\n              // TODO: haptic feedback\n            },\n            onVerticalDragEnd: (_) => widget.controller.end(widget.left, widget.right),\n          ),\n        ),\n      ],\n    ),\n  );\n}\n\nclass _Thumb extends StatelessWidget {\n  final FResizableDividerThumbStyle style;\n  final IconData icon;\n\n  const _Thumb({required this.style, required this.icon});\n\n  @override\n  Widget build(BuildContext context) => Container(\n    alignment: Alignment.center,\n    decoration: style.decoration,\n    height: style.height,\n    width: style.width,\n    child: Icon(icon, color: style.foregroundColor, size: min(style.height, style.width)),\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('icon', icon));\n  }\n}\n\n/// The appearance of dividers between [FResizableRegion]s.\nenum FResizableDivider {\n  /// No divider.\n  none,\n\n  /// Divider without thumb.\n  divider,\n\n  /// Divider with thumb.\n  dividerWithThumb,\n}\n\n/// The style of the dividers between [FResizableRegion]s.\nclass FResizableDividerStyle with Diagnosticable, _$FResizableDividerStyleFunctions {\n  /// The divider's color.\n  @override\n  final Color color;\n\n  /// The divider's width (thickness). Defaults to `0.5`.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [width] <= 0.\n  @override\n  final double width;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// The divider thumb's style.\n  @override\n  final FResizableDividerThumbStyle thumbStyle;\n\n  /// Creates a [FResizableDividerStyle].\n  FResizableDividerStyle({\n    required this.color,\n    required this.focusedOutlineStyle,\n    required this.thumbStyle,\n    this.width = 0.5,\n  }) : assert(0 < width, 'width ($width) must be > 0');\n}\n\n/// The style of the dividers' thumbs between [FResizableRegion]s.\nclass FResizableDividerThumbStyle with Diagnosticable, _$FResizableDividerThumbStyleFunctions {\n  /// The background color.\n  @override\n  final BoxDecoration decoration;\n\n  /// The foreground color.\n  @override\n  final Color foregroundColor;\n\n  /// The height.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if height] <= 0.\n  @override\n  final double height;\n\n  /// The width.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [width] <= 0.\n  @override\n  final double width;\n\n  /// Creates a [FResizableDividerThumbStyle].\n  FResizableDividerThumbStyle({\n    required this.decoration,\n    required this.foregroundColor,\n    required this.height,\n    required this.width,\n  }) : assert(0 < height, 'height ($height) must be > 0'),\n       assert(0 < width, 'width ($width) must be > 0');\n}\n",
      "resizable": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\nimport 'package:sugar/sugar.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\nimport 'package:forui/src/widgets/resizable/divider.dart';\n\npart 'resizable.design.dart';\n\n/// A resizable allows its children to be resized along either the horizontal or vertical main axis.\n///\n/// Each child is a [FResizableRegion] that has an initial and minimum extent. Setting an initial extent less than the\n/// minimum extent will result in undefined behavior. The children are arranged from top to bottom, or left to right,\n/// depending on the main [axis].\n///\n/// It is recommended that a [FResizable] contains at least 2 [FResizableRegion]s.\n///\n/// See:\n/// * https://forui.dev/docs/layout/resizable for working examples.\n/// * [FResizableStyle] for customizing a resizable's appearance.\nclass FResizable extends StatefulWidget {\n  static String _label(FResizableRegionData left, FResizableRegionData right) =>\n      '${left.extent.current}, ${right.extent.current}';\n\n  /// The controller that manages the resizing of regions. Defaults to [FResizableController.cascade].\n  final FResizableController? controller;\n\n  /// The resizable' style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create resizable\n  /// ```\n  final FResizableStyle Function(FResizableStyle style)? style;\n\n  /// The main axis along which the [children] can be resized.\n  final Axis axis;\n\n  /// The divider between resizable regions. Defaults to [FResizableDivider.dividerWithThumb].\n  final FResizableDivider divider;\n\n  /// The extent of the [children] along the non-resizable axis, in logical pixels. By default, it occupies as much\n  /// space as possible.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [crossAxisExtent] is not positive.\n  final double? crossAxisExtent;\n\n  /// The extent of the gesture's hit region along the resizable axis, in logical pixels.\n  ///\n  /// Hit regions are centered around the dividers between resizable regions.\n  ///\n  /// Defaults to `60` on Android and iOS, and `10` on other platforms.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [hitRegionExtent] <= 0.\n  final double hitRegionExtent;\n\n  /// The percentage of the total extent by which regions are resized when using the keyboard. Defaults to 0.005 (0.5%).\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [resizePercentage] is <= 0 or >= 1.\n  final double resizePercentage;\n\n  /// A callback that formats the semantic label for the resizable. Defaults to announcing the extents of both regions.\n  final String Function(FResizableRegionData first, FResizableRegionData second) semanticFormatterCallback;\n\n  /// Handler called when the resizable regions change.\n  final ValueChanged<List<FResizableRegionData>>? onChange;\n\n  /// The children that may be resized.\n  final List<FResizableRegion> children;\n\n  /// Creates a [FResizable].\n  FResizable({\n    required this.axis,\n    required this.children,\n    this.controller,\n    this.style,\n    this.divider = FResizableDivider.dividerWithThumb,\n    this.crossAxisExtent,\n    this.resizePercentage = 0.005,\n    this.semanticFormatterCallback = _label,\n    this.onChange,\n    double? hitRegionExtent,\n    super.key,\n  }) : assert(crossAxisExtent == null || 0 < crossAxisExtent, 'crossAxisExtent ($crossAxisExtent) must be > 0'),\n       assert(hitRegionExtent == null || 0 < hitRegionExtent, 'hitRegionExtent ($hitRegionExtent) must be > 0'),\n       hitRegionExtent = hitRegionExtent ?? (FTouch.primary ? 60 : 10);\n\n  @override\n  State<StatefulWidget> createState() => _FResizableState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(ObjectFlagProperty.has('style', style))\n      ..add(EnumProperty('axis', axis))\n      ..add(EnumProperty('divider', divider))\n      ..add(DoubleProperty('crossAxisExtent', crossAxisExtent))\n      ..add(DoubleProperty('hitRegionExtent', hitRegionExtent))\n      ..add(PercentProperty('resizePercentage', resizePercentage))\n      ..add(ObjectFlagProperty.has('semanticFormatterCallback', semanticFormatterCallback))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(IterableProperty('children', children));\n  }\n}\n\nclass _FResizableState extends State<FResizable> {\n  late FResizableController _controller = widget.controller ?? FResizableController.cascade();\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _update();\n    _controller.addListener(_onChange);\n  }\n\n  @override\n  void didUpdateWidget(FResizable old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        old.controller?.removeListener(_onChange);\n      }\n\n      _controller = widget.controller ?? FResizableController.cascade();\n      _controller.addListener(_onChange);\n    }\n\n    if (widget.axis != old.axis ||\n        widget.crossAxisExtent != old.crossAxisExtent ||\n        widget.controller != old.controller ||\n        !widget.children.equals(old.children)) {\n      _update();\n    }\n  }\n\n  void _update() {\n    var minOffset = 0.0;\n    final minTotalExtent = widget.children.sum((c) => max(c.minExtent ?? 0, widget.hitRegionExtent), initial: 0.0);\n    final totalExtent = widget.children.sum((c) => c.initialExtent, initial: 0.0);\n    final regions = [\n      for (final (index, region) in widget.children.indexed)\n        FResizableRegionData(\n          index: index,\n          extent: (\n            min: region.minExtent ?? widget.hitRegionExtent,\n            max: totalExtent - minTotalExtent + max(region.minExtent ?? 0, widget.hitRegionExtent),\n            total: totalExtent,\n          ),\n          offset: (min: minOffset, max: minOffset += region.initialExtent),\n        ),\n    ];\n\n    _controller.regions.clear();\n    _controller.regions.addAll(regions);\n  }\n\n  void _onChange() => widget.onChange?.call(_controller.regions);\n\n  @override\n  Widget build(BuildContext context) {\n    assert(\n      _controller.regions.length == widget.children.length,\n      'The number of FResizableData should be equal to the number of children.',\n    );\n\n    final style = widget.style?.call(context.theme.resizableStyle) ?? context.theme.resizableStyle;\n    if (widget.axis == Axis.horizontal) {\n      return SizedBox(\n        height: widget.crossAxisExtent,\n        child: LayoutBuilder(\n          builder: (_, constraints) => ListenableBuilder(\n            listenable: _controller,\n            builder: (_, _) => Stack(\n              children: [\n                Row(\n                  mainAxisSize: MainAxisSize.min,\n                  children: [\n                    for (final (i, child) in widget.children.indexed)\n                      InheritedData(\n                        controller: _controller,\n                        axis: widget.axis,\n                        data: _controller.regions[i],\n                        child: child,\n                      ),\n                  ],\n                ),\n                for (var i = 0; i < widget.children.length - 1; i++)\n                  HorizontalDivider(\n                    controller: _controller,\n                    style: style.horizontalDividerStyle,\n                    type: widget.divider,\n                    left: i,\n                    right: i + 1,\n                    crossAxisExtent: constraints.maxHeight.isFinite ? constraints.maxHeight : widget.crossAxisExtent,\n                    hitRegionExtent: widget.hitRegionExtent,\n                    resizePercentage: widget.resizePercentage,\n                    cursor: SystemMouseCursors.resizeLeftRight,\n                    semanticFormatterCallback: widget.semanticFormatterCallback,\n                  ),\n              ],\n            ),\n          ),\n        ),\n      );\n    } else {\n      return SizedBox(\n        width: widget.crossAxisExtent,\n        child: LayoutBuilder(\n          builder: (_, constraints) => ListenableBuilder(\n            listenable: _controller,\n            builder: (_, _) => Stack(\n              children: [\n                Column(\n                  mainAxisSize: MainAxisSize.min,\n                  children: [\n                    for (final (i, child) in widget.children.indexed)\n                      InheritedData(\n                        controller: _controller,\n                        axis: widget.axis,\n                        data: _controller.regions[i],\n                        child: child,\n                      ),\n                  ],\n                ),\n                for (var i = 0; i < widget.children.length - 1; i++)\n                  VerticalDivider(\n                    controller: _controller,\n                    style: style.verticalDividerStyle,\n                    type: widget.divider,\n                    left: i,\n                    right: i + 1,\n                    crossAxisExtent: constraints.maxWidth.isFinite ? constraints.maxWidth : widget.crossAxisExtent,\n                    hitRegionExtent: widget.hitRegionExtent,\n                    resizePercentage: widget.resizePercentage,\n                    cursor: SystemMouseCursors.resizeUpDown,\n                    semanticFormatterCallback: widget.semanticFormatterCallback,\n                  ),\n              ],\n            ),\n          ),\n        ),\n      );\n    }\n  }\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeListener(_onChange);\n    }\n    super.dispose();\n  }\n}\n\n/// A [FResizable]'s style.\nclass FResizableStyle with Diagnosticable, _$FResizableStyleFunctions {\n  /// The horizontal divider style.\n  @override\n  final FResizableDividerStyle horizontalDividerStyle;\n\n  /// The vertical divider style.\n  @override\n  final FResizableDividerStyle verticalDividerStyle;\n\n  /// Creates a [FResizableStyle].\n  FResizableStyle({required this.horizontalDividerStyle, required this.verticalDividerStyle});\n\n  /// Creates a [FResizableStyle] that inherits its properties.\n  FResizableStyle.inherit({required FColors colors, required FStyle style})\n    : this(\n        horizontalDividerStyle: FResizableDividerStyle(\n          color: colors.border,\n          focusedOutlineStyle: style.focusedOutlineStyle,\n          thumbStyle: FResizableDividerThumbStyle(\n            decoration: BoxDecoration(color: colors.border, borderRadius: style.borderRadius),\n            foregroundColor: colors.foreground,\n            height: 20,\n            width: 10,\n          ),\n        ),\n        verticalDividerStyle: FResizableDividerStyle(\n          color: colors.border,\n          focusedOutlineStyle: style.focusedOutlineStyle,\n          thumbStyle: FResizableDividerThumbStyle(\n            decoration: BoxDecoration(color: colors.border, borderRadius: style.borderRadius),\n            foregroundColor: colors.foreground,\n            height: 10,\n            width: 20,\n          ),\n        ),\n      );\n}\n\n@internal\nclass InheritedData extends InheritedWidget {\n  static InheritedData of(BuildContext context) {\n    assert(debugCheckHasAncestor<InheritedData>('$FResizable', context));\n    return context.dependOnInheritedWidgetOfExactType<InheritedData>()!;\n  }\n\n  final FResizableController controller;\n  final Axis axis;\n  final FResizableRegionData data;\n\n  const InheritedData({\n    required this.controller,\n    required this.axis,\n    required this.data,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(InheritedData old) => controller != old.controller || axis != old.axis || data != old.data;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(EnumProperty('axis', axis))\n      ..add(DiagnosticsProperty('data', data));\n  }\n}\n",
      "resizable_controller": "import 'dart:collection';\n\nimport 'package:sugar/collection_aggregate.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/doubles.dart';\nimport 'package:forui/src/widgets/resizable/resizable_region_data.dart';\n\n/// A controller that manages the resizing of regions in a [FResizable].\nabstract interface class FResizableController extends FChangeNotifier {\n  /// The resizable regions. The regions are ordered from top to bottom, or left to right, depending on the resizable\n  /// axis.\n  ///\n  /// ## Contract\n  /// Modifying the regions outside of [update] and [end] will result in undefined behavior.\n  final List<FResizableRegionData> regions = [];\n\n  /// The minimum velocity, inclusive, of a drag gesture for haptic feedback to be performed on collision between two\n  /// regions, defaults to 6.5.\n  ///\n  /// Setting it to `null` disables haptic feedback while setting it to 0 will cause haptic feedback to always be\n  /// performed.\n  ///\n  /// ## Contract\n  /// [_hapticFeedbackVelocity] should be a positive, finite number. It will otherwise\n  /// result in undefined behavior.\n  final double _hapticFeedbackVelocity = 6.5; // ignore: unused_field, TODO: haptic feedback\n\n  bool _haptic = false;\n\n  FResizableController._();\n\n  /// Creates a [FResizableController].\n  ///\n  /// [onResizeUpdate] is called **while** a resizable region and its neighbours are being resized. Most users should\n  /// prefer [onResizeEnd], which is called only after the regions have been resized.\n  ///\n  /// [onResizeEnd] is called after a resizable region and its neighbours have been resized.\n  ///\n  /// See https://forui.dev/docs/layout/resizable#no-cascading for a working example.\n  factory FResizableController({\n    void Function(List<FResizableRegionData> resized)? onResizeUpdate,\n    void Function(List<FResizableRegionData> resized)? onResizeEnd,\n  }) = _ResizableController;\n\n  /// Creates a [FResizableController] that cascades shrinking of a region below its minimum extent to its neighbours.\n  ///\n  /// [onResizeUpdate] is called **while** a resizable region and its neighbours are being resized. Most users should\n  /// prefer [onResizeEnd], which is called only after the regions have been resized.\n  ///\n  /// [onResizeEnd] is called after a resizable region and its neighbours have been resized.\n  ///\n  /// See https://forui.dev/docs/layout/resizable for a working example.\n  factory FResizableController.cascade({\n    void Function(List<FResizableRegionData> resized)? onResizeUpdate,\n    void Function(UnmodifiableListView<FResizableRegionData> all)? onResizeEnd,\n  }) = _CascadeController;\n\n  /// Updates the regions at the given indexes in addition to their neighbours. Returns true if haptic feedback should\n  /// be performed.\n  bool update(int left, int right, double delta);\n\n  /// Notifies the region at the indexes that they and their neighbours have been resized.\n  void end(int left, int right);\n}\n\n/// A non-cascading [FResizableController].\nfinal class _ResizableController extends FResizableController {\n  final void Function(List<FResizableRegionData> resized)? onResizeUpdate;\n  final void Function(List<FResizableRegionData> resized)? onResizeEnd;\n\n  _ResizableController({this.onResizeUpdate, this.onResizeEnd}) : super._();\n\n  @override\n  bool update(int left, int right, double delta) {\n    final (shrink, expand, lhs) = switch (delta) {\n      < 0 => (regions[left], regions[right], false),\n      _ => (regions[right], regions[left], true),\n    };\n\n    // We always want to resize the shrunken region first. This allows us to remove any overlaps caused by shrinking a\n    // region beyond the minimum size.\n    final (shrunk, translated) = shrink.update(delta, lhs: lhs);\n    if (shrink.offset != shrunk.offset) {\n      final (expanded, _) = expand.update(translated, lhs: !lhs);\n      regions[shrunk.index] = shrunk;\n      regions[expanded.index] = expanded;\n\n      assert(\n        regions.sum((r) => r.extent.current, initial: 0.0) == regions[0].extent.total,\n        'Current total extent: ${regions.sum((r) => r.extent.current, initial: 0.0)} != initial total extent: '\n        '${regions[0].extent.total}. This is likely a bug in Forui. Please file a bug report: '\n        'https://github.com/forus-labs/forui/issues/new?template=bug_report.md',\n      );\n\n      if (onResizeUpdate case final onResizeUpdate?) {\n        onResizeUpdate([shrunk, expanded]);\n      }\n      _haptic = true;\n      notifyListeners();\n\n      return false;\n    }\n\n    if (_haptic) {\n      _haptic = false;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  @override\n  void end(int left, int right) {\n    if (onResizeEnd case final onResizeEnd?) {\n      onResizeEnd([regions[left], regions[right]]);\n    }\n  }\n}\n\n/// A cascading [FResizableController].\nfinal class _CascadeController extends FResizableController {\n  final void Function(List<FResizableRegionData> resized)? onResizeUpdate;\n  final void Function(UnmodifiableListView<FResizableRegionData> all)? onResizeEnd;\n\n  _CascadeController({this.onResizeUpdate, this.onResizeEnd}) : super._();\n\n  @override\n  bool update(int left, int right, double delta) {\n    final (shrinks, expand, lhs) = switch (delta) {\n      < 0 => (regions.sublist(0, right).reversed.toList(), regions[right], false),\n      _ => (regions.sublist(right), regions[left], true),\n    };\n\n    // We always want to resize the shrunken region first. This allows us to remove any overlaps caused by shrinking a\n    // region beyond the minimum size.\n    late FResizableRegionData shrunk;\n    late double translated;\n\n    // Shrink affected regions without updating offsets.\n    final shrunks = <FResizableRegionData>[];\n    for (final shrink in shrinks) {\n      (shrunk, translated) = shrink.update(delta, lhs: lhs);\n      shrunks.add(shrunk);\n\n      // Currently shrunk region is not at minimum size. No need to continue cascade.\n      if (translated != 0) {\n        break;\n      }\n    }\n\n    // All shrunk regions are already at minimum size. No need to rebuild.\n    if (translated == 0) {\n      final haptic = _haptic;\n      _haptic = false;\n      return haptic;\n    }\n\n    // Update all affected regions' offsets.\n    final (expanded, _) = expand.update(translated, lhs: !lhs);\n    var (:min, :max) = expanded.offset;\n\n    regions[expanded.index] = expanded;\n    final moved = onResizeUpdate == null ? null : [expanded];\n\n    if (lhs) {\n      for (final region in shrunks) {\n        final updated = region.copyWith(minOffset: max, maxOffset: max + region.extent.current);\n        (:min, :max) = updated.offset;\n\n        regions[updated.index] = updated;\n        moved?.add(updated);\n      }\n    } else {\n      for (final region in shrunks) {\n        final updated = region.copyWith(minOffset: min - region.extent.current, maxOffset: min);\n        (:min, :max) = updated.offset;\n\n        regions[updated.index] = updated;\n        moved?.add(updated);\n      }\n    }\n\n    assert(\n      regions.sum((r) => r.extent.current, initial: 0.0).around(regions[0].extent.total),\n      'Current total size: ${regions.sum((r) => r.extent.current, initial: 0.0)} != initial total size: ${regions[0].extent.total}. '\n      'This is likely a bug in Forui. Please file a bug report: https://github.com/forus-labs/forui/issues/new?template=bug_report.md',\n    );\n\n    onResizeUpdate?.call(moved!);\n    _haptic = true;\n    notifyListeners();\n\n    return false;\n  }\n\n  @override\n  void end(int left, int right) {\n    if (onResizeEnd case final onResizeEnd?) {\n      onResizeEnd(UnmodifiableListView(regions));\n    }\n  }\n}\n",
      "resizable_region": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/doubles.dart';\nimport 'package:forui/src/widgets/resizable/resizable.dart';\n\n/// A resizable region that can be resized along the parent [FResizable]'s axis. It should always be in a [FResizable].\n///\n/// See https://forui.dev/docs/layout/resizable for working examples.\nclass FResizableRegion extends StatelessWidget {\n  /// The initial extent along the resizable axis, in logical pixels.\n  ///\n  /// ## Contract\n  /// Throws a [AssertionError] if:\n  /// * [initialExtent] is not positive\n  /// * [initialExtent] < [minExtent]\n  final double initialExtent;\n\n  /// The minimum extent along the resizable axis, in logical pixels.\n  ///\n  /// The effective minimum extent is either the given minimum extent or [FResizable.hitRegionExtent], whichever is\n  /// larger. Defaults to [FResizable.hitRegionExtent] if not given.\n  final double? minExtent;\n\n  /// The builder used to create a child to display in this region.\n  final ValueWidgetBuilder<FResizableRegionData> builder;\n\n  /// A height/width-independent widget which is passed back to the [builder].\n  ///\n  /// This argument is optional and can be null if the entire widget subtree the [builder] builds depends on the size of\n  /// the region.\n  final Widget? child;\n\n  /// Creates a [FResizableRegion].\n  FResizableRegion({required this.initialExtent, required this.builder, this.minExtent, this.child, super.key})\n    : assert(0 < initialExtent, 'initialExtent ($initialExtent) must be > 0'),\n      assert(minExtent == null || 0 < minExtent, 'minExtent ($minExtent) must be > 0'),\n      assert(\n        minExtent == null || minExtent.lessOrAround(initialExtent),\n        'minExtent ($minExtent) must be < initialExtent ($initialExtent)',\n      );\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedData(:axis, :data) = InheritedData.of(context);\n    return Semantics(\n      container: true,\n      child: GestureDetector(\n        child: switch (axis) {\n          Axis.horizontal => SizedBox(width: data.extent.current, child: builder(context, data, child)),\n          Axis.vertical => SizedBox(height: data.extent.current, child: builder(context, data, child)),\n        },\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DoubleProperty('initialExtent', initialExtent))\n      ..add(DoubleProperty('minExtent', minExtent))\n      ..add(ObjectFlagProperty.has('builder', builder));\n  }\n}\n",
      "resizable_region_data": "import 'package:flutter/foundation.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/doubles.dart';\n\n/// A [FResizableRegion]'s data.\nfinal class FResizableRegionData with Diagnosticable {\n  /// The resizable region's index.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [index] < 0.\n  final int index;\n\n  /// This region's minimum and maximum extent along the main resizable axis, in logical pixels.\n  ///\n  /// The minimum extent is determined by [FResizableRegion.minExtent].\n  /// The maximum extent is determined by the [FResizable]'s total extent - the minimum extent of all regions.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * min <= 0\n  /// * max <= min\n  final ({double min, double current, double max, double total}) extent;\n\n  /// This region's current minimum and maximum offset along the main resizable axis, in logical pixels\n  ///\n  /// Both offsets are relative to the top/left side of the parent [FResizable].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * min < 0\n  /// * max <= min\n  /// * `extent.total` <= `offset.max`\n  final ({double min, double max}) offset;\n\n  /// Creates a [FResizableRegionData].\n  FResizableRegionData({\n    required this.index,\n    required ({double min, double max, double total}) extent,\n    required this.offset,\n  }) : assert(0 <= index, 'index ($index) must be >= 0'),\n       assert(0 < extent.min, 'extent.min (${extent.min}) must be > 0'),\n       assert(extent.min < extent.max, 'min ${extent.min} must be < max ${extent.max}'),\n       assert(extent.max <= extent.total, 'extent.max (${extent.max}) must be <= extent.total (${extent.total})'),\n       assert(0 <= offset.min, 'offset.min ${offset.min} must be >= 0'),\n       assert(offset.min < offset.max, 'offset.min (${offset.min}) must be < offset.max (${offset.max})'),\n       assert(\n         0.0.lessOrAround(offset.max - offset.min) && (offset.max - offset.min).lessOrAround(extent.max),\n         'Current extent (${offset.max - offset.min}) must be >= 0 and <= extent.max (${extent.max})',\n       ),\n       extent = (min: extent.min, current: offset.max - offset.min, max: extent.max, total: extent.total);\n\n  /// Returns a copy of this [FResizableRegionData] with the given fields replaced by the new values.\n  @useResult\n  FResizableRegionData copyWith({\n    int? index,\n    double? minExtent,\n    double? maxExtent,\n    double? minOffset,\n    double? maxOffset,\n  }) => FResizableRegionData(\n    index: index ?? this.index,\n    extent: (min: minExtent ?? extent.min, max: maxExtent ?? extent.max, total: extent.total),\n    offset: (min: minOffset ?? offset.min, max: maxOffset ?? offset.max),\n  );\n\n  /// The offsets as a percentage of the parent [FResizable]'s size.\n  ///\n  /// For example, if the offsets are `(200, 400)`, and the [FResizable]'s size is 500, [offsetPercentage] will be\n  /// `(0.4, 0.8)`.\n  ({double min, double max}) get offsetPercentage => (min: offset.min / extent.total, max: offset.max / extent.total);\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is FResizableRegionData &&\n          runtimeType == other.runtimeType &&\n          index == other.index &&\n          extent == other.extent &&\n          offset == other.offset;\n\n  @override\n  int get hashCode => index.hashCode ^ extent.hashCode ^ offset.hashCode;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(IntProperty('index', index))\n      ..add(StringProperty('extent', extent.toString()))\n      ..add(StringProperty('offset', offset.toString()))\n      ..add(StringProperty('offsetPercentage', offsetPercentage.toString()));\n  }\n}\n\n@internal\nextension UpdatableResizableRegionData on FResizableRegionData {\n  /// Returns a copy of this data with an updated extent, and an offset with any shrinkage beyond the minimum\n  /// height/width removed.\n  ///\n  /// This method assumes that shrinking regions are computed before expanding regions.\n  @useResult\n  (FResizableRegionData, double translated) update(double delta, {required bool lhs}) {\n    var (:min, :max) = offset;\n    lhs ? min += delta : max += delta;\n    final newExtent = max - min;\n\n    assert(0 <= min, 'min ($min) must be >= 0');\n    assert(newExtent.lessOrAround(extent.max), '$newExtent must be < ${extent.max}.');\n\n    if (extent.min <= newExtent) {\n      return (copyWith(minOffset: min, maxOffset: max), delta);\n    }\n\n    // In theory, the translation isn't accurate when performing cascading resizes. Given a sufficiently large delta,\n    // the returned translation will be large enough to cancel out the delta and cause the cascading resize to end\n    // prematurely.\n    //\n    // This isn't an issue in practice since a subsequent delta will be emitted out almost immediately after the first\n    // delta.\n    //\n    // It isn't ideal but it works and I'm too dumb & lazy to address this issue properly.\n    if (lhs) {\n      return (\n        extent.min == extent.current ? this : copyWith(minOffset: max - extent.min),\n        delta + newExtent - extent.min,\n      );\n    } else {\n      return (\n        extent.min == extent.current ? this : copyWith(maxOffset: min + extent.min),\n        delta - newExtent + extent.min,\n      );\n    }\n  }\n}\n"
    },
    "Select": {
      "select_controller": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n@internal\nclass InheritedSelectController<T> extends InheritedWidget {\n  static InheritedSelectController<T> of<T>(BuildContext context) {\n    assert(\n      debugCheckHasAncestor<InheritedSelectController<T>>('${FSelect<T>}/${FMultiSelect<T>}', context, generic: true),\n    );\n    return context.dependOnInheritedWidgetOfExactType<InheritedSelectController<T>>()!;\n  }\n\n  final FPopoverController popover;\n  final bool Function(T) contains;\n  final bool Function(T) focus;\n  final ValueChanged<T> onPress;\n\n  const InheritedSelectController({\n    required this.popover,\n    required this.contains,\n    required this.focus,\n    required this.onPress,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(InheritedSelectController<T> old) =>\n      popover != old.popover || contains != old.contains || focus != old.focus || onPress != old.onPress;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('popover', popover))\n      ..add(ObjectFlagProperty.has('contains', contains))\n      ..add(ObjectFlagProperty.has('focus', focus))\n      ..add(ObjectFlagProperty.has('onPress', onPress));\n  }\n}\n\n/// The [FSelect]'s controller.\nclass FSelectController<T> extends FValueNotifier<T?> {\n  /// The controller for the popover.\n  ///\n  /// ## Contract\n  /// Manually disposing this controller is undefined behavior. Dispose this [FSelectController] instead.\n  final FPopoverController popover;\n\n  /// True if the items in the select can toggled (unselected). Defaults to false.\n  final bool toggleable;\n\n  /// Creates a [FSelectController].\n  FSelectController({\n    required TickerProvider vsync,\n    T? value,\n    this.toggleable = false,\n    FPopoverMotion popoverMotion = const FPopoverMotion(),\n  }) : popover = FPopoverController(vsync: vsync, motion: popoverMotion),\n       super(value);\n\n  @override\n  set value(T? value) => super.value = toggleable && super.value == value ? null : value;\n\n  @override\n  void dispose() {\n    popover.dispose();\n    super.dispose();\n  }\n}\n\n/// The [FMultiSelect]'s controller.\nclass FMultiSelectController<T> extends FMultiValueNotifier<T> {\n  /// The controller for the popover.\n  ///\n  /// ## Contract\n  /// Manually disposing this controller is undefined behavior. Dispose this [FSelectController] instead.\n  final FPopoverController popover;\n\n  /// Creates a [FMultiSelectController].\n  FMultiSelectController({\n    required TickerProvider vsync,\n    super.min,\n    super.max,\n    super.value,\n    FPopoverMotion popoverMotion = const FPopoverMotion(),\n  }) : popover = FPopoverController(vsync: vsync, motion: popoverMotion);\n\n  @override\n  void dispose() {\n    popover.dispose();\n    super.dispose();\n  }\n}\n",
      "select_item": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/select/content/content.dart';\nimport 'package:forui/src/widgets/select/select_controller.dart';\n\npart 'select_item.design.dart';\n\n/// A marker interface which denotes that mixed-in widgets can be used in a [FSelect].\nmixin FSelectItemMixin on Widget {}\n\n/// A section in a [FSelect] that can contain multiple [FSelectItem]s.\nclass FSelectSection<T> extends StatelessWidget with FSelectItemMixin {\n  /// The style. Defaults to the [FSelectSectionStyle] inherited from the parent [FSelect].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create select-section\n  /// ```\n  final FSelectSectionStyle Function(FSelectSectionStyle style)? style;\n\n  /// True if the section is enabled. Disabled sections cannot be selected, and is skipped during traversal.\n  ///\n  /// Defaults to inheriting from the [FSelect].\n  final bool? enabled;\n\n  /// The divider style. Defaults to the [FItemDivider] inherited from the parent [FSelect]. Defaults to\n  /// [FItemDivider.none].\n  final FItemDivider divider;\n\n  /// The label.\n  final Widget label;\n\n  /// The nested [FSelectItem]s.\n  final List<FSelectItem<T>> children;\n\n  /// Creates a [FSelectSection] from the given [items].\n  ///\n  /// For more control over the items' appearances, use [FSelectSection.rich].\n  FSelectSection({\n    required Widget label,\n    required Map<String, T> items,\n    FSelectSectionStyle Function(FSelectSectionStyle style)? style,\n    bool? enabled,\n    FItemDivider divider = FItemDivider.none,\n    Key? key,\n  }) : this.rich(\n         label: label,\n         children: [for (final e in items.entries) FSelectItem<T>(title: Text(e.key), value: e.value)],\n         style: style,\n         enabled: enabled,\n         divider: divider,\n         key: key,\n       );\n\n  /// Creates a [FSelectSection] with the given [children].\n  const FSelectSection.rich({\n    required this.label,\n    required this.children,\n    this.style,\n    this.enabled,\n    this.divider = FItemDivider.none,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final content = ContentData.of<T>(context);\n    final enabled = this.enabled ?? content.enabled;\n    final style = this.style?.call(content.style) ?? content.style;\n    final itemStyle = style.itemStyle.call(context);\n\n    return ContentData<T>(\n      style: style,\n      enabled: enabled,\n      first: false,\n      ensureVisible: content.ensureVisible,\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          DefaultTextStyle.merge(\n            style: style.labelTextStyle.resolve({if (!enabled) WidgetState.disabled}),\n            child: Padding(padding: style.labelPadding, child: label),\n          ),\n          // There is an edge case where a non-first, enabled child of a disabled section will not be auto-focused.\n          // No feasible solution that doesn't involve a lot of complexity exists.\n          if (children.firstOrNull case final first?)\n            ContentData<T>(\n              style: style,\n              first: content.first,\n              enabled: enabled,\n              ensureVisible: content.ensureVisible,\n              child: FInheritedItemData.merge(\n                style: itemStyle,\n                divider: divider,\n                index: 0,\n                last: children.length == 1,\n                child: first,\n              ),\n            ),\n          for (final (i, child) in children.indexed.skip(1))\n            FInheritedItemData.merge(\n              style: itemStyle,\n              divider: divider,\n              index: i,\n              last: i == children.length - 1,\n              child: child,\n            ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'))\n      ..add(EnumProperty('divider', divider));\n  }\n}\n\n/// A [FSelectSection]'s style.\nclass FSelectSectionStyle with Diagnosticable, _$FSelectSectionStyleFunctions {\n  /// The enabled label's text style.\n  ///\n  /// Supported states:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<TextStyle> labelTextStyle;\n\n  /// The padding around the label. Defaults to `EdgeInsetsDirectional.only(start: 15, top: 7.5, bottom: 7.5, end: 10)`.\n  @override\n  final EdgeInsetsGeometry labelPadding;\n\n  /// The divider's style.\n  ///\n  /// Supported states:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<Color> dividerColor;\n\n  /// The divider's width.\n  @override\n  final double dividerWidth;\n\n  /// The section's items' style.\n  @override\n  final FItemStyle itemStyle;\n\n  /// Creates a [FSelectSectionStyle].\n  FSelectSectionStyle({\n    required this.labelTextStyle,\n    required this.dividerColor,\n    required this.dividerWidth,\n    required this.itemStyle,\n    this.labelPadding = const EdgeInsetsDirectional.only(start: 15, top: 7.5, bottom: 7.5, end: 10),\n  });\n\n  /// Creates a [FSelectSectionStyle] that inherits its properties.\n  factory FSelectSectionStyle.inherit({\n    required FColors colors,\n    required FStyle style,\n    required FTypography typography,\n  }) {\n    const padding = EdgeInsetsDirectional.only(start: 11, top: 7.5, bottom: 7.5, end: 6);\n    final iconStyle = FWidgetStateMap({\n      WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 15),\n      WidgetState.any: IconThemeData(color: colors.primary, size: 15),\n    });\n    final textStyle = FWidgetStateMap({\n      WidgetState.disabled: typography.sm.copyWith(color: colors.disable(colors.primary)),\n      WidgetState.any: typography.sm.copyWith(color: colors.primary),\n    });\n\n    return FSelectSectionStyle(\n      labelTextStyle: FWidgetStateMap({\n        WidgetState.disabled: typography.sm.copyWith(\n          color: colors.disable(colors.primary),\n          fontWeight: FontWeight.w600,\n        ),\n        WidgetState.any: typography.sm.copyWith(color: colors.primary, fontWeight: FontWeight.w600),\n      }),\n      dividerColor: FWidgetStateMap.all(colors.border),\n      dividerWidth: style.borderWidth,\n      itemStyle: FItemStyle(\n        backgroundColor: FWidgetStateMap.all(null),\n        decoration: FWidgetStateMap({\n          ~WidgetState.disabled & (WidgetState.focused | WidgetState.hovered | WidgetState.pressed): BoxDecoration(\n            color: colors.secondary,\n            borderRadius: style.borderRadius,\n          ),\n        }),\n        contentStyle: FItemContentStyle.inherit(colors: colors, typography: typography).copyWith(\n          padding: padding,\n          prefixIconStyle: iconStyle,\n          prefixIconSpacing: 10,\n          titleTextStyle: textStyle,\n          titleSpacing: 4,\n          subtitleTextStyle: FWidgetStateMap({\n            WidgetState.disabled: typography.xs.copyWith(color: colors.disable(colors.mutedForeground)),\n            WidgetState.any: typography.xs.copyWith(color: colors.mutedForeground),\n          }),\n          suffixIconStyle: FWidgetStateMap({\n            WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 15),\n            WidgetState.any: IconThemeData(color: colors.primary, size: 15),\n          }),\n        ),\n        rawItemContentStyle: FRawItemContentStyle(\n          padding: padding,\n          prefixIconStyle: iconStyle,\n          childTextStyle: textStyle,\n        ),\n        tappableStyle: style.tappableStyle.copyWith(motion: FTappableMotion.none),\n        focusedOutlineStyle: null,\n      ),\n    );\n  }\n}\n\n/// A selectable item in a [FSelect] that can optionally be nested in a [FSelectSection].\nabstract class FSelectItem<T> extends StatefulWidget with FSelectItemMixin {\n  /// The style. Defaults to the [FItemStyle] inherited from the parent [FSelectSection] or [FSelect].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create select-section\n  /// ```\n  final FItemStyle Function(FItemStyle style)? style;\n\n  /// The value.\n  final T value;\n\n  /// True if the item is enabled. Disabled items cannot be selected, and is skipped during traversal.\n  ///\n  /// Defaults to the value inherited from the parent [FSelectSection] or [FSelect].\n  final bool? enabled;\n\n  /// A prefix.\n  final Widget? prefix;\n\n  /// Creates a [FSelectItem] with a custom [title] and value.\n  const factory FSelectItem({\n    required Widget title,\n    required T value,\n    FItemStyle Function(FItemStyle style)? style,\n    bool? enabled,\n    Widget? prefix,\n    Widget? subtitle,\n    // ignore: avoid_positional_boolean_parameters\n    Widget? Function(BuildContext context, bool selected) suffixBuilder,\n    Key? key,\n  }) = _SelectItem<T>;\n\n  /// Creates a [FSelectItem] with a raw layout.\n  const factory FSelectItem.raw({\n    required Widget child,\n    required T value,\n    FItemStyle Function(FItemStyle style)? style,\n    bool? enabled,\n    Widget? prefix,\n    Key? key,\n  }) = _RawSelectItem<T>;\n\n  const FSelectItem._({required this.value, this.style, this.enabled, this.prefix, super.key});\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('value', value))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'));\n  }\n}\n\nabstract class _State<W extends FSelectItem<T>, T> extends State<W> {\n  late final _focus = FocusNode(debugLabel: widget.value.toString());\n\n  @override\n  void initState() {\n    super.initState();\n\n    // This is hacky but I'm not sure how to properly do this.\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      if (!mounted) {\n        return;\n      }\n\n      final InheritedSelectController(:focus, :onPress) = InheritedSelectController.of<T>(context);\n      final content = ContentData.of<T>(context);\n      if (focus(widget.value)) {\n        content.ensureVisible(context);\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    _focus.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedSelectController(:popover, :contains, :focus, :onPress) = InheritedSelectController.of<T>(context);\n    final content = ContentData.of<T>(context);\n\n    return _item(\n      context,\n      widget.enabled ?? content.enabled,\n      contains(widget.value),\n      focus(widget.value) || content.first,\n      (delta) {\n        if (delta.added.contains(WidgetState.hovered) ||\n            (!delta.previous.contains(WidgetState.hovered) && delta.added.contains(WidgetState.pressed))) {\n          _focus.requestFocus();\n        } else if (delta.removed.contains(WidgetState.hovered) ||\n            (!delta.current.contains(WidgetState.hovered) && delta.removed.contains(WidgetState.pressed))) {\n          _focus.unfocus();\n        }\n      },\n      () => onPress(widget.value),\n    );\n  }\n\n  Widget _item(\n    BuildContext context,\n    bool enabled,\n    bool selected,\n    bool focused,\n    ValueChanged<FWidgetStatesDelta> onStateChange,\n    VoidCallback onPress,\n  );\n}\n\nclass _SelectItem<T> extends FSelectItem<T> {\n  static Widget? _defaultSuffixBuilder(BuildContext _, bool selected) => selected ? const Icon(FIcons.check) : null;\n\n  final Widget? subtitle;\n  final Widget title;\n\n  // ignore: avoid_positional_boolean_parameters\n  final Widget? Function(BuildContext context, bool selected) suffixBuilder;\n\n  const _SelectItem({\n    required this.title,\n    required super.value,\n    this.subtitle,\n    this.suffixBuilder = _defaultSuffixBuilder,\n    super.style,\n    super.enabled,\n    super.prefix,\n    super.key,\n  }) : super._();\n\n  @override\n  State<_SelectItem<T>> createState() => _SelectItemState<T>();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(ObjectFlagProperty.has('suffixBuilder', suffixBuilder));\n  }\n}\n\nclass _SelectItemState<T> extends _State<_SelectItem<T>, T> {\n  @override\n  Widget _item(\n    BuildContext context,\n    bool enabled,\n    bool selected,\n    bool focused,\n    ValueChanged<FWidgetStatesDelta> onStateChange,\n    VoidCallback onPress,\n  ) => FItem(\n    style: widget.style?.call,\n    enabled: enabled,\n    selected: selected,\n    autofocus: focused,\n    focusNode: _focus,\n    onStateChange: onStateChange,\n    onPress: onPress,\n    prefix: widget.prefix,\n    title: widget.title,\n    subtitle: widget.subtitle,\n    suffix: widget.suffixBuilder(context, selected),\n  );\n}\n\nclass _RawSelectItem<T> extends FSelectItem<T> {\n  final Widget child;\n\n  const _RawSelectItem({required this.child, required super.value, super.style, super.enabled, super.prefix, super.key})\n    : super._();\n\n  @override\n  _RawSelectItemState<T> createState() => _RawSelectItemState<T>();\n}\n\nclass _RawSelectItemState<T> extends _State<_RawSelectItem<T>, T> {\n  @override\n  Widget _item(\n    BuildContext context,\n    bool enabled,\n    bool selected,\n    bool focused,\n    ValueChanged<FWidgetStatesDelta> onStateChange,\n    VoidCallback onPress,\n  ) => FItem.raw(\n    style: widget.style?.call,\n    enabled: enabled,\n    selected: selected,\n    autofocus: focused,\n    focusNode: _focus,\n    onStateChange: onStateChange,\n    onPress: onPress,\n    prefix: widget.prefix,\n    child: widget.child,\n  );\n}\n"
    },
    "SelectGroup": {
      "select_group": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\npart 'select_group.design.dart';\n\n/// A [FSelectGroup]'s controller.\ntypedef FSelectGroupController<T> = FMultiValueNotifier<T>;\n\n/// Represents an item in a [FSelectGroup].\nmixin FSelectGroupItem<T> on Widget {\n  /// The value.\n  T get value;\n}\n\n/// A [FSelectGroup]'s item data. Useful for creating your own [FSelectGroupItem].\nclass FSelectGroupItemData<T> extends InheritedWidget {\n  /// Return the [FSelectGroup]'s item data.\n  static FSelectGroupItemData<T> of<T>(BuildContext context) {\n    assert(debugCheckHasAncestor<FSelectGroupItemData<T>>('${FSelectGroup<T>}', context, generic: true));\n    return context.dependOnInheritedWidgetOfExactType<FSelectGroupItemData<T>>()!;\n  }\n\n  /// The controller.\n  final FSelectGroupController<T> controller;\n\n  /// The style.\n  final FSelectGroupStyle style;\n\n  /// True if the item is selected.\n  final bool selected;\n\n  /// The [FSelectGroup]'s item data.\n  const FSelectGroupItemData({\n    required this.controller,\n    required this.style,\n    required this.selected,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(FSelectGroupItemData old) =>\n      controller != old.controller || style != old.style || selected != old.selected;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('selected', value: selected, ifTrue: 'selected'));\n  }\n}\n\n/// A set of items that are treated as a single selection.\n///\n/// Typically used to group multiple [FCheckbox.grouped]s or [FRadio.grouped]s.\n///\n/// For touch devices, a [FSelectTileGroup] is generally recommended over this.\n///\n/// See:\n/// * https://forui.dev/docs/form/select-group for working examples.\n/// * [FSelectGroupStyle] for customizing a select group's appearance.\nclass FSelectGroup<T> extends FormField<Set<T>> with FFormFieldProperties<Set<T>> {\n  /// The controller.\n  final FSelectGroupController<T> controller;\n\n  /// The style. Defaults to [FThemeData.selectGroupStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create select-group\n  /// ```\n  final FSelectGroupStyle Function(FSelectGroupStyle style)? style;\n\n  @override\n  final Widget? label;\n\n  @override\n  final Widget? description;\n\n  /// The items.\n  final List<FSelectGroupItem<T>> children;\n\n  /// The callback that is called when the value changes.\n  final ValueChanged<Set<T>>? onChange;\n\n  /// The callback that is called when an item is selected.\n  final ValueChanged<(T, bool)>? onSelect;\n\n  /// Creates a [FSelectGroup].\n  FSelectGroup({\n    required this.controller,\n    required this.children,\n    this.style,\n    this.label,\n    this.description,\n    this.onChange,\n    this.onSelect,\n    Widget Function(BuildContext context, String message) errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    super.onSaved,\n    super.onReset,\n    super.validator,\n    super.forceErrorText,\n    super.enabled = true,\n    super.autovalidateMode,\n    super.key,\n  }) : super(\n         initialValue: controller.value,\n         errorBuilder: errorBuilder,\n         builder: (field) {\n           final state = field as _State;\n           final groupStyle = style?.call(state.context.theme.selectGroupStyle) ?? state.context.theme.selectGroupStyle;\n           final formStates = {if (!enabled) WidgetState.disabled, if (state.errorText != null) WidgetState.error};\n\n           return FLabel(\n             axis: Axis.vertical,\n             states: formStates,\n             style: groupStyle,\n             label: label,\n             description: description,\n             error: state.errorText == null ? null : errorBuilder(state.context, state.errorText!),\n             child: Column(\n               children: [\n                 for (final child in children)\n                   Padding(\n                     padding: groupStyle.itemPadding,\n                     child: FSelectGroupItemData<T>(\n                       controller: controller,\n                       style: groupStyle,\n                       selected: controller.contains(child.value),\n                       child: child,\n                     ),\n                   ),\n               ],\n             ),\n           );\n         },\n       );\n\n  @override\n  FormFieldState<Set<T>> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onSelect', onSelect));\n  }\n}\n\nclass _State<T> extends FormFieldState<Set<T>> {\n  @override\n  void initState() {\n    super.initState();\n    widget.controller.addListener(_handleControllerChanged);\n    widget.controller.addValueListener(widget.onChange);\n    widget.controller.addUpdateListener(widget.onSelect);\n  }\n\n  @override\n  void didUpdateWidget(covariant FSelectGroup<T> old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      widget.controller.addListener(_handleControllerChanged);\n      old.controller.removeListener(_handleControllerChanged);\n    }\n\n    old.controller.removeValueListener(old.onChange);\n    old.controller.removeUpdateListener(old.onSelect);\n    widget.controller.addValueListener(widget.onChange);\n    widget.controller.addUpdateListener(widget.onSelect);\n  }\n\n  @override\n  void didChange(Set<T>? value) {\n    super.didChange(value);\n    if (!setEquals(widget.controller.value, value)) {\n      widget.controller.value = value ?? {};\n    }\n  }\n\n  @override\n  void reset() {\n    // Set the controller value before calling super.reset() to let _handleControllerChanged suppress the change.\n    widget.controller.value = widget.initialValue ?? {};\n    super.reset();\n  }\n\n  @override\n  void dispose() {\n    widget.controller\n      ..removeListener(_handleControllerChanged)\n      ..removeValueListener(widget.onChange)\n      ..removeUpdateListener(widget.onSelect);\n    super.dispose();\n  }\n\n  void _handleControllerChanged() {\n    // Suppress changes that originated from within this class.\n    //\n    // In the case where a controller has been passed in to this widget, we register this change listener. In these\n    // cases, we'll also receive change notifications for changes originating from within this class -- for example, the\n    // reset() method. In such cases, the FormField value will already have been set.\n    if (widget.controller.value != value) {\n      didChange(widget.controller.value);\n    }\n  }\n\n  @override\n  FSelectGroup<T> get widget => super.widget as FSelectGroup<T>;\n}\n\n/// [FSelectGroup]'s style.\nclass FSelectGroupStyle extends FLabelStyle with Diagnosticable, _$FSelectGroupStyleFunctions {\n  /// The [FCheckbox]'s style.\n  @override\n  final FCheckboxStyle checkboxStyle;\n\n  /// The [FRadio]'s style.\n  @override\n  final FRadioStyle radioStyle;\n\n  /// The padding surrounding an item. Defaults to `EdgeInsets.symmetric(vertical: 2)`.\n  @override\n  final EdgeInsetsGeometry itemPadding;\n\n  /// Creates a [FSelectGroupStyle].\n  const FSelectGroupStyle({\n    required this.checkboxStyle,\n    required this.radioStyle,\n    required super.labelTextStyle,\n    required super.descriptionTextStyle,\n    required super.errorTextStyle,\n    this.itemPadding = const EdgeInsets.symmetric(vertical: 2),\n    super.labelPadding,\n    super.descriptionPadding,\n    super.errorPadding,\n    super.childPadding,\n  });\n\n  /// Creates a [FSelectGroupStyle] that inherits its properties.\n  factory FSelectGroupStyle.inherit({required FColors colors, required FTypography typography, required FStyle style}) {\n    final vertical = FLabelStyles.inherit(style: style).verticalStyle;\n\n    final labelTextStyle = FWidgetStateMap({\n      WidgetState.disabled: typography.sm.copyWith(color: colors.disable(colors.primary), fontWeight: FontWeight.w500),\n      WidgetState.any: typography.sm.copyWith(color: colors.primary, fontWeight: FontWeight.w500),\n    });\n    final descriptionTextStyle = FWidgetStateMap({\n      WidgetState.disabled: typography.sm.copyWith(color: colors.disable(colors.mutedForeground)),\n      WidgetState.any: typography.sm.copyWith(color: colors.mutedForeground),\n    });\n    final errorTextStyle = typography.sm.copyWith(color: colors.error, fontWeight: FontWeight.w500);\n\n    return FSelectGroupStyle(\n      checkboxStyle: FCheckboxStyle.inherit(colors: colors, style: style).copyWith(\n        labelTextStyle: labelTextStyle,\n        descriptionTextStyle: descriptionTextStyle,\n        errorTextStyle: errorTextStyle,\n      ),\n      radioStyle: FRadioStyle.inherit(colors: colors, style: style).copyWith(\n        labelTextStyle: labelTextStyle,\n        descriptionTextStyle: descriptionTextStyle,\n        errorTextStyle: errorTextStyle,\n      ),\n      labelTextStyle: style.formFieldStyle.labelTextStyle,\n      descriptionTextStyle: style.formFieldStyle.descriptionTextStyle,\n      errorTextStyle: style.formFieldStyle.errorTextStyle,\n      labelPadding: vertical.labelPadding,\n      descriptionPadding: vertical.descriptionPadding,\n      errorPadding: vertical.errorPadding,\n      childPadding: vertical.childPadding,\n    );\n  }\n}\n"
    },
    "SelectTileGroup": {
      "select_tile": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n/// A tile that represents a selection in a [FSelectTileGroup]. It should only be used in a [FSelectTileGroup].\n///\n/// See:\n/// * https://forui.dev/docs/tile/select-tile-group for working examples.\n/// * [FSelectTileGroup] for grouping tiles together.\n/// * [FTileStyle] for customizing a select tile's appearance.\nclass FSelectTile<T> extends StatelessWidget with FTileMixin {\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create tile\n  /// ```\n  final FItemStyle Function(FItemStyle)? style;\n\n  /// The checked icon. Defaults to `FIcon(FIcons.check)`.\n  final Widget? checkedIcon;\n\n  /// The unchecked icon.\n  final Widget? uncheckedIcon;\n\n  /// The title.\n  final Widget title;\n\n  /// The subtitle below the title.\n  final Widget? subtitle;\n\n  /// The details on the right hand side of the title and subtitle.\n  final Widget? details;\n\n  /// {@macro forui.foundation.doc_templates.semanticsLabel}\n  final String? semanticsLabel;\n\n  /// The current value.\n  final T value;\n\n  /// Whether this radio tile is enabled. Defaults to true.\n  final bool? enabled;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// {@macro forui.foundation.FTappable.onHoverChange}\n  final ValueChanged<bool>? onHoverChange;\n\n  /// {@macro forui.foundation.FTappable.onStateChange}\n  final ValueChanged<FWidgetStatesDelta>? onStatesChange;\n\n  /// The shortcuts. Defaults to calling [ActivateIntent].\n  final Map<ShortcutActivator, Intent>? shortcuts;\n\n  /// The actions. Defaults to selecting a tile when [ActivateIntent] is invoked.\n  final Map<Type, Action<Intent>>? actions;\n\n  final Widget? _icon;\n\n  final bool _suffix;\n\n  /// Creates a [FSelectTile] with a prefix check icon.\n  const FSelectTile({\n    required this.title,\n    required this.value,\n    this.style,\n    this.checkedIcon = const Icon(FIcons.check),\n    this.uncheckedIcon = const Icon(FIcons.check, color: Colors.transparent),\n    this.subtitle,\n    this.details,\n    this.semanticsLabel,\n    this.enabled,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStatesChange,\n    this.shortcuts,\n    this.actions,\n    Widget? suffix,\n    super.key,\n  }) : _suffix = false,\n       _icon = suffix;\n\n  /// Creates a [FSelectTile] with a suffix check icon.\n  const FSelectTile.suffix({\n    required this.title,\n    required this.value,\n    this.style,\n    this.checkedIcon = const Icon(FIcons.check),\n    this.uncheckedIcon = const Icon(FIcons.check, color: Colors.transparent),\n    this.subtitle,\n    this.details,\n    this.semanticsLabel,\n    this.enabled,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStatesChange,\n    this.shortcuts,\n    this.actions,\n    Widget? prefix,\n    super.key,\n  }) : _icon = prefix,\n       _suffix = true;\n\n  @override\n  Widget build(BuildContext context) {\n    final FSelectTileData(:controller, :selected) = FSelectTileData.of<T>(context);\n    return FTile(\n      style: style,\n      prefix: switch ((_suffix, selected)) {\n        (true, _) => _icon,\n        (false, true) => checkedIcon,\n        (false, false) => uncheckedIcon,\n      },\n      title: title,\n      subtitle: subtitle,\n      details: details,\n      suffix: switch ((_suffix, selected)) {\n        (false, _) => _icon,\n        (true, true) => checkedIcon,\n        (true, false) => uncheckedIcon,\n      },\n      semanticsLabel: semanticsLabel,\n      enabled: enabled,\n      selected: selected,\n      onPress: () => controller.update(value, add: !selected),\n      autofocus: autofocus,\n      focusNode: focusNode,\n      onFocusChange: onFocusChange,\n      onHoverChange: onHoverChange,\n      onStateChange: onStatesChange,\n      shortcuts: shortcuts,\n      actions: actions,\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(StringProperty('semanticsLabel', semanticsLabel))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onStatesChange', onStatesChange))\n      ..add(DiagnosticsProperty('shortcuts', shortcuts))\n      ..add(DiagnosticsProperty('actions', actions));\n  }\n}\n\n@internal\nclass FSelectTileData<T> extends InheritedWidget with FTileMixin {\n  static FSelectTileData<T> of<T>(BuildContext context) {\n    assert(debugCheckHasAncestor<FSelectTileData<T>>('${FSelectTileGroup<T>}', context, generic: true));\n    return context.dependOnInheritedWidgetOfExactType<FSelectTileData<T>>()!;\n  }\n\n  final FSelectTileGroupController<T> controller;\n  final bool selected;\n\n  const FSelectTileData({required this.controller, required this.selected, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(FSelectTileData old) => controller != old.controller || selected != old.selected;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(FlagProperty('selected', value: selected, ifTrue: 'selected'));\n  }\n}\n",
      "select_tile_group": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/select_tile_group/select_tile.dart';\n\n/// A controller for a [FSelectTileGroup].\ntypedef FSelectTileGroupController<T> = FMultiValueNotifier<T>;\n\n/// A set of tiles that are treated as a single selection.\n///\n/// A [FSelectTileGroup] is internally a [FormField], therefore it can be used in a [Form].\n///\n/// For desktop, a [FSelectGroup] is generally recommended over this.\n///\n/// See:\n/// * https://forui.dev/docs/tile/select-tile-group for working examples.\n/// * [FSelectTile] for a single select tile.\n/// * [FTileGroupStyle] for customizing a select group's appearance.\nclass FSelectTileGroup<T> extends FormField<Set<T>> with FTileGroupMixin, FFormFieldProperties<Set<T>> {\n  /// The controller.\n  final FSelectTileGroupController<T> selectController;\n\n  /// {@macro forui.widgets.FTileGroup.scrollController}\n  final ScrollController? scrollController;\n\n  /// {@macro forui.widgets.FTileGroup.cacheExtent}\n  final double? cacheExtent;\n\n  /// {@macro forui.widgets.FTileGroup.maxHeight}\n  final double maxHeight;\n\n  /// {@macro forui.widgets.FTileGroup.dragStartBehavior}\n  final DragStartBehavior dragStartBehavior;\n\n  /// {@macro forui.widgets.FTileGroup.physics}\n  final ScrollPhysics physics;\n\n  /// The style. Defaults to [FThemeData.tileGroupStyle].\n  final FTileGroupStyle? style;\n\n  /// {@macro forui.widgets.FTileGroup.divider}\n  ///\n  /// Defaults to [FItemDivider.indented].\n  final FItemDivider divider;\n\n  /// The label displayed above the group.\n  ///\n  /// It is not rendered if the group is disabled or part of a [FTileGroup].\n  @override\n  final Widget? label;\n\n  /// The description displayed below the group.\n  ///\n  /// It is not rendered if the group is disabled or part of a [FTileGroup].\n  @override\n  final Widget? description;\n\n  /// {@macro forui.foundation.doc_templates.semanticsLabel}\n  final String? semanticsLabel;\n\n  /// The callback that is called when the value changes.\n  final ValueChanged<Set<T>>? onChange;\n\n  /// The callback that is called when an item is selected.\n  final ValueChanged<(T, bool)>? onSelect;\n\n  /// Creates a [FSelectTileGroup].\n  FSelectTileGroup({\n    required this.selectController,\n    required List<FSelectTile<T>> children,\n    this.scrollController,\n    this.style,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.divider = FItemDivider.indented,\n    this.label,\n    this.description,\n    this.semanticsLabel,\n    this.onChange,\n    this.onSelect,\n    Widget Function(BuildContext context, String message) errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    super.onSaved,\n    super.onReset,\n    super.validator,\n    super.forceErrorText,\n    super.enabled = true,\n    super.autovalidateMode,\n    super.key,\n  }) : super(\n         initialValue: selectController.value,\n         builder: (field) {\n           final state = field as _State;\n           return FTileGroup(\n             scrollController: scrollController,\n             style: style ?? state.context.theme.tileGroupStyle,\n             cacheExtent: cacheExtent,\n             maxHeight: maxHeight,\n             dragStartBehavior: dragStartBehavior,\n             physics: physics,\n             divider: divider,\n             label: label,\n             enabled: enabled,\n             description: description,\n             error: switch (state.errorText) {\n               _ when !enabled => null,\n               final text? => errorBuilder(state.context, text),\n               null => null,\n             },\n             semanticsLabel: semanticsLabel,\n             children: [\n               for (final child in children)\n                 FSelectTileData<T>(\n                   controller: selectController,\n                   selected: selectController.contains(child.value),\n                   child: child,\n                 ),\n             ],\n           );\n         },\n       );\n\n  /// Creates a [FSelectTileGroup] that lazily builds its children.\n  ///\n  /// {@macro forui.widgets.FTileGroup.builder}\n  FSelectTileGroup.builder({\n    required this.selectController,\n    required FSelectTile<T>? Function(BuildContext context, int index) tileBuilder,\n    int? count,\n    this.scrollController,\n    this.style,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.divider = FItemDivider.indented,\n    this.label,\n    this.description,\n    this.semanticsLabel,\n    this.onChange,\n    this.onSelect,\n    Widget Function(BuildContext context, String message) errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    super.onSaved,\n    super.validator,\n    super.forceErrorText,\n    super.enabled = true,\n    super.autovalidateMode,\n    super.key,\n  }) : super(\n         initialValue: selectController.value,\n         errorBuilder: errorBuilder,\n         builder: (field) {\n           final state = field as _State;\n\n           return FTileGroup.builder(\n             scrollController: scrollController,\n             style: style ?? state.context.theme.tileGroupStyle,\n             cacheExtent: cacheExtent,\n             maxHeight: maxHeight,\n             dragStartBehavior: dragStartBehavior,\n             physics: physics,\n             count: count,\n             divider: divider,\n             label: label,\n             enabled: enabled,\n             description: description,\n             error: switch (state.errorText) {\n               _ when !enabled => null,\n               final text? => errorBuilder(state.context, text),\n               null => null,\n             },\n             semanticsLabel: semanticsLabel,\n             tileBuilder: (context, index) {\n               final child = tileBuilder(context, index);\n               return child == null\n                   ? null\n                   : FSelectTileData<T>(\n                       controller: selectController,\n                       selected: selectController.contains(child.value),\n                       child: child,\n                     );\n             },\n           );\n         },\n       );\n\n  @override\n  FormFieldState<Set<T>> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('groupController', selectController))\n      ..add(DiagnosticsProperty('scrollController', scrollController))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DoubleProperty('cacheExtent', cacheExtent))\n      ..add(DoubleProperty('maxHeight', maxHeight))\n      ..add(EnumProperty('dragStartBehavior', dragStartBehavior))\n      ..add(DiagnosticsProperty('physics', physics))\n      ..add(EnumProperty('divider', divider))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder))\n      ..add(StringProperty('semanticsLabel', semanticsLabel))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onSelect', onSelect));\n  }\n}\n\nclass _State<T> extends FormFieldState<Set<T>> {\n  final FocusNode _focus = FocusNode(debugLabel: 'FSelectTileGroup');\n\n  @override\n  void initState() {\n    super.initState();\n    widget.selectController.addListener(_handleControllerChanged);\n    widget.selectController.addValueListener(widget.onChange);\n    widget.selectController.addUpdateListener(widget.onSelect);\n  }\n\n  @override\n  void didUpdateWidget(covariant FSelectTileGroup<T> old) {\n    super.didUpdateWidget(old);\n    if (widget.selectController != old.selectController) {\n      widget.selectController.addListener(_handleControllerChanged);\n      old.selectController.removeListener(_handleControllerChanged);\n    }\n\n    old.selectController.removeValueListener(old.onChange);\n    old.selectController.removeUpdateListener(old.onSelect);\n    widget.selectController.addValueListener(widget.onChange);\n    widget.selectController.addUpdateListener(widget.onSelect);\n  }\n\n  @override\n  void didChange(Set<T>? value) {\n    super.didChange(value);\n    if (!setEquals(widget.selectController.value, value)) {\n      widget.selectController.value = value ?? {};\n    }\n  }\n\n  @override\n  void reset() {\n    // Set the controller value before calling super.reset() to let _handleControllerChanged suppress the change.\n    widget.selectController.value = widget.initialValue ?? {};\n    super.reset();\n  }\n\n  @override\n  void dispose() {\n    widget.selectController\n      ..removeListener(_handleControllerChanged)\n      ..removeValueListener(widget.onChange)\n      ..removeUpdateListener(widget.onSelect);\n    _focus.dispose();\n    super.dispose();\n  }\n\n  void _handleControllerChanged() {\n    // Suppress changes that originated from within this class.\n    //\n    // In the case where a controller has been passed in to this widget, we register this change listener. In these\n    // cases, we'll also receive change notifications for changes originating from within this class -- for example, the\n    // reset() method. In such cases, the FormField value will already have been set.\n    if (!setEquals(widget.selectController.value, value)) {\n      didChange(widget.selectController.value);\n    }\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    // This is a workaround the default FormField.build() function wrapping the child (a SliverList) in a Semantics\n    // which results in:\n    // \"A RenderSemanticsAnnotations expected a child of type RenderBox but received a child of type RenderSliverList.\"\n    //\n    // This behavior was introduced without any prior notice in Flutter 3.32.\n    super.build(context);\n\n    final child = widget.builder(this);\n    if (Form.maybeOf(context)?.widget.autovalidateMode == AutovalidateMode.onUnfocus &&\n            widget.autovalidateMode != AutovalidateMode.always ||\n        widget.autovalidateMode == AutovalidateMode.onUnfocus) {\n      return Focus(\n        canRequestFocus: false,\n        skipTraversal: true,\n        onFocusChange: (value) {\n          if (!value) {\n            validate();\n          }\n        },\n        focusNode: _focus,\n        child: child,\n      );\n    }\n\n    return child;\n  }\n\n  @override\n  FSelectTileGroup<T> get widget => super.widget as FSelectTileGroup<T>;\n}\n"
    },
    "Sheet": {
      "gesture_detector": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\n\n/// The sheet's gesture detector. We use a [RawGestureDetector] instead of a [GestureDetector] because the latter\n/// doesn't allow [DragGestureRecognizer.onlyAcceptDragOnThreshold] to be configured.\n///\n/// This is based on Material's _BottomSheetGestureDetector.\n@internal\nclass SheetGestureDetector extends StatelessWidget {\n  final FLayout layout;\n  final GestureDragStartCallback? onStart;\n  final GestureDragUpdateCallback? onUpdate;\n  final GestureDragEndCallback? onEnd;\n  final Widget child;\n\n  const SheetGestureDetector({\n    required this.layout,\n    required this.onStart,\n    required this.onUpdate,\n    required this.onEnd,\n    required this.child,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext _) {\n    void initialize(DragGestureRecognizer recognizer) {\n      recognizer\n        ..onStart = onStart\n        ..onUpdate = onUpdate\n        ..onEnd = onEnd\n        ..onlyAcceptDragOnThreshold = true;\n    }\n\n    return RawGestureDetector(\n      excludeFromSemantics: true,\n      gestures: {\n        if (layout.vertical)\n          VerticalDragGestureRecognizer: GestureRecognizerFactoryWithHandlers<VerticalDragGestureRecognizer>(\n            () => VerticalDragGestureRecognizer(debugOwner: this),\n            initialize,\n          )\n        else\n          HorizontalDragGestureRecognizer: GestureRecognizerFactoryWithHandlers<HorizontalDragGestureRecognizer>(\n            () => HorizontalDragGestureRecognizer(debugOwner: this),\n            initialize,\n          ),\n      },\n      child: child,\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(EnumProperty('layout', layout))\n      ..add(ObjectFlagProperty.has('onStart', onStart))\n      ..add(ObjectFlagProperty.has('onUpdate', onUpdate))\n      ..add(ObjectFlagProperty.has('onEnd', onEnd));\n  }\n}\n",
      "modal_sheet": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/sheet/sheet.dart';\n\npart 'modal_sheet.design.dart';\n\n/// Shows a modal sheet that appears from the given [side].\n///\n/// A modal sheet is an alternative to a menu or a dialog and prevents the user from interacting with the rest of the\n/// app.\n///\n/// [context] is used to look up the [Navigator] and [FSheetStyle] for the sheet. It is only used when the method is\n/// called. Its corresponding widget can be safely removed from the tree before the sheet is closed.\n///\n/// [useRootNavigator] ensures that the root navigator displays the sheet when `true`. This is useful in the case that a\n/// modal sheet needs to be displayed above all other content but the caller is inside another [Navigator].\n///\n/// [style] defaults to [FSheetStyle] from the closest [FTheme] ancestor.\n///\n/// [mainAxisMaxRatio] represents the main axis's max constraint ratio for the sheet, depending on [side].\n/// Defaults to 9 / 16. The main axis is the width if [side] is [FLayout.ltr] or [FLayout.rtl], and the height if [side]\n/// is [FLayout.ttb] or [FLayout.btt]. Consider setting [mainAxisMaxRatio] to null if this sheet has a scrollable child,\n/// i.e. [ListView], along the main axis, to have the sheet be draggable.\n///\n/// [barrierLabel] defaults to [FLocalizations.barrierLabel].\n///\n/// [transitionAnimationController] can be used to provide a custom [AnimationController] for the sheet's entrance and\n/// exit. Passing a controller will override [FSheetMotion.expandDuration] and [FSheetMotion.collapseDuration].\n///\n/// [onClosing] is called when the sheet begins to close, before the route is popped.\n///\n/// Returns a `Future` that resolves to the value (if any) that was passed to [Navigator.pop] when the modal sheet was\n/// closed.\n///\n/// ## CLI\n/// To generate and customize this widget's style:\n///\n/// ```shell\n/// dart run forui style create sheet\n/// ```\n///\n/// See:\n/// * https://forui.dev/docs/overlay/sheet for working examples.\n/// * [showFPersistentSheet] for displaying a sheet above the current widget.\n/// * [FModalSheetRoute] for more information about the various arguments.\n/// * [FSheetStyle] for customizing a switch's appearance.\n/// * [DraggableScrollableSheet], creates a bottom sheet that grows and then becomes scrollable once it reaches its\n///   maximum size.\nFuture<T?> showFSheet<T>({\n  required BuildContext context,\n  required WidgetBuilder builder,\n  required FLayout side,\n  bool useRootNavigator = false,\n  FModalSheetStyle Function(FModalSheetStyle style)? style,\n  double? mainAxisMaxRatio = 9 / 16,\n  String? barrierLabel,\n  bool barrierDismissible = true,\n  BoxConstraints constraints = const BoxConstraints(),\n  bool draggable = true,\n  RouteSettings? routeSettings,\n  AnimationController? transitionAnimationController,\n  Offset? anchorPoint,\n  bool useSafeArea = false,\n  VoidCallback? onClosing,\n}) {\n  assert(debugCheckHasMediaQuery(context));\n\n  final navigator = Navigator.of(context, rootNavigator: useRootNavigator);\n  final localizations = FLocalizations.of(context) ?? FDefaultLocalizations();\n\n  return navigator.push(\n    FModalSheetRoute<T>(\n      style: style?.call(context.theme.modalSheetStyle) ?? context.theme.modalSheetStyle,\n      side: side,\n      builder: builder,\n      mainAxisMaxRatio: mainAxisMaxRatio,\n      capturedThemes: InheritedTheme.capture(from: context, to: navigator.context),\n      barrierOnTapHint: localizations.barrierOnTapHint(localizations.sheetSemanticsLabel),\n      barrierLabel: barrierLabel ?? localizations.barrierLabel,\n      barrierDismissible: barrierDismissible,\n      constraints: constraints,\n      draggable: draggable,\n      settings: routeSettings,\n      transitionAnimationController: transitionAnimationController,\n      anchorPoint: anchorPoint,\n      useSafeArea: useSafeArea,\n      onClosing: onClosing,\n    ),\n  );\n}\n\n/// A route that represents a modal sheet. [showFSheet] should be preferred in most cases.\n///\n/// A modal sheet is an alternative to a menu or a dialog and prevents the user from interacting with the rest of the\n/// app.\n///\n/// A closely related widget is a persistent sheet, which shows information that supplements the primary content of the\n/// app without preventing the user from interacting with the app.\n///\n/// See:\n/// * https://forui.dev/docs/overlay/sheet for working examples.\n/// * [FSheetStyle] for customizing a switch's appearance.\n/// * [showFSheet] for displaying a FModalSheetRoute.\n/// * [showFPersistentSheet] for displaying a sheet above the current widget.\n/// * [DraggableScrollableSheet], creates a bottom sheet that grows and then becomes scrollable once it reaches its\n///   maximum size.\n///\n/// This is based on Material's `ModalBottomSheetRoute`.\nclass FModalSheetRoute<T> extends PopupRoute<T> {\n  /// The style.\n  final FModalSheetStyle style;\n\n  /// The side.\n  final FLayout side;\n\n  /// Stores a list of captured [InheritedTheme]s that are wrapped around the sheet.\n  ///\n  /// Consider setting this attribute when the [FModalSheetRoute] is created through [Navigator.push] and its friends.\n  final CapturedThemes? capturedThemes;\n\n  /// The main axis's max constraint ratio for the sheet, depending on [side]. Defaults to 9 / 16.\n  ///\n  /// The main axis is the width if [side] is [FLayout.ltr] or [FLayout.rtl], and the height if [side] is [FLayout.ttb] or\n  /// [FLayout.btt].\n  ///\n  /// Consider setting this to null if this sheet has a scrollable child, i.e. [ListView], along the main axis, to have\n  /// the sheet be draggable.\n  final double? mainAxisMaxRatio;\n\n  /// The minimum and maximum sizes for a sheet. Default to being unconstrained.\n  final BoxConstraints constraints;\n\n  /// True if the sheet can be dragged up and down/left and right. Defaults is true.\n  final bool draggable;\n\n  /// The animation controller that controls the sheet's entrance and exit animations.\n  ///\n  /// The sheet widget will manipulate the position of this animation, it is not just a passive observer.\n  final AnimationController? transitionAnimationController;\n\n  /// The anchor point used to pick the closest sub-screen.\n  ///\n  /// If the anchor point sits inside one of these sub-screens, then that sub-screen is picked. If not, then the\n  /// sub-screen with the closest edge to the point is used.\n  ///\n  /// [Offset.zero] is the top-left corner of the available screen space. For a vertically split dual-screen device,\n  /// this is the top-left corner of the left screen.\n  ///\n  /// When this is null, [Directionality] is used:\n  /// * for [TextDirection.ltr], [anchorPoint] is [Offset.zero], which will cause the top-left sub-screen to be picked.\n  /// * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`, which will cause the top-right\n  ///   sub-screen to be picked.\n  final Offset? anchorPoint;\n\n  /// True if a [SafeArea] should be inserted o keep the sheet away from system intrusions on the sides other than\n  /// [side]. Defaults to false.\n  ///\n  /// If false, the sheet will extend through any system intrusions other than [side]. In addition,\n  /// [MediaQuery.removePadding] is used to remove opposite [side]'s padding so that a [SafeArea] widget inside the\n  /// sheet will not have any effect on the opposite side. If this is undesired, consider setting [useSafeArea] to true.\n  /// Alternatively, wrap the [SafeArea] in a [MediaQuery] that restates an ambient [MediaQueryData] from outside\n  /// [builder].\n  ///\n  /// In either case, the sheet extends all the way to the [side] of the screen, including any system intrusions.\n  final bool useSafeArea;\n\n  /// The semantic hint text that informs users what will happen if they tap on the widget. Announced in the format of\n  /// 'Double tap to ...'.\n  ///\n  /// If the field is null, the default hint will be used, which results in an announcement of 'Double tap to activate'.\n  ///\n  /// See:\n  ///  * [barrierDismissible], which controls the behavior of the barrier when tapped.\n  ///  * [FModalBarrier], which uses this field as onTapHint when it has an onTap action.\n  final String? barrierOnTapHint;\n\n  /// A builder for the contents of the sheet.\n  final WidgetBuilder builder;\n\n  /// Called when the sheet begins to close, before the route is popped.\n  final VoidCallback? onClosing;\n\n  @override\n  final String? barrierLabel;\n\n  @override\n  final bool barrierDismissible;\n\n  final ValueNotifier<EdgeInsets> _clipDetailsNotifier = ValueNotifier<EdgeInsets>(EdgeInsets.zero);\n\n  AnimationController? _animationController;\n\n  /// Creates a [FModalSheetRoute].\n  FModalSheetRoute({\n    required this.style,\n    required this.side,\n    required this.builder,\n    this.mainAxisMaxRatio = 9 / 16,\n    this.capturedThemes,\n    this.barrierOnTapHint,\n    this.barrierLabel,\n    this.barrierDismissible = true,\n    this.constraints = const BoxConstraints(),\n    this.draggable = true,\n    this.transitionAnimationController,\n    this.anchorPoint,\n    this.useSafeArea = false,\n    this.onClosing,\n    super.settings,\n  });\n\n  @override\n  AnimationController createAnimationController() {\n    if (transitionAnimationController != null) {\n      _animationController = transitionAnimationController;\n      willDisposeAnimationController = false;\n    } else {\n      _animationController = Sheet.createAnimationController(navigator!, style);\n    }\n\n    return _animationController!;\n  }\n\n  @override\n  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation) {\n    final sheet = Sheet(\n      controller: controller,\n      animation: animation,\n      side: side,\n      style: style,\n      constraints: constraints,\n      mainAxisMaxRatio: mainAxisMaxRatio,\n      anchorPoint: anchorPoint,\n      draggable: draggable,\n      useSafeArea: useSafeArea,\n      builder: builder,\n      onChange: (size) => _didChangeBarrierSemanticsClip(switch (side) {\n        FLayout.ttb => EdgeInsets.fromLTRB(0, size.height, 0, 0),\n        FLayout.btt => EdgeInsets.fromLTRB(0, 0, 0, size.height),\n        FLayout.ltr => EdgeInsets.fromLTRB(size.width, 0, 0, 0),\n        FLayout.rtl => EdgeInsets.fromLTRB(0, 0, size.width, 0),\n      }),\n      onClosing: () {\n        onClosing?.call();\n        if (isCurrent) {\n          Navigator.pop(context);\n        }\n      },\n    );\n\n    return capturedThemes?.wrap(sheet) ?? sheet;\n  }\n\n  @override\n  Widget buildModalBarrier() {\n    if (style.barrierFilter != null && !offstage) {\n      return Builder(\n        builder: (context) => FAnimatedModalBarrier(\n          animation: animation!.drive(CurveTween(curve: barrierCurve)),\n          filter: style.barrierFilter,\n          onDismiss: barrierDismissible ? () => Navigator.pop(context) : null,\n          semanticsLabel: barrierLabel,\n          // changedInternalState is called if barrierLabel updates\n          barrierSemanticsDismissible: semanticsDismissible,\n          clipDetailsNotifier: _clipDetailsNotifier,\n          semanticsOnTapHint: barrierOnTapHint,\n        ),\n      );\n    } else {\n      return Builder(\n        builder: (context) => FModalBarrier(\n          filter: null,\n          onDismiss: barrierDismissible ? () => Navigator.pop(context) : null,\n          semanticsLabel: barrierLabel,\n          // changedInternalState is called if barrierLabel updates\n          barrierSemanticsDismissible: semanticsDismissible,\n          clipDetailsNotifier: _clipDetailsNotifier,\n          semanticsOnTapHint: barrierOnTapHint,\n        ),\n      );\n    }\n  }\n\n  @override\n  void dispose() {\n    _clipDetailsNotifier.dispose();\n    super.dispose();\n  }\n\n  /// Updates the details regarding how the [SemanticsNode.rect] (focus) of the barrier for this [FModalSheetRoute]\n  /// should be clipped.\n  ///\n  /// Returns true if the clipDetails did change and false otherwise.\n  bool _didChangeBarrierSemanticsClip(EdgeInsets details) {\n    if (_clipDetailsNotifier.value == details) {\n      return false;\n    }\n\n    _clipDetailsNotifier.value = details;\n    return true;\n  }\n\n  /// Always returns [Colors.transparent] and is not used by [FModalSheetRoute].\n  @override\n  Color get barrierColor => Colors.transparent;\n\n  @override\n  Curve get barrierCurve => style.motion.barrierCurve;\n\n  @override\n  Duration get transitionDuration => style.motion.expandDuration;\n\n  @override\n  Duration get reverseTransitionDuration => style.motion.collapseDuration;\n}\n\n/// A modal sheet's style.\nclass FModalSheetStyle extends FSheetStyle with Diagnosticable, _$FModalSheetStyleFunctions {\n  /// {@macro forui.widgets.FPopoverStyle.barrierFilter}\n  @override\n  final ImageFilter Function(double animation)? barrierFilter;\n\n  /// The motion-related properties for a modal sheet.\n  @override\n  final FModalSheetMotion motion;\n\n  /// Creates a [FSheetStyle].\n  const FModalSheetStyle({\n    this.barrierFilter,\n    this.motion = const FModalSheetMotion(),\n    super.flingVelocity,\n    super.closeProgressThreshold,\n  });\n\n  /// Creates a [FSheetStyle] that inherits its colors from the given [FColors].\n  FModalSheetStyle.inherit({required FColors colors})\n    : this(\n        barrierFilter: (v) => ColorFilter.mode(Color.lerp(Colors.transparent, colors.barrier, v)!, BlendMode.srcOver),\n      );\n}\n\n/// The motion-related properties for a modal sheet.\nclass FModalSheetMotion extends FSheetMotion with Diagnosticable, _$FModalSheetMotionFunctions {\n  /// The barrier's curve. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve barrierCurve;\n\n  /// Creates a [FModalSheetMotion].\n  const FModalSheetMotion({\n    this.barrierCurve = Curves.easeOutCubic,\n    super.expandDuration,\n    super.collapseDuration,\n    super.curve,\n  });\n}\n",
      "persistent_sheet": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/sheet/sheet.dart';\n\npart 'persistent_sheet.design.dart';\n\n/// Shows a persistent sheet that appears above the current widget. It should have a [FSheets] or [FScaffold] ancestor.\n///\n/// The returned [FPersistentSheetController] should always be disposed after use. Not doing so can lead to the sheets\n/// accumulating over time, which can negatively impact performance.\n///\n/// A closely related widget is a modal sheet which prevents the user from interacting with the rest of the app.\n///\n/// [context] is used to look up the [Navigator] and [FSheetStyle] for the sheet. It is only used when the method is\n/// called. Its corresponding widget can be safely removed from the tree before the sheet is closed.\n///\n/// [style] defaults to [FSheetStyle] from the closest [FTheme] ancestor.\n///\n/// [mainAxisMaxRatio] represents the main axis's max constraint ratio for the sheet, depending on [side].\n/// Defaults to 9 / 16. The main axis is the width if [side] is [FLayout.ltr] or [FLayout.rtl], and the height if [side]\n/// is [FLayout.ttb] or [FLayout.btt]. Consider setting [mainAxisMaxRatio] to null if this sheet has a scrollable child,\n/// i.e. [ListView], along the main axis, to have the sheet be draggable.\n///\n/// [anchorPoint] is used to pick the closest sub-screen.\n///\n/// [keepAliveOffstage] determines whether the sheet should be kept alive even when it is offstage. Setting it to true\n/// retains the sheet's state even when it is not visible. Defaults to false. Keeping multiple sheets alive even when\n/// offstage can negatively impact performance.\n///\n/// [onClosing] is called when the sheet begins to close.\n///\n/// [key] is used to identify the sheet. If a key is not provided, a random key will be generated. All sheets in a\n/// [FScaffold]/[FSheets] must have unique keys.\n///\n/// ## Contract\n/// Throws [FlutterError] if:\n///   * the [context] does not contain a [FSheets] or [FScaffold] ancestor.\n///   * a sheet with the same [key] already exists.\n///\n/// ## CLI\n/// To generate and customize this widget's style:\n///\n/// ```shell\n/// dart run forui style create sheet\n/// ```\n///\n/// See:\n/// * https://forui.dev/docs/overlay/persistent-sheet for working examples.\n/// * [showFSheet] for showing a sheet in a modal that prevents the user from interacting with the rest of the app.\n/// * [FSheetStyle] for customizing a switch's appearance.\n/// * [DraggableScrollableSheet], creates a bottom sheet that grows and then becomes scrollable once it reaches its\n///   maximum size.\n@useResult\nFPersistentSheetController showFPersistentSheet({\n  required BuildContext context,\n  required FLayout side,\n  required Widget Function(BuildContext context, FPersistentSheetController controller) builder,\n  FPersistentSheetStyle Function(FPersistentSheetStyle)? style,\n  double? mainAxisMaxRatio = 9 / 16,\n  BoxConstraints constraints = const BoxConstraints(),\n  bool draggable = true,\n  Offset? anchorPoint,\n  bool useSafeArea = false,\n  bool keepAliveOffstage = false,\n  VoidCallback? onClosing,\n  Key? key,\n}) {\n  final state = context.findAncestorStateOfType<FSheetsState>();\n  if (state == null) {\n    throw FlutterError.fromParts([\n      ErrorSummary('showFSheet(...) called with a context that does not contain a FSheets/FScaffold.'),\n      ErrorDescription(\n        'No FSheets/FScaffold ancestor could be found starting from the context that was passed to FSheets/FScaffold.of(). '\n        'This usually happens when the context provided is from the same StatefulWidget as that whose build function '\n        'actually creates the FSheets/FScaffold widget being sought.',\n      ),\n      ErrorHint(\n        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\n        'context that is \"under\" the FSheets/FScaffold.',\n      ),\n      context.describeElement('The context used was'),\n    ]);\n  }\n\n  key ??= ValueKey(Random().nextInt(2147483647));\n  final sheetStyle = style?.call(context.theme.persistentSheetStyle) ?? context.theme.persistentSheetStyle;\n\n  final controller = FPersistentSheetController._(\n    vsync: state,\n    style: sheetStyle,\n    key: key,\n    keepAliveOffstage: keepAliveOffstage,\n    setState: (function) {\n      if (state.mounted) {\n        // ignore: invalid_use_of_protected_member\n        state.setState(function);\n      }\n    },\n    onDispose: () => state._remove(key!),\n  );\n\n  try {\n    state._add(\n      controller,\n      Sheet(\n        controller: controller._controller,\n        animation: null,\n        style: sheetStyle,\n        side: side,\n        mainAxisMaxRatio: mainAxisMaxRatio,\n        constraints: constraints,\n        draggable: draggable,\n        anchorPoint: anchorPoint,\n        useSafeArea: useSafeArea,\n        builder: (context) => builder(context, controller),\n        onChange: null,\n        onClosing: onClosing,\n      ),\n    );\n  } catch (_) {\n    controller.dispose();\n    rethrow;\n  }\n\n  controller.show();\n\n  return controller;\n}\n\n/// A sheet controller.\nclass FPersistentSheetController {\n  /// The sheet's key.\n  final Key key;\n\n  /// True if the sheet to which this controller is attached should be kept alive even when it is offstage. Setting it\n  /// to true retains the sheet's state even when it is not visible. Defaults to false. Keeping multiple sheets alive\n  /// even when offstage can negatively impact performance.\n  final bool keepAliveOffstage;\n\n  /// Marks the sheet as needing to be rebuilt.\n  final StateSetter setState;\n\n  final AnimationController _controller;\n  final VoidCallback _onDispose;\n\n  FPersistentSheetController._({\n    required TickerProvider vsync,\n    required FSheetStyle style,\n    required VoidCallback onDispose,\n    required this.key,\n    required this.keepAliveOffstage,\n    required this.setState,\n  }) : _controller = Sheet.createAnimationController(vsync, style),\n       _onDispose = onDispose {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/forui.dart',\n        className: '$FPersistentSheetController',\n        object: this,\n      );\n    }\n    _controller.addStatusListener((status) => setState(() {}));\n  }\n\n  /// Shows the sheet if it is hidden.\n  TickerFuture show() => _controller.forward();\n\n  /// Shows the sheet if it is hidden and hides it if it is shown.\n  TickerFuture toggle() => _controller.toggle();\n\n  /// Hides the sheet if it is shown.\n  TickerFuture hide() => _controller.reverse();\n\n  /// The current status.\n  ///\n  /// [AnimationStatus.dismissed] - The sheet is hidden.\n  /// [AnimationStatus.forward] - The sheet is transitioning from hidden to shown.\n  /// [AnimationStatus.completed] - The sheet is shown.\n  /// [AnimationStatus.reverse] - The sheet is transitioning from shown to hidden.\n  AnimationStatus get status => _controller.status;\n\n  /// Disposes of the controller.\n  void dispose() {\n    _controller.dispose();\n    _onDispose();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n}\n\n/// Sheets that are displayed above its [child]. It is part of [FScaffold], which should be preferred in most cases.\n///\n/// A sheet shows information that supplements the primary content of the app without preventing the user from\n/// interacting with the app.\n///\n/// A closely related widget is a modal sheet, which is an alternative to a menu or a dialog and prevents the user from\n/// interacting with the rest of the app.\n///\n/// See:\n/// * https://forui.dev/docs/overlay/sheet for working examples.\n/// * [FSheetStyle] for customizing a switch's appearance.\n/// * [showFPersistentSheet] for for displaying a sheet above the current widget.\n/// * [showFSheet] for displaying a modal sheet.\n/// * [DraggableScrollableSheet], creates a bottom sheet that grows and then becomes scrollable once it reaches its\n///   maximum size.\nclass FSheets extends StatefulWidget {\n  /// The child.\n  final Widget child;\n\n  /// Creates a [FSheets].\n  const FSheets({required this.child, super.key});\n\n  @override\n  State<FSheets> createState() => FSheetsState();\n}\n\n@visibleForTesting\n@internal\nclass FSheetsState extends State<FSheets> with TickerProviderStateMixin {\n  final Map<Key, (FPersistentSheetController, Sheet)> sheets = {};\n\n  @override\n  Widget build(BuildContext _) => Stack(\n    children: [\n      widget.child,\n      for (final (controller, sheet) in sheets.values)\n        if (controller.keepAliveOffstage || controller.status.isAnimating || controller.status.isCompleted)\n          CallbackShortcuts(\n            bindings: {const SingleActivator(LogicalKeyboardKey.escape): controller._controller.reverse},\n            child: FocusTraversalGroup(\n              descendantsAreFocusable: controller.status.isCompleted,\n              descendantsAreTraversable: controller.status.isCompleted,\n              child: sheet,\n            ),\n          ),\n    ],\n  );\n\n  void _add(FPersistentSheetController controller, Sheet sheet) {\n    if (!mounted) {\n      return;\n    }\n\n    if (sheets.containsKey(controller.key)) {\n      throw FlutterError.fromParts([\n        ErrorSummary('showFSheet(...) called with a key that already exists.'),\n        ErrorDescription(\n          'A sheet with the key, \"${controller.key}\", already exists. Each sheet must have a unique key.',\n        ),\n        ErrorHint(\n          'To solve this problem, pass a different key to `showFSheet(...)` or dispose of the other sheet with the same '\n          'key first',\n        ),\n      ]);\n    }\n\n    setState(() => sheets[controller.key] = (controller, sheet));\n  }\n\n  Future<void> _remove(Key key) async {\n    // This checks if the method was called during the build phase, and schedules the removal for the next frame.\n    // This done as _remove is called in FSheetController.dispose, and subsequently StatefulWidget.dispose, which is\n    // part of the build phase.\n    if (mounted && SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      setState(() => sheets.remove(key));\n    } else {\n      WidgetsBinding.instance.addPostFrameCallback((_) {\n        if (mounted) {\n          setState(() => sheets.remove(key));\n        }\n      });\n    }\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('sheets', sheets));\n  }\n}\n\n/// A persistent sheet's style.\nclass FPersistentSheetStyle extends FSheetStyle with Diagnosticable, _$FPersistentSheetStyleFunctions {\n  /// The motion-related properties for a persistent sheet.\n  @override\n  final FPersistentSheetMotion motion;\n\n  /// Creates a [FSheetStyle].\n  const FPersistentSheetStyle({\n    this.motion = const FPersistentSheetMotion(),\n    super.flingVelocity,\n    super.closeProgressThreshold,\n  });\n}\n\n/// The motion-related properties for a persistent sheet.\nclass FPersistentSheetMotion extends FSheetMotion with Diagnosticable, _$FPersistentSheetMotionFunctions {\n  /// Creates a [FPersistentSheetMotion].\n  const FPersistentSheetMotion({super.expandDuration, super.collapseDuration, super.curve});\n}\n",
      "sheet": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/sheet/gesture_detector.dart';\nimport 'package:forui/src/widgets/sheet/shifted_sheet.dart';\n\n@internal\nclass Sheet extends StatefulWidget {\n  static AnimationController createAnimationController(TickerProvider vsync, FSheetStyle style) => AnimationController(\n    duration: style.motion.expandDuration,\n    reverseDuration: style.motion.collapseDuration,\n    vsync: vsync,\n  );\n\n  final AnimationController? controller;\n  final Animation<double>? animation;\n  final FSheetStyle style;\n  final FLayout side;\n  final double? mainAxisMaxRatio;\n  final BoxConstraints constraints;\n  final Offset? anchorPoint;\n  final bool draggable;\n  final bool useSafeArea;\n  final WidgetBuilder builder;\n  final ValueChanged<Size>? onChange;\n  final VoidCallback? onClosing;\n\n  const Sheet({\n    required this.controller,\n    required this.animation,\n    required this.style,\n    required this.side,\n    required this.mainAxisMaxRatio,\n    required this.constraints,\n    required this.anchorPoint,\n    required this.draggable,\n    required this.useSafeArea,\n    required this.builder,\n    required this.onChange,\n    required this.onClosing,\n    super.key,\n  }) : assert(!draggable || controller != null, 'Draggable sheets must have a controller');\n\n  @override\n  State<Sheet> createState() => _SheetState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('animation', animation))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(EnumProperty('side', side))\n      ..add(DoubleProperty('mainAxisMaxRatio', mainAxisMaxRatio))\n      ..add(DiagnosticsProperty('constraints', constraints))\n      ..add(DiagnosticsProperty('anchorPoint', anchorPoint))\n      ..add(FlagProperty('draggable', value: draggable, ifTrue: 'draggable'))\n      ..add(FlagProperty('useSafeArea', value: useSafeArea, ifTrue: 'useSafeArea'))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onClosing', onClosing));\n  }\n}\n\nclass _SheetState extends State<Sheet> with SingleTickerProviderStateMixin {\n  final GlobalKey _key = GlobalKey(debugLabel: 'Sheet child');\n  late AnimationController _controller;\n  late Animation<double> _animation;\n  late ParametricCurve<double> _curve;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = widget.controller ?? Sheet.createAnimationController(this, widget.style);\n    _animation = widget.animation ?? _controller.view;\n    _curve = widget.style.motion.curve;\n  }\n\n  @override\n  void didUpdateWidget(covariant Sheet old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      }\n\n      _controller = widget.controller ?? Sheet.createAnimationController(this, widget.style);\n      _animation = widget.animation ?? _controller.view;\n      _curve = widget.style.motion.curve;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    assert(debugCheckHasMediaQuery(context));\n\n    Widget sheet = DisplayFeatureSubScreen(\n      anchorPoint: widget.anchorPoint,\n      child: Align(\n        alignment: switch (widget.side) {\n          FLayout.ttb => Alignment.topCenter,\n          FLayout.btt => Alignment.bottomCenter,\n          FLayout.ltr => Alignment.centerLeft,\n          FLayout.rtl => Alignment.centerRight,\n        },\n        heightFactor: widget.side.vertical ? 1 : null,\n        widthFactor: widget.side.vertical ? null : 1,\n        child: ConstrainedBox(\n          constraints: widget.constraints,\n          child: NotificationListener<DraggableScrollableNotification>(\n            key: _key,\n            onNotification: (notification) {\n              if (notification.extent == notification.minExtent && notification.shouldCloseOnMinExtent) {\n                widget.onClosing?.call();\n              }\n              return false;\n            },\n            child: widget.builder(context),\n          ),\n        ),\n      ),\n    );\n\n    if (widget.draggable) {\n      sheet = SheetGestureDetector(\n        layout: widget.side,\n        // Allow the sheet to track the user's finger accurately.\n        // This cannot be done inside the Sheet widget itself since doing that will interfere with the expansion and\n        // collapse animations when initially entering the screen and when dismissing the sheet without dragging.\n        onStart: (_) => _curve = Curves.linear,\n        onUpdate: _dragUpdate,\n        onEnd: _dragEnd,\n        child: sheet,\n      );\n    }\n\n    sheet = switch ((widget.side, widget.useSafeArea)) {\n      (FLayout.ttb, true) => SafeArea(top: false, child: sheet),\n      (FLayout.btt, true) => SafeArea(bottom: false, child: sheet),\n      (FLayout.ltr, true) => SafeArea(left: false, child: sheet),\n      (FLayout.rtl, true) => SafeArea(right: false, child: sheet),\n      (FLayout.ttb, false) => MediaQuery.removePadding(context: context, removeBottom: true, child: sheet),\n      (FLayout.btt, false) => MediaQuery.removePadding(context: context, removeTop: true, child: sheet),\n      (FLayout.ltr, false) => MediaQuery.removePadding(context: context, removeRight: true, child: sheet),\n      (FLayout.rtl, false) => MediaQuery.removePadding(context: context, removeLeft: true, child: sheet),\n    };\n\n    return AnimatedBuilder(\n      animation: _animation,\n      builder: (context, child) => Semantics(\n        scopesRoute: true,\n        namesRoute: true,\n        label: switch (defaultTargetPlatform) {\n          TargetPlatform.iOS || TargetPlatform.macOS => null,\n          _ => (FLocalizations.of(context) ?? FDefaultLocalizations()).sheetSemanticsLabel,\n        },\n        explicitChildNodes: true,\n        child: ClipRect(\n          child: ShiftedSheet(\n            side: widget.side,\n            onChange: widget.onChange,\n            value: _curve.transform(_animation.value),\n            mainAxisMaxRatio: widget.mainAxisMaxRatio,\n            child: child,\n          ),\n        ),\n      ),\n      child: sheet,\n    );\n  }\n\n  GestureDragUpdateCallback get _dragUpdate => switch (widget.side) {\n    FLayout.ttb => (details) {\n      if (!_dismissing) {\n        _controller.value += details.primaryDelta! / _key.currentChildHeight;\n      }\n    },\n    FLayout.btt => (details) {\n      if (!_dismissing) {\n        _controller.value -= details.primaryDelta! / _key.currentChildHeight;\n      }\n    },\n    FLayout.ltr => (details) {\n      if (!_dismissing) {\n        _controller.value += details.primaryDelta! / _key.currentChildWidth;\n      }\n    },\n    FLayout.rtl => (details) {\n      if (!_dismissing) {\n        _controller.value -= details.primaryDelta! / _key.currentChildWidth;\n      }\n    },\n  };\n\n  GestureDragEndCallback get _dragEnd {\n    final double Function(DragEndDetails) velocity = switch (widget.side) {\n      FLayout.ttb => (details) => details.primaryVelocity! / _key.currentChildHeight,\n      FLayout.btt => (details) => -details.primaryVelocity! / _key.currentChildHeight,\n      FLayout.ltr => (details) => details.primaryVelocity! / _key.currentChildWidth,\n      FLayout.rtl => (details) => -details.primaryVelocity! / _key.currentChildWidth,\n    };\n\n    return (details) {\n      if (_dismissing) {\n        return;\n      }\n\n      var closing = false;\n      if (widget.style.flingVelocity < details.primaryVelocity!) {\n        final flingVelocity = velocity(details);\n        if (0 < _controller.value) {\n          _controller.fling(velocity: flingVelocity);\n        }\n\n        if (flingVelocity < 0) {\n          closing = true;\n        }\n      } else if (_controller.value < widget.style.closeProgressThreshold) {\n        if (0 < _controller.value) {\n          _controller.fling(velocity: -1);\n        }\n        closing = true;\n      } else {\n        _controller.forward();\n      }\n\n      // Allow the sheet to animate smoothly from its current position.\n      _curve = Split(_animation.value, endCurve: widget.style.motion.curve);\n      if (closing) {\n        widget.onClosing?.call();\n      }\n    };\n  }\n\n  bool get _dismissing => _controller.status == AnimationStatus.reverse;\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    }\n    super.dispose();\n  }\n}\n\nextension on GlobalKey {\n  double get currentChildWidth => (currentContext!.findRenderObject()! as RenderBox).size.width;\n\n  double get currentChildHeight => (currentContext!.findRenderObject()! as RenderBox).size.height;\n}\n\n/// A sheet's style.\nabstract class FSheetStyle {\n  /// The minimum velocity to initiate a fling. Defaults to 700.\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if the value is not positive.\n  final double flingVelocity;\n\n  /// The threshold for determining whether the sheet is closing. Defaults to 0.5.\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if the value is not in the range `[0, 1]`.\n  final double closeProgressThreshold;\n\n  /// Creates a [FSheetStyle].\n  const FSheetStyle({this.flingVelocity = 700, this.closeProgressThreshold = 0.5});\n\n  /// The motion-related properties for a sheet.\n  FSheetMotion get motion;\n}\n\n/// The motion-related properties for a sheet.\nabstract class FSheetMotion {\n  /// The duration of the sheet's expansion animation. Defaults to 200ms.\n  final Duration expandDuration;\n\n  /// The duration of the sheet's collapsing animation. Defaults to 200ms.\n  final Duration collapseDuration;\n\n  /// The curve of the sheet's expansion and collapse. Defaults to [Curves.easeOutCubic].\n  final Curve curve;\n\n  /// Creates a [FSheetMotion].\n  const FSheetMotion({\n    this.expandDuration = const Duration(milliseconds: 200),\n    this.collapseDuration = const Duration(milliseconds: 200),\n    this.curve = Curves.easeOutCubic,\n  });\n}\n",
      "shifted_sheet": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/src/foundation/rendering.dart';\n\n/// This is based on Material's _BottomSheetLayoutWithSizeListener.\n@internal\nclass ShiftedSheet extends SingleChildRenderObjectWidget {\n  final FLayout side;\n  final double value;\n  final double? mainAxisMaxRatio;\n  final ValueChanged<Size>? onChange;\n\n  const ShiftedSheet({\n    required this.side,\n    required this.value,\n    required this.mainAxisMaxRatio,\n    required this.onChange,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  RenderBox createRenderObject(BuildContext _) =>\n      _ShiftedSheet(side: side, value: value, mainAxisMaxRatio: mainAxisMaxRatio, onChange: onChange);\n\n  @override\n  // ignore: library_private_types_in_public_api\n  void updateRenderObject(BuildContext _, _ShiftedSheet box) => box\n    ..side = side\n    ..value = value\n    ..mainAxisMaxRatio = mainAxisMaxRatio\n    ..onChange = onChange;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(EnumProperty('side', side))\n      ..add(DoubleProperty('value', value))\n      ..add(DoubleProperty('mainAxisMaxRatio', mainAxisMaxRatio))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n\nclass _ShiftedSheet extends RenderShiftedBox {\n  FLayout _side;\n  double _value;\n  double? _mainAxisMaxRatio;\n  ValueChanged<Size>? _onChange;\n  Size _previous = Size.zero;\n\n  _ShiftedSheet({\n    required FLayout side,\n    required double value,\n    required double? mainAxisMaxRatio,\n    required ValueChanged<Size>? onChange,\n  }) : _side = side,\n       _value = value,\n       _mainAxisMaxRatio = mainAxisMaxRatio,\n       _onChange = onChange,\n       super(null);\n\n  @override\n  void performLayout() {\n    size = constraints.biggest;\n\n    if (child case final child?) {\n      final childConstraints = constrainChild(constraints);\n      assert(childConstraints.debugAssertIsValid(isAppliedConstraint: true));\n\n      child.layout(childConstraints, parentUsesSize: !childConstraints.isTight);\n\n      final childSize = childConstraints.isTight ? childConstraints.smallest : child.size;\n      child.data.offset = positionChild(size, childSize);\n\n      if (_previous != childSize) {\n        _previous = childSize;\n        _onChange?.call(_previous);\n      }\n    }\n  }\n\n  @override\n  double? computeDryBaseline(covariant BoxConstraints constraints, TextBaseline baseline) {\n    if (child case final child?) {\n      final childConstraints = constrainChild(constraints);\n      final result = child.getDryBaseline(childConstraints, baseline);\n      if (result == null) {\n        return null;\n      }\n\n      final childSize = childConstraints.isTight ? childConstraints.smallest : child.getDryLayout(childConstraints);\n      return result + positionChild(constraints.biggest, childSize).dy;\n    }\n\n    return null;\n  }\n\n  BoxConstraints constrainChild(BoxConstraints constraints) => side.vertical\n      ? BoxConstraints(\n          minWidth: constraints.maxWidth,\n          maxWidth: constraints.maxWidth,\n          maxHeight: _mainAxisMaxRatio == null ? constraints.maxHeight : constraints.maxHeight * _mainAxisMaxRatio!,\n        )\n      : BoxConstraints(\n          maxWidth: _mainAxisMaxRatio == null ? constraints.maxWidth : constraints.maxWidth * _mainAxisMaxRatio!,\n          minHeight: constraints.maxHeight,\n          maxHeight: constraints.maxHeight,\n        );\n\n  Offset positionChild(Size size, Size childSize) => switch (side) {\n    FLayout.ttb => Offset(0, childSize.height * (_value - 1)),\n    FLayout.btt => Offset(0, size.height - childSize.height * _value),\n    FLayout.ltr => Offset(childSize.width * (_value - 1), 0),\n    FLayout.rtl => Offset(size.width - childSize.width * _value, 0),\n  };\n\n  @override\n  Size computeDryLayout(BoxConstraints constraints) => constraints.biggest;\n\n  @override\n  double computeMinIntrinsicWidth(double _) => 0.0;\n\n  @override\n  double computeMaxIntrinsicWidth(double _) => 0.0;\n\n  @override\n  double computeMinIntrinsicHeight(double _) => 0.0;\n\n  @override\n  double computeMaxIntrinsicHeight(double _) => 0.0;\n\n  FLayout get side => _side;\n\n  set side(FLayout value) {\n    if (_side != value) {\n      _side = value;\n      markNeedsLayout();\n    }\n  }\n\n  double get value => _value;\n\n  set value(double value) {\n    if (_value != value) {\n      _value = value;\n      markNeedsLayout();\n    }\n  }\n\n  double? get mainAxisMaxRatio => _mainAxisMaxRatio;\n\n  set mainAxisMaxRatio(double? value) {\n    if (_mainAxisMaxRatio != value) {\n      _mainAxisMaxRatio = value;\n      markNeedsLayout();\n    }\n  }\n\n  ValueChanged<Size>? get onChange => _onChange;\n\n  set onChange(ValueChanged<Size>? value) {\n    if (_onChange != value) {\n      _onChange = value;\n      markNeedsLayout();\n    }\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(EnumProperty('side', side))\n      ..add(DoubleProperty('value', value))\n      ..add(DoubleProperty('mainAxisRatio', mainAxisMaxRatio))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n"
    },
    "Sidebar": {
      "sidebar": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'sidebar.design.dart';\n\n/// A sidebar widget that provides an opinionated layout on the side of the screen.\n///\n/// The [FSidebar] widget is useful for creating navigation sidebars with a header (sticky), content (scrollable), and\n/// footer (sticky) sections.\n///\n/// The layout structure is organized as follows:\n/// ```md\n/// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2510\n/// \u2502   Header (Sticky)   \u2502\n/// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2524\n/// \u2502                     \u2502\n/// \u2502                     \u2502\n/// \u2502      Content        \u2502\n/// \u2502    (Scrollable)     \u2502\n/// \u2502                     \u2502\n/// \u2502                     \u2502\n/// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2524\n/// \u2502   Footer (Sticky)   \u2502\n/// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500-\u2518\n/// ```\n///\n/// See:\n/// * https://forui.dev/docs/navigation/sidebar for working examples.\n/// * [FSidebarStyle] for customizing a sidebar's appearance.\nclass FSidebar extends StatefulWidget {\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create sidebar\n  /// ```\n  final FSidebarStyle Function(FSidebarStyle style)? style;\n\n  /// An optional sticky header.\n  final Widget? header;\n\n  /// The main scrollable content.\n  final Widget child;\n\n  /// An optional sticky footer.\n  final Widget? footer;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusScopeNode? focusNode;\n\n  /// Controls the transfer of focus beyond the first and the last items in the sidebar. Defaults to\n  /// [TraversalEdgeBehavior.parentScope].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if both [focusNode] and [traversalEdgeBehavior] are not null.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  /// Creates a sidebar with a list of children that will be wrapped in a [ListView].\n  FSidebar({\n    required List<Widget> children,\n    this.header,\n    this.footer,\n    this.style,\n    this.autofocus = false,\n    this.focusNode,\n    this.traversalEdgeBehavior,\n    super.key,\n  }) : assert(\n         focusNode == null || traversalEdgeBehavior == null,\n         'Cannot provide both a focusNode and traversalEdgeBehavior',\n       ),\n       child = ListView(children: children);\n\n  /// Creates a sidebar with a builder function that will be wrapped in a [ListView.builder].\n  FSidebar.builder({\n    required Widget Function(BuildContext context, int index) itemBuilder,\n    required int itemCount,\n    this.style,\n    this.header,\n    this.footer,\n    this.autofocus = false,\n    this.focusNode,\n    this.traversalEdgeBehavior,\n    super.key,\n  }) : assert(\n         focusNode == null || traversalEdgeBehavior == null,\n         'Cannot provide both a focusNode and traversalEdgeBehavior',\n       ),\n       child = ListView.builder(itemBuilder: itemBuilder, itemCount: itemCount);\n\n  /// Creates a sidebar with a custom content widget.\n  ///\n  /// Use this constructor when you want to provide your own scrollable content widget instead of using the default\n  /// [ListView].\n  const FSidebar.raw({\n    required this.child,\n    this.header,\n    this.footer,\n    this.style,\n    this.autofocus = false,\n    this.focusNode,\n    this.traversalEdgeBehavior,\n    super.key,\n  }) : assert(\n         focusNode == null || traversalEdgeBehavior == null,\n         'Cannot provide both a focusNode and traversalEdgeBehavior',\n       );\n\n  @override\n  State<FSidebar> createState() => _FSidebarState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(EnumProperty('traversalEdgeBehavior', traversalEdgeBehavior));\n  }\n}\n\nclass _FSidebarState extends State<FSidebar> {\n  FocusScopeNode? _focusNode;\n\n  @override\n  void initState() {\n    super.initState();\n    _focusNode =\n        widget.focusNode ??\n        FocusScopeNode(\n          debugLabel: 'FSidebar',\n          traversalEdgeBehavior: widget.traversalEdgeBehavior ?? TraversalEdgeBehavior.parentScope,\n        );\n  }\n\n  @override\n  void didUpdateWidget(covariant FSidebar old) {\n    super.didUpdateWidget(old);\n\n    if (widget.focusNode != old.focusNode || widget.traversalEdgeBehavior != old.traversalEdgeBehavior) {\n      if (old.focusNode == null) {\n        _focusNode?.dispose();\n      }\n\n      _focusNode =\n          widget.focusNode ??\n          FocusScopeNode(\n            debugLabel: 'FSidebar',\n            traversalEdgeBehavior: widget.traversalEdgeBehavior ?? TraversalEdgeBehavior.parentScope,\n          );\n    }\n  }\n\n  @override\n  void dispose() {\n    if (widget.focusNode == null) {\n      _focusNode?.dispose();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.sidebarStyle) ?? context.theme.sidebarStyle;\n\n    Widget sidebar = FocusScope(\n      autofocus: widget.autofocus,\n      node: _focusNode,\n      child: FSidebarData(\n        style: style,\n        child: DecoratedBox(\n          decoration: style.decoration,\n          child: ConstrainedBox(\n            constraints: style.constraints,\n            child: Column(\n              children: [\n                if (widget.header != null) Padding(padding: style.headerPadding, child: widget.header!),\n                Expanded(\n                  child: Padding(padding: style.contentPadding, child: widget.child),\n                ),\n                if (widget.footer != null) Padding(padding: style.footerPadding, child: widget.footer!),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n\n    if (style.backgroundFilter case final filter?) {\n      sidebar = Stack(\n        children: [\n          Positioned.fill(\n            child: ClipRect(\n              child: BackdropFilter(filter: filter, child: Container()),\n            ),\n          ),\n          sidebar,\n        ],\n      );\n    }\n\n    return sidebar;\n  }\n}\n\n/// A [FSidebar]'s data.\nclass FSidebarData extends InheritedWidget {\n  /// Returns the [FSidebarData] of the [FSidebar] in the given [context].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if there is no ancestor [FSidebar] in the given [context].\n  static FSidebarData? maybeOf(BuildContext context) => context.dependOnInheritedWidgetOfExactType<FSidebarData>();\n\n  /// The [FSidebar]'s style.\n  final FSidebarStyle style;\n\n  /// Creates a [FSidebarData].\n  const FSidebarData({required this.style, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(FSidebarData old) => style != old.style;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// A [FSidebar]'s style.\nclass FSidebarStyle with Diagnosticable, _$FSidebarStyleFunctions {\n  /// The decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// An optional background filter applied to the sidebar.\n  ///\n  /// This is typically combined with a translucent background in [decoration] to create a glassmorphic effect.\n  @override\n  final ImageFilter? backgroundFilter;\n\n  /// The sidebar's width. Defaults to `BoxConstraints.tightFor(width: 250)`.\n  @override\n  final BoxConstraints constraints;\n\n  /// The group's style.\n  @override\n  final FSidebarGroupStyle groupStyle;\n\n  /// The padding for the header section. Defaults to `EdgeInsets.fromLTRB(0, 16, 0, 0)`.\n  ///\n  /// It is recommended to set the horizontal padding to 0. This ensures that the elements such as the scrollbar is not\n  /// overlapped by the content.\n  @override\n  final EdgeInsetsGeometry headerPadding;\n\n  /// The padding for the content section. Defaults to `EdgeInsets.symmetric(vertical: 12)`.\n  ///\n  /// It is recommended to set the horizontal padding to 0. This ensures that the elements such as the scrollbar is not\n  /// overlapped by the content.\n  @override\n  final EdgeInsetsGeometry contentPadding;\n\n  /// The padding for the footer section. Defaults to `EdgeInsets.fromLTRB(0, 0, 0, 16)`.\n  ///\n  /// It is recommended to set the horizontal padding to 0. This ensures that the elements such as the scrollbar is not\n  /// overlapped by the content.\n  @override\n  final EdgeInsetsGeometry footerPadding;\n\n  /// Creates a [FSidebarStyle].\n  const FSidebarStyle({\n    required this.decoration,\n    required this.groupStyle,\n    this.constraints = const BoxConstraints.tightFor(width: 250),\n    this.backgroundFilter,\n    this.headerPadding = const EdgeInsets.fromLTRB(0, 16, 0, 0),\n    this.contentPadding = const EdgeInsets.symmetric(vertical: 12),\n    this.footerPadding = const EdgeInsets.fromLTRB(0, 0, 0, 16),\n  });\n\n  /// Creates a [FSidebarStyle] that inherits its properties.\n  FSidebarStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        decoration: BoxDecoration(\n          color: colors.background,\n          border: BorderDirectional(\n            end: BorderSide(color: colors.border, width: style.borderWidth),\n          ),\n        ),\n        groupStyle: FSidebarGroupStyle.inherit(colors: colors, typography: typography, style: style),\n      );\n}\n",
      "sidebar_group": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'sidebar_group.design.dart';\n\n/// A group of [FSidebarItem]s.\n///\n/// The [FSidebarGroup] widget is useful for organizing sidebar items into logical sections with an optional label and\n/// action. The label is typically used to describe the group, while the action can be used for group-level operations.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/sidebar for working examples.\n/// * [FSidebarGroupStyle] for customizing a sidebar group's appearance.\nclass FSidebarGroup extends StatelessWidget {\n  /// The sidebar group's style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create sidebar\n  /// ```\n  final FSidebarGroupStyle Function(FSidebarGroupStyle style)? style;\n\n  /// The label of the group.\n  final Widget? label;\n\n  /// An optional action widget to display after the label.\n  final Widget? action;\n\n  /// Called when the action's hover state changes.\n  final ValueChanged<bool>? onActionHoverChange;\n\n  /// Called when the action's state changes.\n  final ValueChanged<FWidgetStatesDelta>? onActionStateChange;\n\n  /// Called when the action is pressed.\n  final VoidCallback? onActionPress;\n\n  /// Called when the action is long pressed.\n  final VoidCallback? onActionLongPress;\n\n  /// The children of the group.\n  final List<Widget> children;\n\n  /// Creates a [FSidebarGroup].\n  const FSidebarGroup({\n    required this.children,\n    this.style,\n    this.label,\n    this.action,\n    this.onActionHoverChange,\n    this.onActionStateChange,\n    this.onActionPress,\n    this.onActionLongPress,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final sidebarData = FSidebarData.maybeOf(context);\n    final inheritedStyle = sidebarData?.style.groupStyle ?? context.theme.sidebarStyle.groupStyle;\n    final style = this.style?.call(inheritedStyle) ?? inheritedStyle;\n\n    return FSidebarGroupData(\n      style: style,\n      child: Padding(\n        padding: style.padding,\n        child: Column(\n          children: [\n            if (label != null || action != null)\n              Padding(\n                padding: style.headerPadding,\n                child: Row(\n                  spacing: style.headerSpacing,\n                  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                  children: [\n                    if (label != null)\n                      Expanded(\n                        child: DefaultTextStyle.merge(style: style.labelStyle, child: label!),\n                      )\n                    else\n                      const SizedBox(),\n                    if (action != null)\n                      FTappable(\n                        style: style.tappableStyle,\n                        focusedOutlineStyle: style.focusedOutlineStyle,\n                        onHoverChange: onActionHoverChange,\n                        onStateChange: onActionStateChange,\n                        onPress: onActionPress,\n                        onLongPress: onActionLongPress,\n                        builder: (_, states, child) =>\n                            IconTheme(data: style.actionStyle.resolve(states), child: child!),\n                        child: action!,\n                      )\n                    else\n                      const SizedBox(),\n                  ],\n                ),\n              ),\n            SizedBox(height: style.childrenSpacing),\n            Padding(\n              padding: style.childrenPadding,\n              child: Column(spacing: style.childrenSpacing, children: children),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(ObjectFlagProperty.has('onActionHoverChange', onActionHoverChange))\n      ..add(ObjectFlagProperty.has('onActionStateChange', onActionStateChange))\n      ..add(ObjectFlagProperty.has('onActionPress', onActionPress))\n      ..add(ObjectFlagProperty.has('onActionLongPress', onActionLongPress))\n      ..add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// A [FSidebarGroup]'s data.\nclass FSidebarGroupData extends InheritedWidget {\n  /// Returns the [FSidebarGroupData] of the [FSidebarGroup] in the given [context].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if there is no ancestor [FSidebarGroup] in the given [context].\n  static FSidebarGroupData? maybeOf(BuildContext context) =>\n      context.dependOnInheritedWidgetOfExactType<FSidebarGroupData>();\n\n  /// The [FSidebarGroup]'s style.\n  final FSidebarGroupStyle style;\n\n  /// Creates a [FSidebarGroupData].\n  const FSidebarGroupData({required this.style, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(FSidebarGroupData old) => style != old.style;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// The style for a [FSidebarGroup].\nclass FSidebarGroupStyle with Diagnosticable, _$FSidebarGroupStyleFunctions {\n  /// The padding. Defaults to `EdgeInsets.symmetric(horizontal: 16)`.\n  @override\n  final EdgeInsets padding;\n\n  /// The spacing between the label and action in the header. Defaults to 8.\n  @override\n  final double headerSpacing;\n\n  /// The padding around the header. Defaults to `EdgeInsets.fromLTRB(12, 0, 8, 2)`.\n  @override\n  final EdgeInsetsGeometry headerPadding;\n\n  /// The label's text style.\n  @override\n  final TextStyle labelStyle;\n\n  /// The action's style.\n  @override\n  final FWidgetStateMap<IconThemeData> actionStyle;\n\n  /// The spacing between children. Defaults to 2.\n  @override\n  final double childrenSpacing;\n\n  /// The padding around the children. Defaults to `EdgeInsets.fromLTRB(0, 0, 0, 24)`.\n  @override\n  final EdgeInsetsGeometry childrenPadding;\n\n  /// The tappable action's style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// The item's style.\n  @override\n  final FSidebarItemStyle itemStyle;\n\n  /// Creates a [FSidebarGroupStyle].\n  const FSidebarGroupStyle({\n    required this.labelStyle,\n    required this.actionStyle,\n    required this.tappableStyle,\n    required this.focusedOutlineStyle,\n    required this.itemStyle,\n    this.padding = const EdgeInsets.symmetric(horizontal: 16),\n    this.headerSpacing = 8,\n    this.headerPadding = const EdgeInsets.fromLTRB(12, 0, 8, 2),\n    this.childrenSpacing = 2,\n    this.childrenPadding = const EdgeInsets.fromLTRB(0, 0, 0, 24),\n  });\n\n  /// Creates a [FSidebarGroupStyle] that inherits its properties.\n  FSidebarGroupStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        labelStyle: typography.sm.copyWith(\n          color: colors.mutedForeground,\n          overflow: TextOverflow.ellipsis,\n          fontWeight: FontWeight.w500,\n        ),\n        actionStyle: FWidgetStateMap({\n          WidgetState.hovered | WidgetState.pressed: IconThemeData(color: colors.primary, size: 18),\n          WidgetState.any: IconThemeData(color: colors.mutedForeground, size: 18),\n        }),\n        tappableStyle: style.tappableStyle,\n        focusedOutlineStyle: style.focusedOutlineStyle,\n        itemStyle: FSidebarItemStyle.inherit(colors: colors, typography: typography, style: style),\n      );\n}\n",
      "sidebar_item": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart' show Colors;\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'sidebar_item.design.dart';\n\n/// A sidebar item.\n///\n/// The [FSidebarItem] widget is useful for creating interactive items in a sidebar. It can display an icon, label, and\n/// optional action, with support for selected and enabled states.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/sidebar for working examples.\n/// * [FSidebarItemStyle] for customizing a sidebar item's appearance.\nclass FSidebarItem extends StatefulWidget {\n  /// The sidebar item's style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create sidebar\n  /// ```\n  final FSidebarItemStyle Function(FSidebarItemStyle style)? style;\n\n  /// The icon to display before the label.\n  final Widget? icon;\n\n  /// The main content of the item.\n  final Widget? label;\n\n  /// Whether this item is currently selected.\n  final bool selected;\n\n  /// Whether this item is initially expanded.\n  final bool initiallyExpanded;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// Called when the item is pressed.\n  ///\n  /// The method will run concurrently with animations if [children] is non-null.\n  final VoidCallback? onPress;\n\n  /// Called when the item is long pressed.\n  final VoidCallback? onLongPress;\n\n  /// Called when the hover state changes.\n  final ValueChanged<bool>? onHoverChange;\n\n  /// Called when the state changes.\n  final ValueChanged<FWidgetStatesDelta>? onStateChange;\n\n  /// The sidebar item's children.\n  final List<Widget> children;\n\n  /// Creates a [FSidebarItem].\n  const FSidebarItem({\n    this.style,\n    this.icon,\n    this.label,\n    this.selected = false,\n    this.initiallyExpanded = false,\n    this.autofocus = false,\n    this.focusNode,\n    this.onPress,\n    this.onLongPress,\n    this.onHoverChange,\n    this.onStateChange,\n    this.children = const [],\n    super.key,\n  });\n\n  @override\n  State<FSidebarItem> createState() => _FSidebarItemState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('selected', value: selected, ifTrue: 'selected'))\n      ..add(FlagProperty('initiallyExpanded', value: initiallyExpanded, ifTrue: 'initiallyExpanded'))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(ObjectFlagProperty.has('onLongPress', onLongPress))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onStateChange', onStateChange))\n      ..add(DiagnosticsProperty('children', children));\n  }\n}\n\nclass _FSidebarItemState extends State<FSidebarItem> with TickerProviderStateMixin {\n  FSidebarItemStyle? _style;\n  AnimationController? _controller;\n  CurvedAnimation? _curvedReveal;\n  CurvedAnimation? _curvedFade;\n  CurvedAnimation? _curvedIconRotation;\n  Animation<double>? _reveal;\n  Animation<double>? _fade;\n  Animation<double>? _iconRotation;\n  late bool _expanded;\n\n  @override\n  void initState() {\n    super.initState();\n    _expanded = widget.initiallyExpanded;\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _update();\n  }\n\n  @override\n  void didUpdateWidget(FSidebarItem old) {\n    super.didUpdateWidget(old);\n    _update();\n  }\n\n  void _update() {\n    final groupData = FSidebarGroupData.maybeOf(context);\n    final sidebarData = FSidebarData.maybeOf(context);\n    final inheritedStyle =\n        groupData?.style.itemStyle ??\n        sidebarData?.style.groupStyle.itemStyle ??\n        context.theme.sidebarStyle.groupStyle.itemStyle;\n    final style = widget.style?.call(inheritedStyle) ?? inheritedStyle;\n\n    if (_style != style) {\n      _style = style;\n      _curvedIconRotation?.dispose();\n      _curvedFade?.dispose();\n      _curvedReveal?.dispose();\n      _controller?.dispose();\n\n      _controller = AnimationController(\n        vsync: this,\n        value: _expanded ? 1.0 : 0.0,\n        duration: style.motion.expandDuration,\n        reverseDuration: style.motion.collapseDuration,\n      );\n      _curvedReveal = CurvedAnimation(\n        curve: style.motion.expandCurve,\n        reverseCurve: style.motion.collapseCurve,\n        parent: _controller!,\n      );\n      _curvedFade = CurvedAnimation(curve: Curves.easeIn, reverseCurve: Curves.easeOut, parent: _controller!);\n      _curvedIconRotation = CurvedAnimation(\n        curve: style.motion.iconExpandCurve,\n        reverseCurve: style.motion.iconCollapseCurve,\n        parent: _controller!,\n      );\n      _reveal = style.motion.revealTween.animate(_curvedReveal!);\n      _fade = style.motion.fadeTween.animate(_curvedFade!);\n      _iconRotation = style.motion.iconTween.animate(_curvedIconRotation!);\n    }\n  }\n\n  @override\n  void dispose() {\n    _curvedIconRotation?.dispose();\n    _curvedFade?.dispose();\n    _curvedReveal?.dispose();\n    _controller?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => Column(\n    crossAxisAlignment: CrossAxisAlignment.start,\n    children: [\n      FTappable(\n        style: _style!.tappableStyle,\n        focusedOutlineStyle: _style!.focusedOutlineStyle,\n        selected: widget.selected,\n        autofocus: widget.autofocus,\n        focusNode: widget.focusNode,\n        onPress: widget.children.isNotEmpty\n            ? () {\n                _toggle();\n                widget.onPress?.call();\n              }\n            : widget.onPress,\n        onLongPress: widget.onLongPress,\n        onHoverChange: widget.onHoverChange,\n        onStateChange: widget.onStateChange,\n        builder: (_, states, child) => Container(\n          padding: _style!.padding,\n          decoration: BoxDecoration(color: _style!.backgroundColor.resolve(states), borderRadius: _style!.borderRadius),\n          child: Row(\n            spacing: _style!.collapsibleIconSpacing,\n            mainAxisAlignment: MainAxisAlignment.spaceBetween,\n            children: [\n              Expanded(\n                child: Row(\n                  spacing: _style!.iconSpacing,\n                  children: [\n                    if (widget.icon != null) IconTheme(data: _style!.iconStyle.resolve(states), child: widget.icon!),\n                    if (widget.label != null)\n                      Expanded(\n                        child: DefaultTextStyle.merge(style: _style!.textStyle.resolve(states), child: widget.label!),\n                      ),\n                  ],\n                ),\n              ),\n              if (widget.children.isNotEmpty)\n                IconTheme(\n                  data: _style!.collapsibleIconStyle.resolve(states),\n                  child: RotationTransition(turns: _iconRotation!, child: const Icon(FIcons.chevronRight)),\n                ),\n            ],\n          ),\n        ),\n      ),\n      if (widget.children.isNotEmpty)\n        AnimatedBuilder(\n          animation: _reveal!,\n          builder: (_, _) => FCollapsible(\n            value: _reveal!.value,\n            child: Padding(\n              padding: _style!.childrenPadding,\n              child: AnimatedBuilder(\n                animation: _fade!,\n                builder: (context, child) => FadeTransition(\n                  opacity: _fade!,\n                  child: Column(\n                    crossAxisAlignment: CrossAxisAlignment.start,\n                    spacing: _style!.childrenSpacing,\n                    children: widget.children,\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n    ],\n  );\n\n  void _toggle() {\n    _controller?.toggle();\n    setState(() => _expanded = !_expanded);\n  }\n}\n\n/// The style for a [FSidebarItem].\nclass FSidebarItemStyle with Diagnosticable, _$FSidebarItemStyleFunctions {\n  /// The label's text style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<TextStyle> textStyle;\n\n  /// The spacing between the icon and label. Defaults to 8.\n  @override\n  final double iconSpacing;\n\n  /// The icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<IconThemeData> iconStyle;\n\n  /// The spacing between the label and collapsible widget. Defaults to 8.\n  @override\n  final double collapsibleIconSpacing;\n\n  /// The collapsible icon's style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<IconThemeData> collapsibleIconStyle;\n\n  /// The spacing between child items. Defaults to 2.\n  @override\n  final double childrenSpacing;\n\n  /// The padding around the children container. Defaults to `EdgeInsets.only(left: 26, top: 2)`.\n  @override\n  final EdgeInsetsGeometry childrenPadding;\n\n  /// The background color.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.selectable}\n  @override\n  final FWidgetStateMap<Color> backgroundColor;\n\n  /// The padding around the content. Defaults to `EdgeInsets.symmetric(horizontal: 12, vertical: 10)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The item's border radius.\n  @override\n  final BorderRadius borderRadius;\n\n  /// The tappable's style.\n  @override\n  final FTappableStyle tappableStyle;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// The motion-related properties.\n  @override\n  final FSidebarItemMotion motion;\n\n  /// Creates a [FSidebarItemStyle].\n  const FSidebarItemStyle({\n    required this.textStyle,\n    required this.iconStyle,\n    required this.collapsibleIconStyle,\n    required this.backgroundColor,\n    required this.borderRadius,\n    required this.tappableStyle,\n    required this.focusedOutlineStyle,\n    this.iconSpacing = 8,\n    this.collapsibleIconSpacing = 8,\n    this.childrenSpacing = 2,\n    this.childrenPadding = const EdgeInsets.only(left: 26, top: 2),\n    this.padding = const EdgeInsets.symmetric(horizontal: 12, vertical: 10),\n    this.motion = const FSidebarItemMotion(),\n  });\n\n  /// Creates a [FSidebarItemStyle] that inherits its properties.\n  FSidebarItemStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        textStyle: FWidgetStateMap({\n          WidgetState.disabled: typography.base.copyWith(\n            color: colors.mutedForeground,\n            height: 1,\n            overflow: TextOverflow.ellipsis,\n          ),\n          WidgetState.any: typography.base.copyWith(\n            color: colors.foreground,\n            height: 1,\n            overflow: TextOverflow.ellipsis,\n          ),\n        }),\n        iconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: colors.mutedForeground, size: 16),\n          WidgetState.any: IconThemeData(color: colors.foreground, size: 16),\n        }),\n        collapsibleIconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: colors.mutedForeground, size: 16),\n          WidgetState.any: IconThemeData(color: colors.foreground, size: 16),\n        }),\n        backgroundColor: FWidgetStateMap({\n          WidgetState.disabled: Colors.transparent,\n          WidgetState.selected | WidgetState.hovered | WidgetState.pressed: colors.hover(colors.secondary),\n          WidgetState.any: Colors.transparent,\n        }),\n        borderRadius: style.borderRadius,\n        tappableStyle: style.tappableStyle.copyWith(motion: FTappableMotion.none),\n        focusedOutlineStyle: style.focusedOutlineStyle.copyWith(spacing: 0),\n      );\n}\n\n/// The motion-related properties for a [FSidebarItem].\nclass FSidebarItemMotion with Diagnosticable, _$FSidebarItemMotionFunctions {\n  /// The expand animation's duration. Defaults to 200ms.\n  @override\n  final Duration expandDuration;\n\n  /// The collapse animation's duration. Defaults to 150ms.\n  @override\n  final Duration collapseDuration;\n\n  /// The expand animation's curve. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve expandCurve;\n\n  /// The collapse animation's curve. Defaults to [Curves.easeInCubic].\n  @override\n  final Curve collapseCurve;\n\n  /// The fade-in animation's curve. Defaults to [Curves.linear].\n  @override\n  final Curve fadeInCurve;\n\n  /// The fade-out animation's curve. Defaults to [Curves.linear].\n  @override\n  final Curve fadeOutCurve;\n\n  /// The icon's animation curve when expanding. Defaults to [Curves.easeOut].\n  @override\n  final Curve iconExpandCurve;\n\n  /// The icon's animation curve when collapsing. Defaults to [Curves.easeOut].\n  @override\n  final Curve iconCollapseCurve;\n\n  /// The reveal animation's tween. Defaults to `FImmutableTween(begin: 0.0, end: 1.0)`.\n  @override\n  final Animatable<double> revealTween;\n\n  /// The fade animation's tween. Defaults to `FImmutableTween(begin: 0.0, end: 1.0)`.\n  @override\n  final Animatable<double> fadeTween;\n\n  /// The icon animation's tween. Defaults to `FImmutableTween(begin: 0.0, end: 0.25)`.\n  @override\n  final Animatable<double> iconTween;\n\n  /// Creates a [FSidebarItemMotion].\n  const FSidebarItemMotion({\n    this.expandDuration = const Duration(milliseconds: 200),\n    this.collapseDuration = const Duration(milliseconds: 150),\n    this.expandCurve = Curves.easeOutCubic,\n    this.collapseCurve = Curves.easeInCubic,\n    this.fadeInCurve = Curves.linear,\n    this.fadeOutCurve = Curves.linear,\n    this.iconExpandCurve = Curves.easeOut,\n    this.iconCollapseCurve = Curves.easeOut,\n    this.revealTween = const FImmutableTween(begin: 0.0, end: 1.0),\n    this.fadeTween = const FImmutableTween(begin: 0.0, end: 1.0),\n    this.iconTween = const FImmutableTween(begin: 0.0, end: 0.25),\n  });\n}\n"
    },
    "Slider": {
      "form_field": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/slider/inherited_data.dart';\nimport 'package:forui/src/widgets/slider/inherited_state.dart';\nimport 'package:forui/src/widgets/slider/slider_render_object.dart';\nimport 'package:forui/src/widgets/slider/track.dart';\n\n@internal\nclass SliderFormField extends FormField<FSliderSelection> with FFormFieldProperties<FSliderSelection> {\n  final FSliderController controller;\n  final BoxConstraints constraints;\n  @override\n  final Widget? label;\n  @override\n  final Widget? description;\n\n  SliderFormField({\n    required this.controller,\n    required this.constraints,\n    required this.label,\n    required this.description,\n    Widget Function(BuildContext context, String message) errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    super.onSaved,\n    super.onReset,\n    super.validator,\n    super.forceErrorText,\n    super.enabled = true,\n    super.autovalidateMode,\n    super.restorationId,\n    super.key,\n  }) : super(\n         initialValue: controller.selection,\n         errorBuilder: errorBuilder,\n         builder: (field) {\n           final state = field as _State;\n           final InheritedData(:layout, :marks, :trackMainAxisExtent) = InheritedData.of(state.context);\n           final style = InheritedData.of(state.context).style;\n           final states = {if (!enabled) WidgetState.disabled, if (state.hasError) WidgetState.error};\n\n           // DO NOT REORDER THE CHILDREN - _RenderSlider assumes this order.\n           final children = [\n             Padding(padding: style.childPadding, child: const Track()),\n             if (label != null)\n               DefaultTextStyle(\n                 style: style.labelTextStyle.resolve(states),\n                 child: Padding(padding: style.labelPadding, child: label),\n               )\n             else\n               const SizedBox(),\n             if (description != null)\n               DefaultTextStyle.merge(\n                 style: style.descriptionTextStyle.resolve(states),\n                 child: Padding(padding: style.descriptionPadding, child: description),\n               )\n             else\n               const SizedBox(),\n             if (state.errorText != null)\n               DefaultTextStyle.merge(\n                 style: style.errorTextStyle,\n                 child: Padding(padding: style.errorPadding, child: errorBuilder(state.context, state.errorText!)),\n               )\n             else\n               const SizedBox(),\n             for (final mark in marks.where((mark) => mark.label != null).toList())\n               if (mark case FSliderMark(style: final markStyle, :final label?))\n                 DefaultTextStyle(style: (markStyle ?? style.markStyle).labelTextStyle.resolve(states), child: label),\n           ];\n\n           return InheritedStates(\n             states: states,\n             child: layout.vertical\n                 ? VerticalSliderRenderObject(children: children)\n                 : HorizontalSliderRenderObject(children: children),\n           );\n         },\n       );\n\n  @override\n  FormFieldState<FSliderSelection> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('constraints', constraints))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder));\n  }\n}\n\nclass _State extends FormFieldState<FSliderSelection> {\n  @override\n  void initState() {\n    super.initState();\n    widget.controller.addListener(_handleControllerChanged);\n  }\n\n  @override\n  void didUpdateWidget(covariant SliderFormField old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      widget.controller.addListener(_handleControllerChanged);\n      old.controller.removeListener(_handleControllerChanged);\n    }\n  }\n\n  @override\n  void didChange(FSliderSelection? value) {\n    // This is not 100% accurate since a controller's selection can never be null. However, users will have to go out\n    // of their way to obtain a FormFieldState<FSliderSelection> via a GlobalKey AND call didChange(null).\n    assert(value != null, \"slider's selection cannot be null\");\n    super.didChange(value);\n    if (widget.controller.selection != value) {\n      widget.controller.selection = value;\n    }\n  }\n\n  @override\n  void reset() {\n    // Set the controller value before calling super.reset() to let _handleControllerChanged suppress the change.\n    widget.controller.reset();\n    super.reset();\n  }\n\n  @override\n  void dispose() {\n    widget.controller.removeListener(_handleControllerChanged);\n    super.dispose();\n  }\n\n  void _handleControllerChanged() {\n    // Suppress changes that originated from within this class.\n    //\n    // In the case where a controller has been passed in to this widget, we register this change listener. In these\n    // cases, we'll also receive change notifications for changes originating from within this class -- for example, the\n    // reset() method. In such cases, the FormField value will already have been set.\n    if (widget.controller.selection != value) {\n      didChange(widget.controller.selection);\n    }\n  }\n\n  @override\n  SliderFormField get widget => super.widget as SliderFormField;\n}\n",
      "inherited_controller": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n@internal\nclass InheritedController extends InheritedModel<UniqueKey> {\n  static final extendable = UniqueKey();\n\n  static final rawOffset = UniqueKey();\n\n  static final rawExtent = UniqueKey();\n\n  static FSliderController of(BuildContext context, [UniqueKey? aspect]) {\n    assert(debugCheckHasAncestor<InheritedController>('$FSlider', context));\n    return InheritedModel.inheritFrom<InheritedController>(context, aspect: aspect)!.controller;\n  }\n\n  final FSliderController controller;\n  final FSliderSelection _selection;\n\n  InheritedController({required this.controller, required super.child, super.key}) : _selection = controller.selection;\n\n  @override\n  bool updateShouldNotify(InheritedController old) => _selection != old._selection || controller != old.controller;\n\n  @override\n  bool updateShouldNotifyDependent(covariant InheritedController old, Set<UniqueKey> dependencies) =>\n      controller != old.controller ||\n      dependencies.contains(rawOffset) && _selection.rawOffset != old._selection.rawOffset ||\n      dependencies.contains(rawExtent) && _selection.rawExtent != old._selection.rawExtent ||\n      dependencies.contains(extendable) && controller.extendable != old.controller.extendable;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('controller', controller));\n  }\n}\n",
      "inherited_data": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:collection/collection.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n@internal\nclass InheritedData extends InheritedWidget {\n  static InheritedData of(BuildContext context) {\n    assert(debugCheckHasAncestor<InheritedData>('$FSlider', context));\n    return context.dependOnInheritedWidgetOfExactType<InheritedData>()!;\n  }\n\n  final FSliderStyle style;\n  final FLayout layout;\n  final List<FSliderMark> marks;\n  final double? trackMainAxisExtent;\n  final double? trackHitRegionCrossExtent;\n  final Widget Function(FTooltipController controller, double value) tooltipBuilder;\n  final String Function(FSliderSelection) semanticFormatterCallback;\n  final String Function(double) semanticValueFormatterCallback;\n  final bool enabled;\n\n  const InheritedData({\n    required this.style,\n    required this.layout,\n    required this.marks,\n    required this.trackMainAxisExtent,\n    required this.trackHitRegionCrossExtent,\n    required this.tooltipBuilder,\n    required this.semanticFormatterCallback,\n    required this.semanticValueFormatterCallback,\n    required this.enabled,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  bool updateShouldNotify(covariant InheritedData old) =>\n      style != old.style ||\n      layout != old.layout ||\n      !marks.equals(marks) ||\n      trackMainAxisExtent != old.trackMainAxisExtent ||\n      trackHitRegionCrossExtent != old.trackHitRegionCrossExtent ||\n      tooltipBuilder != old.tooltipBuilder ||\n      semanticFormatterCallback != old.semanticFormatterCallback ||\n      semanticValueFormatterCallback != old.semanticValueFormatterCallback ||\n      enabled != old.enabled;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(EnumProperty('layout', layout))\n      ..add(IterableProperty('marks', marks))\n      ..add(DoubleProperty('trackMainAxisExtent', trackMainAxisExtent))\n      ..add(DoubleProperty('trackHitRegionCrossExtent', trackHitRegionCrossExtent))\n      ..add(ObjectFlagProperty.has('tooltipBuilder', tooltipBuilder))\n      ..add(ObjectFlagProperty.has('semanticFormatterCallback', semanticFormatterCallback))\n      ..add(ObjectFlagProperty.has('semanticFormatterCallback', semanticValueFormatterCallback))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'));\n  }\n}\n",
      "inherited_state": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/debug.dart';\n\n@internal\nclass InheritedStates extends InheritedWidget {\n  static InheritedStates of(BuildContext context) {\n    assert(debugCheckHasAncestor<InheritedStates>('$FSlider', context));\n    return context.dependOnInheritedWidgetOfExactType<InheritedStates>()!;\n  }\n\n  final Set<WidgetState> states;\n\n  const InheritedStates({required this.states, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(InheritedStates old) => !setEquals(states, states);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(IterableProperty('states', states));\n  }\n}\n",
      "slider": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:collection/collection.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/slider/form_field.dart';\nimport 'package:forui/src/widgets/slider/inherited_controller.dart';\nimport 'package:forui/src/widgets/slider/inherited_data.dart';\n\n/// An input where the user selects a value from within a given range.\n///\n/// A slider is a form field and therefore can be used within a [Form] widget.\n///\n/// See:\n/// * https://forui.dev/docs/form/slider for working examples.\n/// * [FContinuousSliderController.new] for selecting a single continuous value.\n/// * [FContinuousSliderController.range] for selecting continuous range.\n/// * [FDiscreteSliderController.new] for selecting a discrete value.\n/// * [FDiscreteSliderController.range] for selecting a discrete range.\n/// * [FSliderStyles] for customizing a slider's appearance.\nclass FSlider extends StatelessWidget with FFormFieldProperties<FSliderSelection> {\n  static Widget _tooltipBuilder(FTooltipController _, double value) => Text('${(value * 100).toStringAsFixed(0)}%');\n\n  static String _semanticValueFormatter(double value) => '${(value * 100).toStringAsFixed(0)}%';\n\n  /// The controller. Defaults to [FContinuousSliderController.new].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * Both [controller] and [initialSelection] are provided.\n  final FSliderController? controller;\n\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create sliders\n  /// ```\n  final FSliderStyle Function(FSliderStyle style)? style;\n\n  /// The layout. Defaults to the current [TextDirection].\n  final FLayout? layout;\n\n  /// The marks.\n  final List<FSliderMark> marks;\n\n  /// The initial selection.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * Both [controller] and [initialSelection] are provided.\n  final FSliderSelection? initialSelection;\n\n  /// The extent of the track along the main axis. Defaults to occupying the maximum amount of space possible along the\n  /// main axis.\n  ///\n  /// **Contract**:\n  /// Throws [AssertionError] if [trackMainAxisExtent] is not positive.\n  ///\n  /// Throws [StateError] if [trackMainAxisExtent], either [label], [description], or [forceErrorText] is given,\n  /// and [layout] is vertical.\n  final double? trackMainAxisExtent;\n\n  /// The extent of the track's hit region in the cross-axis direction.\n  ///\n  /// Defaults to:\n  /// * either the tracker the thumb's cross extent, whichever is larger, on primarily touch devices.\n  /// * 0 on non-primarily touch devices.\n  final double? trackHitRegionCrossExtent;\n\n  /// A builder that creates the tooltip. Defaults to printing the current percentage.\n  final Widget Function(FTooltipController controller, double value) tooltipBuilder;\n\n  /// A callback that formats the semantic label for the slider. Defaults to announcing the percentages the active track\n  /// occupies.\n  final String Function(FSliderSelection)? semanticFormatterCallback;\n\n  /// A callback that formats the semantic label for the slider's thumb. Defaults to announcing the percentage.\n  ///\n  /// In practice, this is mostly useful for range sliders.\n  final String Function(double) semanticValueFormatterCallback;\n\n  @override\n  final Widget? label;\n\n  @override\n  final Widget? description;\n\n  @override\n  final Widget Function(BuildContext context, String message) errorBuilder;\n\n  @override\n  final bool enabled;\n\n  /// Handler for when the slider value changes.\n  final ValueChanged<FSliderSelection>? onChange;\n\n  @override\n  final FormFieldSetter<FSliderSelection>? onSaved;\n\n  @override\n  final VoidCallback? onReset;\n\n  @override\n  final FormFieldValidator<FSliderSelection>? validator;\n\n  @override\n  final AutovalidateMode autovalidateMode;\n\n  @override\n  final String? forceErrorText;\n\n  /// Creates a [FSlider].\n  FSlider({\n    required this.controller,\n    this.style,\n    this.layout,\n    this.label,\n    this.description,\n    this.errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    this.marks = const [],\n    this.initialSelection,\n    this.trackMainAxisExtent,\n    this.trackHitRegionCrossExtent,\n    this.tooltipBuilder = _tooltipBuilder,\n    this.semanticValueFormatterCallback = _semanticValueFormatter,\n    this.semanticFormatterCallback,\n    this.onChange,\n    this.onSaved,\n    this.onReset,\n    this.validator,\n    this.forceErrorText,\n    this.enabled = true,\n    this.autovalidateMode = AutovalidateMode.disabled,\n    super.key,\n  }) : assert(\n         controller == null || initialSelection == null,\n         'Cannot provide both controller and initialSelection at the same time',\n       ) {\n    if (trackMainAxisExtent == null &&\n        (label != null || description != null || forceErrorText != null) &&\n        (layout?.vertical ?? false)) {\n      throw StateError(\n        'A vertical FSlider was given a label, description, or forceErrorText although it needs a trackMainAxisExtent. '\n        'To fix this, consider supplying a trackMainAxisExtent or changing the layout to horizontal.',\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final layout = switch (this.layout) {\n      final layout? => layout,\n      _ when Directionality.maybeOf(context) == TextDirection.rtl => FLayout.rtl,\n      _ => FLayout.ltr,\n    };\n\n    final styles = context.theme.sliderStyles;\n    final inheritedStyle = (layout.vertical ? styles.verticalStyle : styles.horizontalStyle);\n    final sliderStyle = style?.call(inheritedStyle) ?? inheritedStyle;\n\n    return LayoutBuilder(\n      builder: (_, constraints) => _Slider(\n        controller: controller,\n        style: sliderStyle,\n        layout: layout,\n        label: label,\n        description: description,\n        errorBuilder: errorBuilder,\n        marks: marks,\n        textDirection: Directionality.maybeOf(context) ?? TextDirection.ltr,\n        constraints: constraints,\n        mainAxisExtent: trackMainAxisExtent,\n        trackHitRegionCrossExtent: trackHitRegionCrossExtent,\n        tooltipBuilder: tooltipBuilder,\n        semanticFormatterCallback: semanticFormatterCallback,\n        semanticValueFormatterCallback: semanticValueFormatterCallback,\n        initialSelection: initialSelection,\n        onSaved: onSaved,\n        onReset: onReset,\n        validator: validator,\n        autovalidateMode: autovalidateMode,\n        forceErrorText: forceErrorText,\n        enabled: enabled,\n        onChange: onChange,\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(EnumProperty('layout', layout))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder))\n      ..add(IterableProperty('marks', marks))\n      ..add(DiagnosticsProperty('initialSelection', initialSelection))\n      ..add(DoubleProperty('trackMainAxisExtent', trackMainAxisExtent))\n      ..add(DoubleProperty('trackHitRegionCrossExtent', trackHitRegionCrossExtent))\n      ..add(ObjectFlagProperty.has('tooltipBuilder', tooltipBuilder))\n      ..add(ObjectFlagProperty.has('semanticFormatterCallback', semanticFormatterCallback))\n      ..add(ObjectFlagProperty.has('semanticValueFormatterCallback', semanticValueFormatterCallback))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onSaved', onSaved))\n      ..add(ObjectFlagProperty.has('validator', validator))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'))\n      ..add(EnumProperty('autovalidateMode', autovalidateMode))\n      ..add(ObjectFlagProperty.has('forceErrorText', forceErrorText));\n  }\n}\n\nclass _Slider extends StatefulWidget {\n  final FSliderController? controller;\n  final FSliderStyle style;\n  final FLayout layout;\n  final Widget? label;\n  final Widget? description;\n  final Widget Function(BuildContext context, String message) errorBuilder;\n  final List<FSliderMark> marks;\n  final FSliderSelection? initialSelection;\n  final TextDirection textDirection;\n  final BoxConstraints constraints;\n  final double? mainAxisExtent;\n  final double? trackHitRegionCrossExtent;\n  final Widget Function(FTooltipController controller, double value) tooltipBuilder;\n  final String Function(FSliderSelection)? semanticFormatterCallback;\n  final String Function(double) semanticValueFormatterCallback;\n  final ValueChanged<FSliderSelection>? onChange;\n  final FormFieldSetter<FSliderSelection>? onSaved;\n  final VoidCallback? onReset;\n  final FormFieldValidator<FSliderSelection>? validator;\n  final AutovalidateMode? autovalidateMode;\n  final String? forceErrorText;\n  final bool enabled;\n\n  const _Slider({\n    required this.controller,\n    required this.style,\n    required this.layout,\n    required this.label,\n    required this.description,\n    required this.errorBuilder,\n    required this.marks,\n    required this.initialSelection,\n    required this.textDirection,\n    required this.constraints,\n    required this.mainAxisExtent,\n    required this.trackHitRegionCrossExtent,\n    required this.tooltipBuilder,\n    required this.semanticFormatterCallback,\n    required this.semanticValueFormatterCallback,\n    required this.onChange,\n    required this.onSaved,\n    required this.onReset,\n    required this.validator,\n    required this.autovalidateMode,\n    required this.forceErrorText,\n    required this.enabled,\n  });\n\n  @override\n  State<_Slider> createState() => _SliderState();\n\n  double get _mainAxisExtent {\n    final insets = style.childPadding.resolve(textDirection);\n    final extent = switch (mainAxisExtent) {\n      final extent? => extent,\n      _ when layout.vertical => constraints.maxHeight - insets.top - insets.bottom,\n      _ => constraints.maxWidth - insets.left - insets.right,\n    };\n\n    if (extent.isInfinite) {\n      throw FlutterError(switch (layout.vertical) {\n        true =>\n          'A vertical FSlider was given an infinite height although it needs a finite height. To fix this, '\n              'consider supplying a mainAxisExtent or placing FSlider in a SizedBox.',\n        false =>\n          'A horizontal FSlider was given an infinite width although it needs a finite width. To fix this, '\n              'consider supplying a mainAxisExtent or placing FSlider in a SizedBox.',\n      });\n    }\n\n    return extent - style.thumbSize;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(EnumProperty('layout', layout))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder))\n      ..add(IterableProperty('marks', marks))\n      ..add(EnumProperty('textDirection', textDirection))\n      ..add(DiagnosticsProperty('constraints', constraints))\n      ..add(DoubleProperty('mainAxisExtent', mainAxisExtent))\n      ..add(ObjectFlagProperty.has('onSaved', onSaved))\n      ..add(ObjectFlagProperty.has('onReset', onReset))\n      ..add(ObjectFlagProperty.has('validator', validator))\n      ..add(EnumProperty('autovalidateMode', autovalidateMode))\n      ..add(ObjectFlagProperty.has('forceErrorText', forceErrorText))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled', ifFalse: 'disabled'))\n      ..add(ObjectFlagProperty.has('trackHitRegionCrossExtent', trackHitRegionCrossExtent))\n      ..add(DiagnosticsProperty('initialSelection', initialSelection))\n      ..add(ObjectFlagProperty.has('tooltipBuilder', tooltipBuilder))\n      ..add(ObjectFlagProperty.has('semanticFormatterCallback', semanticFormatterCallback))\n      ..add(ObjectFlagProperty.has('semanticValueFormatterCallback', semanticValueFormatterCallback))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n\nclass _SliderState extends State<_Slider> {\n  late FSliderController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = _createController();\n    _controller\n      ..attach(widget._mainAxisExtent, widget.marks)\n      ..addListener(_onChange);\n  }\n\n  @override\n  void didUpdateWidget(covariant _Slider old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        old.controller?.removeListener(_onChange);\n      }\n\n      _controller = _createController();\n      _controller\n        ..attach(widget._mainAxisExtent, widget.marks)\n        ..addListener(_onChange);\n    } else if (widget.layout != old.layout ||\n        widget._mainAxisExtent != old._mainAxisExtent ||\n        !widget.marks.equals(old.marks)) {\n      _controller.attach(widget._mainAxisExtent, widget.marks);\n    }\n  }\n\n  FSliderController _createController() =>\n      widget.controller ?? FContinuousSliderController(selection: widget.initialSelection ?? FSliderSelection(max: 0));\n\n  void _onChange() => widget.onChange?.call(_controller.selection);\n\n  @override\n  Widget build(BuildContext _) => InheritedData(\n    style: widget.style,\n    layout: widget.layout,\n    marks: widget.marks,\n    trackMainAxisExtent: widget.mainAxisExtent,\n    trackHitRegionCrossExtent: widget.trackHitRegionCrossExtent,\n    enabled: widget.enabled,\n    tooltipBuilder: widget.tooltipBuilder,\n    semanticFormatterCallback: widget.semanticFormatterCallback ?? formatter,\n    semanticValueFormatterCallback: widget.semanticValueFormatterCallback,\n    child: ListenableBuilder(\n      listenable: _controller,\n      builder: (_, _) => InheritedController(\n        controller: _controller,\n        child: SliderFormField(\n          controller: _controller,\n          constraints: widget.constraints,\n          label: widget.label,\n          description: widget.description,\n          errorBuilder: widget.errorBuilder,\n          onSaved: widget.onSaved,\n          onReset: widget.onReset,\n          validator: widget.validator,\n          autovalidateMode: widget.autovalidateMode ?? AutovalidateMode.disabled,\n          forceErrorText: widget.forceErrorText,\n          enabled: widget.enabled,\n        ),\n      ),\n    ),\n  );\n\n  String Function(FSliderSelection) get formatter => switch (_controller.extendable) {\n    (min: true, max: false) => (selection) => '${(selection.offset.min * 100).toStringAsFixed(0)}%',\n    (min: false, max: true) => (selection) => '${(selection.offset.max * 100).toStringAsFixed(0)}%',\n    (min: true, max: true) || (min: false, max: false) =>\n      (selection) =>\n          '${(selection.offset.min * 100).toStringAsFixed(0)}% - ${(selection.offset.max * 100).toStringAsFixed(0)}%',\n  };\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeListener(_onChange);\n    }\n    super.dispose();\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(ObjectFlagProperty<String Function(FSliderSelection p1)>.has('formatter', formatter));\n  }\n}\n",
      "slider_controller": "import 'dart:collection';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/slider/slider_selection.dart';\n\n/// Possible ways for a user to interact with a slider.\nenum FSliderInteraction {\n  /// Allows the user to interact with the slider by sliding anywhere on the track.\n  slide,\n\n  /// Allows the user to interact with the slider by sliding only the slider thumb.\n  slideThumb,\n\n  /// Allows the user to interact with the slider by tapping and sliding the slider thumb.\n  tapAndSlideThumb,\n\n  /// Allows the user to interact with the slider by tapping anywhere.\n  tap,\n}\n\n/// A controller that manages a slider's active track.\n///\n/// This class should be extended to customize selection. By default, the following controllers are provided:\n/// * [FContinuousSliderController.new] for selecting a single continuous value.\n/// * [FContinuousSliderController.range] for selecting continuous range.\n/// * [FDiscreteSliderController.new] for selecting a discrete value.\n/// * [FDiscreteSliderController.range] for selecting a discrete range.\nabstract class FSliderController extends FChangeNotifier {\n  /// True if the registered tooltip(s) should be shown when the user interacts with the slider. Defaults to true.\n  final FSliderTooltipsController tooltips;\n\n  /// The allowed ways to interaction with the slider. Defaults to [FSliderInteraction.tapAndSlideThumb].\n  final FSliderInteraction allowedInteraction;\n\n  /// Whether the active track is extendable at its min and max edges.\n  final ({bool min, bool max}) extendable;\n\n  final FSliderSelection _initialSelection;\n  FSliderSelection? _selection;\n\n  /// Creates a [FSliderController] for selecting a single value.\n  FSliderController({\n    required FSliderSelection selection,\n    this.allowedInteraction = FSliderInteraction.tapAndSlideThumb,\n    bool tooltips = true,\n    bool minExtendable = false,\n  }) : tooltips = FSliderTooltipsController(enabled: tooltips),\n       extendable = (min: minExtendable, max: !minExtendable),\n       _initialSelection = selection;\n\n  /// Creates a [FSliderController] for selecting a range.\n  FSliderController.range({required FSliderSelection selection, bool tooltips = true})\n    : tooltips = FSliderTooltipsController(enabled: tooltips),\n      allowedInteraction = FSliderInteraction.tapAndSlideThumb,\n      extendable = (min: true, max: true),\n      _initialSelection = selection;\n\n  /// Registers the controller to a slider with the given extent and marks.\n  ///\n  /// A controller can only be attached to a single slider at a time.\n  void attach(double extent, List<FSliderMark> marks);\n\n  /// Moves the active track on the [min] edge to the previous/next step.\n  void step({required bool min, required bool extend}) {\n    if (_selection case final selection?) {\n      this.selection = selection.step(min: min, extend: extend);\n    }\n  }\n\n  /// Slides the active track to the given [offset] on the [min] edge, in logical pixels.\n  ///\n  /// The delta is relative to the origin defined by [FSlider.layout].\n  void slide(double offset, {required bool min}) {\n    if (allowedInteraction == FSliderInteraction.tap) {\n      return;\n    }\n\n    assert(min ? extendable.min : extendable.max, 'Slider is not extendable at the ${min ? 'min' : 'max'} edge.');\n\n    if (_selection case final selection?) {\n      this.selection = selection.move(min: min, to: offset);\n    }\n  }\n\n  /// Taps the slider at given offset, in logical pixels, along the track.\n  ///\n  /// Returns:\n  /// * true if the offset moves the min edge\n  /// * false if the offset moves the max edge\n  /// * null if the offset did not move either edge\n  ///\n  /// The offset is relative to the origin defined by [FSlider.layout].\n  bool? tap(double offset) {\n    if (allowedInteraction == FSliderInteraction.slide || allowedInteraction == FSliderInteraction.slideThumb) {\n      return null;\n    }\n\n    if (_selection case final selection?) {\n      final min = switch (extendable) {\n        (min: true, max: true) when offset < selection.rawOffset.min => true,\n        (min: true, max: true) when selection.rawOffset.max < offset => false,\n        (min: true, max: false) => true,\n        (min: false, max: true) => false,\n        _ => null,\n      };\n\n      if (min != null) {\n        this.selection = selection.move(min: min, to: offset);\n      }\n\n      return min;\n    }\n\n    return null;\n  }\n\n  /// Resets the controller to its initial state.\n  void reset();\n\n  /// The slider's active track/selection.\n  FSliderSelection get selection => _selection ?? _initialSelection;\n\n  set selection(FSliderSelection? selection) {\n    if (selection == null || _selection == selection) {\n      return;\n    }\n\n    _selection = selection;\n    notifyListeners();\n  }\n}\n\n/// A controller that manages a slider's active track which represents a continuous range/value.\nclass FContinuousSliderController extends FSliderController {\n  /// The percentage of the track that represents a single step. Defaults to 0.05.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if it is not between 0 and 1, inclusive.\n  final double stepPercentage;\n\n  /// Creates a [FContinuousSliderController] for selecting a single value.\n  FContinuousSliderController({\n    required super.selection,\n    this.stepPercentage = 0.05,\n    super.tooltips = true,\n    super.allowedInteraction,\n    super.minExtendable,\n  }) : assert(\n         0 <= stepPercentage && stepPercentage <= 1,\n         'stepPercentage ($stepPercentage) must be between 0 and 1, inclusive.',\n       );\n\n  /// Creates a [FContinuousSliderController] for selecting a range.\n  FContinuousSliderController.range({required super.selection, this.stepPercentage = 0.05, super.tooltips = true})\n    : assert(\n        0 <= stepPercentage && stepPercentage <= 1,\n        'stepPercentage ($stepPercentage) must be between 0 and 1, inclusive.',\n      ),\n      super.range();\n\n  @override\n  @internal\n  void attach(double extent, List<FSliderMark> _) {\n    final proposed = ContinuousSelection(\n      step: stepPercentage,\n      mainAxisExtent: extent,\n      extent: selection.extent,\n      offset: selection.offset,\n    );\n\n    if (_selection == null) {\n      _selection = proposed; // We don't want to notify listeners when performing initialization.\n    } else {\n      selection = proposed;\n    }\n  }\n\n  @override\n  void reset() {\n    if (_selection case final selection?) {\n      this.selection = ContinuousSelection(\n        step: stepPercentage,\n        mainAxisExtent: selection.rawExtent.total,\n        extent: _initialSelection.extent,\n        offset: _initialSelection.offset,\n      );\n    }\n  }\n}\n\n/// A controller that manages a slider's active track which represents a discrete range/value.\nclass FDiscreteSliderController extends FSliderController {\n  /// Creates a [FDiscreteSliderController] for selecting a single value.\n  FDiscreteSliderController({\n    required super.selection,\n    super.allowedInteraction,\n    super.tooltips = true,\n    super.minExtendable,\n  });\n\n  /// Creates a [FDiscreteSliderController] for selecting a range.\n  FDiscreteSliderController.range({required super.selection, super.tooltips = true}) : super.range();\n\n  @override\n  void attach(double extent, List<FSliderMark> marks) {\n    assert(marks.isNotEmpty, 'At least one mark is required.');\n\n    final proposed = DiscreteSelection(\n      mainAxisExtent: extent,\n      extent: selection.extent,\n      offset: selection.offset,\n      ticks: SplayTreeMap.fromIterable(marks.map((mark) => mark.value), value: (_) {}),\n    );\n\n    if (_selection == null) {\n      _selection = proposed; // We don't want to notify listeners when performing initialization.\n    } else {\n      selection = proposed;\n    }\n  }\n\n  @override\n  void reset() {\n    if (_selection case final DiscreteSelection discrete?) {\n      selection = DiscreteSelection(\n        ticks: discrete.ticks,\n        mainAxisExtent: discrete.rawExtent.total,\n        extent: _initialSelection.extent,\n        offset: _initialSelection.offset,\n      );\n    }\n  }\n}\n",
      "slider_mark": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'slider_mark.design.dart';\n\n/// A mark in a [FSlider]. It is a combination of a tick - a visual indicator along the track, and a label.\nclass FSliderMark with Diagnosticable {\n  /// The mark's style.\n  final FSliderMarkStyle? style;\n\n  /// The offset in the slider's track at which to position this mark, in percentage.\n  ///\n  /// For example, if the value is `0.5`, the mark will be positioned in the middle of the slider's bar.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if it is not between `0` and `1`, inclusive.\n  final double value;\n\n  /// True if a tick should be shown. Defaults to true.\n  final bool tick;\n\n  /// The mark's label.\n  final Widget? label;\n\n  /// Creates a [FSliderMark] at the given percentage in a slider.\n  const FSliderMark({required this.value, this.style, this.tick = true, this.label})\n    : assert(0 <= value && value <= 1, 'value ($value) must be between 0.0 and 1.0, inclusive.');\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DoubleProperty('offset', value))\n      ..add(FlagProperty('tick', value: tick, ifTrue: 'tick'));\n  }\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is FSliderMark &&\n          runtimeType == other.runtimeType &&\n          style == other.style &&\n          value == other.value &&\n          tick == other.tick &&\n          label == other.label;\n\n  @override\n  int get hashCode => style.hashCode ^ value.hashCode ^ tick.hashCode ^ label.hashCode;\n}\n\n/// A [FSlider] mark's style.\nclass FSliderMarkStyle with Diagnosticable, _$FSliderMarkStyleFunctions {\n  /// The tick's color.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.form}\n  @override\n  final FWidgetStateMap<Color> tickColor;\n\n  /// The tick's size. Defaults to 3.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if it is not positive.\n  @override\n  final double tickSize;\n\n  /// The label's default text style.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.form}\n  @override\n  final FWidgetStateMap<TextStyle> labelTextStyle;\n\n  /// The label's anchor to which the [labelOffset] is applied.\n  @override\n  final AlignmentGeometry labelAnchor;\n\n  /// The label's offset from the slider, along its cross axis, in logical pixels. The top-left corner is always the\n  /// origin, regardless of the layout.\n  ///\n  /// For example, if the layout is [FLayout.ltr] and the cross axis offset is 3, the label will be 3 pixels below the\n  /// slider's edge.\n  ///\n  /// ```diagram\n  /// |--------------------------|\n  /// |----------[tick]----------|\n  /// |__________________________|\n  ///              (1)\n  ///              (2)\n  ///              (3)\n  ///            [label]\n  /// ```\n  ///\n  /// Given the same layout, if the cross axis offset is -3, the label will be 3 pixels above the slider's edge.\n  ///\n  /// ```diagram\n  ///            [label]\n  ///              (3)\n  ///              (2)\n  ///              (1)\n  /// |--------------------------|\n  /// |----------[tick]----------|\n  /// |__________________________|\n  /// ```\n  @override\n  final double labelOffset;\n\n  /// Creates a [FSliderMarkStyle].\n  const FSliderMarkStyle({\n    required this.tickColor,\n    required this.labelTextStyle,\n    required this.labelAnchor,\n    required this.labelOffset,\n    this.tickSize = 3,\n  }) : assert(0 < tickSize, 'tickSize ($tickSize) must be > 0');\n}\n",
      "slider_render_object": "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\n\nimport 'package:collection/collection.dart';\nimport 'package:sugar/sugar.dart' hide Offset;\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/foundation/rendering.dart';\nimport 'package:forui/src/widgets/slider/inherited_data.dart';\n\n@internal\nclass HorizontalSliderRenderObject extends _SliderRenderObject {\n  const HorizontalSliderRenderObject({super.children, super.key});\n\n  @override\n  RenderObject createRenderObject(BuildContext context) {\n    final InheritedData(:style, :layout, :marks, :trackMainAxisExtent) = InheritedData.of(context);\n    final labelledMarks = marks.where((mark) => mark.label != null).toList();\n    final direction = Directionality.maybeOf(context) ?? TextDirection.ltr;\n    return _RenderHorizontalSlider(style, layout, direction, labelledMarks, trackMainAxisExtent);\n  }\n}\n\n@internal\nclass VerticalSliderRenderObject extends _SliderRenderObject {\n  const VerticalSliderRenderObject({super.children, super.key});\n\n  @override\n  RenderObject createRenderObject(BuildContext context) {\n    final InheritedData(:style, :layout, :marks, :trackMainAxisExtent) = InheritedData.of(context);\n    final labelledMarks = marks.where((mark) => mark.label != null).toList();\n    final direction = Directionality.maybeOf(context) ?? TextDirection.ltr;\n    return _RenderVerticalSlider(style, layout, direction, labelledMarks, trackMainAxisExtent);\n  }\n}\n\nabstract class _SliderRenderObject extends MultiChildRenderObjectWidget {\n  const _SliderRenderObject({super.key, super.children});\n\n  @override\n  void updateRenderObject(BuildContext context, covariant _RenderSlider slider) {\n    final InheritedData(:style, :layout, :marks, :trackMainAxisExtent) = InheritedData.of(context);\n    slider\n      ..style = style\n      ..sliderLayout = layout\n      ..textDirection = Directionality.maybeOf(context) ?? TextDirection.ltr\n      ..marks = marks.where((mark) => mark.label != null).toList()\n      ..mainAxisExtent = trackMainAxisExtent;\n  }\n}\n\nclass _RenderHorizontalSlider extends _RenderSlider {\n  _RenderHorizontalSlider(super._style, super._layout, super._textDirection, super._marks, super._mainAxisExtent);\n\n  @override\n  void performLayout() {\n    final loosened = constraints.loosen();\n\n    // Layout parts, assuming top-left corner of track/origin is (0, 0).\n    final insets = _style.childPadding.resolve(_textDirection);\n    final (:label, :paddedTrack, :description, :error, :slider) = layoutParts(loosened, switch (_mainAxisExtent) {\n      final extent? => loosened.copyWith(maxWidth: extent + insets.left + insets.right),\n      null => loosened,\n    });\n\n    // Calculate offset to move the top/left corner of track/origin from (0, 0), such that no part of the slider has a\n    // negative offset.\n    final boxes = [label, paddedTrack, description, error];\n    final largest = boxes.order(by: (box) => box.size.width).max!;\n    boxes.remove(largest);\n\n    // Check whether the marks are larger than the largest label/description/error.\n    final sliderOffset = Offset(\n      0,\n      label.size.height + (slider.marks.values.map((r) => r.top).where((y) => y.isNegative).minOrNull?.abs() ?? 0),\n    );\n\n    paddedTrack.data.offset = sliderOffset;\n    for (final MapEntry(key: label, value: rect) in slider.marks.entries) {\n      label.data.offset = rect.topLeft + sliderOffset;\n    }\n\n    var height = label.size.height + slider.size.height;\n    description.data.offset = Offset(0, height);\n\n    height += description.size.height;\n    error.data.offset = Offset(0, height);\n\n    final width = [label.size, slider.size, description.size, error.size].order(by: (size) => size.width).max!.width;\n    size = constraints.constrain(Size(width, height + error.size.height));\n  }\n}\n\nclass _RenderVerticalSlider extends _RenderSlider {\n  _RenderVerticalSlider(super._style, super._layout, super._textDirection, super._marks, super._mainAxisExtent);\n\n  @override\n  void performLayout() {\n    final loosened = constraints.loosen();\n\n    // Layout parts, assuming top-left corner of track/origin is (0, 0).\n    final insets = _style.childPadding.resolve(_textDirection);\n    final (:label, :paddedTrack, :description, :error, :slider) = layoutParts(loosened, switch (_mainAxisExtent) {\n      final extent? => loosened.copyWith(maxHeight: extent + insets.top + insets.bottom),\n      null => loosened,\n    });\n\n    // Calculate offset to move the top/left corner of track/origin from (0, 0), such that no part of the slider has a\n    // negative offset.\n    final boxes = [label, paddedTrack, description, error];\n    final largest = boxes.order(by: (box) => box.size.width).max!;\n    boxes.remove(largest);\n\n    // Check whether the marks are larger than the largest label/description/error.\n    final largestMiddleOffset = largest.size.bottomCenter(Offset.zero).dx;\n    final marksOffset = slider.marks.values.map((rect) => rect.left).where((x) => x.isNegative).minOrNull?.abs() ?? 0;\n\n    final double middle;\n    final double largestOffset;\n    final Offset sliderOffset;\n\n    if (largestMiddleOffset < marksOffset) {\n      middle = marksOffset;\n      sliderOffset = Offset(marksOffset, label.size.height);\n      largestOffset = marksOffset + paddedTrack.size.width / 2;\n    } else {\n      middle = largestMiddleOffset;\n      sliderOffset = Offset(largestMiddleOffset - paddedTrack.size.width / 2, label.size.height);\n      largestOffset = 0.0;\n    }\n\n    // Center align the slider's parts.\n    largest.data.offset = Offset(max(largestOffset - largest.size.width / 2, 0), 0);\n    for (final box in boxes) {\n      box.data.offset = Offset(middle - box.size.width / 2, 0);\n    }\n\n    paddedTrack.data.offset = sliderOffset;\n    for (final MapEntry(key: label, value: rect) in slider.marks.entries) {\n      label.data.offset = rect.topLeft + sliderOffset;\n    }\n\n    var height = label.size.height + slider.size.height;\n    description.data.offset = Offset(description.data.offset.dx, height);\n\n    height += description.size.height;\n    error.data.offset = Offset(error.data.offset.dx, height);\n\n    final width = max(largest.size.width, (sliderOffset & slider.size).right);\n    size = constraints.constrain(Size(width, height + error.size.height));\n  }\n}\n\ntypedef _Parts = ({\n  RenderBox paddedTrack,\n  RenderBox label,\n  RenderBox description,\n  RenderBox error,\n  ({Map<RenderBox, Rect> marks, Size size}) slider,\n});\n\nabstract class _RenderSlider extends RenderBox\n    with ContainerRenderObjectMixin<RenderBox, DefaultData>, RenderBoxContainerDefaultsMixin<RenderBox, DefaultData> {\n  FSliderStyle _style;\n  FLayout _layout;\n  TextDirection _textDirection;\n  List<FSliderMark> _marks;\n  double? _mainAxisExtent;\n  late Rect Function(RenderBox, Size, FSliderMark, FSliderMarkStyle) _positionMark;\n\n  _RenderSlider(this._style, this._layout, this._textDirection, this._marks, this._mainAxisExtent) {\n    _positionMark = _position;\n  }\n\n  @override\n  void setupParentData(covariant RenderObject child) => child.parentData = DefaultData();\n\n  _Parts layoutParts(BoxConstraints constraints, BoxConstraints trackMainAxis) {\n    final paddedTrack = firstChild!..layout(trackMainAxis, parentUsesSize: true);\n\n    final label = childAfter(paddedTrack)!..layout(constraints, parentUsesSize: true);\n    final description = childAfter(label)!..layout(constraints, parentUsesSize: true);\n    final error = childAfter(description)!..layout(constraints, parentUsesSize: true);\n\n    final (marks, sliderSize) = _layoutMarks(constraints, paddedTrack, childAfter(error));\n\n    return (\n      paddedTrack: paddedTrack,\n      label: label,\n      description: description,\n      error: error,\n      slider: (marks: marks, size: sliderSize),\n    );\n  }\n\n  (Map<RenderBox, Rect>, Size) _layoutMarks(BoxConstraints constraints, RenderBox paddedTrack, RenderBox? label) {\n    final marks = <RenderBox, Rect>{};\n    var minX = 0.0;\n    var minY = 0.0;\n    var maxX = paddedTrack.size.width;\n    var maxY = paddedTrack.size.height;\n\n    final positionMark = _positionMark;\n    for (final mark in _marks) {\n      if (label == null) {\n        break;\n      }\n\n      label.layout(constraints, parentUsesSize: true);\n\n      final rect = positionMark(paddedTrack, label.size, mark, mark.style ?? _style.markStyle);\n      marks[label] = rect;\n\n      minX = min(minX, rect.left);\n      maxX = max(maxX, rect.right);\n      minY = min(minY, rect.top);\n      maxY = max(maxY, rect.bottom);\n\n      label = childAfter(label);\n    }\n\n    return (marks, Size(maxX - minX, maxY - minY));\n  }\n\n  Rect Function(RenderBox, Size, FSliderMark, FSliderMarkStyle) get _position {\n    final insets = _style.childPadding.resolve(_textDirection);\n    return switch (_layout) {\n      FLayout.ltr => (track, size, mark, style) {\n        final extent = track.size.width - insets.left - insets.right;\n        final offset = _anchor(extent, mark.value, insets.left, insets.top, style);\n        return _rect(size, Offset(offset.$1, offset.$2), style);\n      },\n      FLayout.rtl => (track, size, mark, style) {\n        final extent = track.size.width - insets.left - insets.right;\n        final offset = _anchor(extent, 1 - mark.value, insets.left, insets.top, style);\n        return _rect(size, Offset(offset.$1, offset.$2), style);\n      },\n      FLayout.ttb => (track, size, mark, style) {\n        final extent = track.size.height - insets.top - insets.bottom;\n        final offset = _anchor(extent, mark.value, insets.top, insets.left, style);\n        return _rect(size, Offset(offset.$2, offset.$1), style);\n      },\n      FLayout.btt => (track, size, mark, style) {\n        final extent = track.size.height - insets.top - insets.bottom;\n        final offset = _anchor(extent, 1 - mark.value, insets.top, insets.left, style);\n        return _rect(size, Offset(offset.$2, offset.$1), style);\n      },\n    };\n  }\n\n  (double, double) _anchor(\n    double extent,\n    double offset,\n    double mainAxisPadding,\n    double crossAxisPadding,\n    FSliderMarkStyle markStyle,\n  ) {\n    final thumb = _style.thumbSize;\n    final trackMainAxis = (extent - thumb) * offset;\n    final anchorMainAxis = (thumb / 2) + trackMainAxis + mainAxisPadding;\n\n    final crossAxisExtent = _style.crossAxisExtent < thumb ? thumb : _style.crossAxisExtent;\n    final crossAxisOffset = crossAxisPadding + (markStyle.labelOffset < 0 ? 0.0 : crossAxisExtent);\n    final anchorCrossAxis = markStyle.labelOffset + crossAxisOffset;\n\n    return (anchorMainAxis, anchorCrossAxis);\n  }\n\n  Rect _rect(Size size, Offset anchor, FSliderMarkStyle markStyle) {\n    final rect = anchor & size;\n    return rect.shift(anchor - markStyle.labelAnchor.resolve(_textDirection).relative(to: size, origin: anchor));\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    // We paint the labels first, then the track so that the thumb is painted on top of the labels.\n    var child = lastChild;\n    while (child != null) {\n      final childParentData = child.parentData! as DefaultData;\n      context.paintChild(child, childParentData.offset + offset);\n      child = childParentData.previousSibling;\n    }\n  }\n\n  @override\n  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) =>\n      defaultHitTestChildren(result, position: position);\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(EnumProperty('layout', sliderLayout))\n      ..add(EnumProperty('textDirection', textDirection))\n      ..add(IterableProperty('marks', marks))\n      ..add(DoubleProperty('mainAxisExtent', mainAxisExtent));\n  }\n\n  FSliderStyle get style => _style;\n\n  set style(FSliderStyle value) {\n    if (_style == value) {\n      return;\n    }\n\n    _style = value;\n    _positionMark = _position;\n    markNeedsLayout();\n  }\n\n  FLayout get sliderLayout => _layout;\n\n  set sliderLayout(FLayout value) {\n    if (_layout == value) {\n      return;\n    }\n\n    _layout = value;\n    _positionMark = _position;\n    markNeedsLayout();\n  }\n\n  TextDirection get textDirection => _textDirection;\n\n  set textDirection(TextDirection value) {\n    if (_textDirection == value) {\n      return;\n    }\n\n    _textDirection = value;\n    markNeedsLayout();\n  }\n\n  List<FSliderMark> get marks => _marks;\n\n  set marks(List<FSliderMark> value) {\n    if (_marks.equals(value)) {\n      return;\n    }\n\n    _marks = value;\n    markNeedsLayout();\n  }\n\n  double? get mainAxisExtent => _mainAxisExtent;\n\n  set mainAxisExtent(double? value) {\n    if (_mainAxisExtent == value) {\n      return;\n    }\n\n    _mainAxisExtent = value;\n    markNeedsLayout();\n  }\n}\n",
      "slider_selection": "import 'dart:collection';\n\nimport 'package:flutter/foundation.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\n/// A [FSlider]'s active track/selection.\nsealed class FSliderSelection with Diagnosticable {\n  /// The selection's minimum and maximum extent along the slider's track, in percentage.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * min <= 0\n  /// * max <= min\n  /// * 1 < max\n  final ({double min, double max}) extent;\n\n  /// The selection's current minimum and maximum offset along the slider's track, in percentage.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * min <= 0\n  /// * max <= min\n  /// * 1 <= max\n  /// * total percentage is less than `extent.min`.\n  /// * total percentage is greater than `extent.max`.\n  final ({double min, double max}) offset;\n\n  /// The selection's minimum and maximum extent along the slider's track, in logical pixels.\n  final ({double min, double max, double total}) rawExtent;\n\n  /// The selection's current minimum and maximum offset along the slider's track, in logical pixels.\n  final ({double min, double max}) rawOffset;\n\n  /// Creates a [FSliderSelection].\n  factory FSliderSelection({required double max, double min, ({double min, double max}) extent}) = _Selection;\n\n  FSliderSelection._({\n    required double mainAxisExtent,\n    required ({double min, double max}) extent,\n    required ({double min, double max}) offset,\n  }) : this._copy(\n         extent: extent,\n         offset: offset,\n         rawExtent: (min: extent.min * mainAxisExtent, max: extent.max * mainAxisExtent, total: mainAxisExtent),\n         rawOffset: (min: offset.min * mainAxisExtent, max: offset.max * mainAxisExtent),\n       );\n\n  FSliderSelection._copy({required this.extent, required this.offset, required this.rawExtent, required this.rawOffset})\n    : assert(extent.min >= 0, 'extent.min (${extent.min}) must be >= 0'),\n      assert(extent.max >= extent.min, 'extent.min (${extent.min}) must be <= extent.max (${extent.max})'),\n      assert(extent.max <= 1, 'extent.max (${extent.max}) must be <= 1'),\n      assert(offset.min >= 0, 'offset.min (${offset.min}) must be >= 0'),\n      assert(offset.max >= offset.min, 'offset.min (${offset.min}) must be <= offset.max (${offset.max})'),\n      assert(offset.max <= 1, 'offset.max (${offset.max}) must be <= 1');\n\n  /// Returns a [FSliderSelection] which [min] edge is extended/shrunk to the previous/next step.\n  @useResult\n  FSliderSelection step({required bool min, required bool extend});\n\n  /// Returns a [FSliderSelection] which [min] edge is extended/shrunk to the given offset.\n  @useResult\n  FSliderSelection move({required bool min, required double to});\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(StringProperty('extent', extent.toString()))\n      ..add(StringProperty('offset', offset.toString()))\n      ..add(StringProperty('rawExtent', rawExtent.toString()))\n      ..add(StringProperty('rawOffset', rawOffset.toString()));\n  }\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is FSliderSelection &&\n          runtimeType == other.runtimeType &&\n          extent == other.extent &&\n          offset == other.offset &&\n          rawExtent == other.rawExtent &&\n          rawOffset == other.rawOffset;\n\n  @override\n  int get hashCode => extent.hashCode ^ offset.hashCode ^ rawExtent.hashCode ^ rawOffset.hashCode;\n}\n\nfinal class _Selection extends FSliderSelection {\n  _Selection({required double max, double min = 0, super.extent = (min: 0, max: 1)})\n    : super._copy(offset: (min: min, max: max), rawExtent: (min: 0, max: 0, total: 0), rawOffset: (min: 0, max: 0));\n\n  @override\n  FSliderSelection step({required bool min, required bool extend}) => this;\n\n  @override\n  FSliderSelection move({required bool min, required double to}) => this;\n}\n\n@internal\nfinal class ContinuousSelection extends FSliderSelection {\n  final double _step;\n\n  ContinuousSelection({\n    required double step,\n    required super.mainAxisExtent,\n    required super.extent,\n    required super.offset,\n  }) : assert(0 < step && step <= 1, 'step must be > 0 and <= 1, but is $step.'),\n       _step = step,\n       super._();\n\n  ContinuousSelection._({\n    required double step,\n    required super.extent,\n    required super.rawExtent,\n    required super.rawOffset,\n  }) : _step = step,\n       super._copy(offset: (min: rawOffset.min / rawExtent.total, max: rawOffset.max / rawExtent.total));\n\n  @override\n  ContinuousSelection step({required bool min, required bool extend}) {\n    final edge = min ? rawOffset.min : rawOffset.max;\n    final step = rawExtent.total * _step;\n\n    return move(min: min, to: edge + ((min ^ extend) ? step : -step));\n  }\n\n  @override\n  ContinuousSelection move({required bool min, required double to}) {\n    if (to < 0) {\n      to = 0;\n    } else if (rawExtent.total < to) {\n      to = rawExtent.total;\n    }\n\n    final (minOffset, maxOffset) = switch (min) {\n      true when rawOffset.max - to < rawExtent.min => (rawOffset.max - rawExtent.min, rawOffset.max),\n      true when rawOffset.max - to > rawExtent.max => (rawOffset.max - rawExtent.max, rawOffset.max),\n      true => (to, rawOffset.max),\n      false when to - rawOffset.min < rawExtent.min => (rawOffset.min, rawOffset.min + rawExtent.min),\n      false when to - rawOffset.min > rawExtent.max => (rawOffset.min, rawOffset.min + rawExtent.max),\n      false => (rawOffset.min, to),\n    };\n\n    return ContinuousSelection._(\n      step: _step,\n      extent: extent,\n      rawExtent: (min: rawExtent.min, max: rawExtent.max, total: rawExtent.total),\n      rawOffset: (min: minOffset, max: maxOffset),\n    );\n  }\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is ContinuousSelection &&\n          runtimeType == other.runtimeType &&\n          extent == other.extent &&\n          offset == other.offset &&\n          rawExtent == other.rawExtent &&\n          rawOffset == other.rawOffset &&\n          _step == other._step;\n\n  @override\n  int get hashCode => extent.hashCode ^ offset.hashCode ^ rawExtent.hashCode ^ rawOffset.hashCode ^ _step.hashCode;\n}\n\n@internal\nfinal class DiscreteSelection extends FSliderSelection {\n  final SplayTreeMap<double, void> ticks;\n\n  DiscreteSelection({\n    required this.ticks,\n    required ({double min, double max}) offset,\n    required super.mainAxisExtent,\n    required super.extent,\n  }) : assert(ticks.isNotEmpty, 'ticks must not be empty.'),\n       assert(ticks.keys.every((tick) => 0 <= tick && tick <= 1), 'Every tick must be >= 0 and <= 1.'),\n       super._(offset: (min: ticks.round(offset.min), max: ticks.round(offset.max)));\n\n  DiscreteSelection._({required this.ticks, required super.offset, required super.extent, required super.rawExtent})\n    : super._copy(rawOffset: (min: offset.min * rawExtent.total, max: offset.max * rawExtent.total));\n\n  @override\n  DiscreteSelection step({required bool min, required bool extend}) => _move(\n    min: min,\n    to: switch ((min, extend)) {\n      (true, true) => ticks.lastKeyBefore(offset.min) ?? offset.min,\n      (true, false) => ticks.firstKeyAfter(offset.min) ?? offset.min,\n      (false, true) => ticks.firstKeyAfter(offset.max) ?? offset.max,\n      (false, false) => ticks.lastKeyBefore(offset.max) ?? offset.max,\n    },\n  );\n\n  @override\n  DiscreteSelection move({required bool min, required double to}) => _move(min: min, to: to / rawExtent.total);\n\n  DiscreteSelection _move({required bool min, required double to}) {\n    if ((min ? offset.min : offset.max) == to) {\n      return this;\n    }\n\n    // Round to the nearest tick that satisfy the extent constraints.\n    to = ticks.round(to);\n    final (minOffset, maxOffset) = switch (min) {\n      true when offset.max - to < extent.min => (\n        ticks\n            .lastKeysBefore(to)\n            .takeWhile((tick) => offset.min < tick)\n            .firstWhere((tick) => extent.min <= offset.max - tick, orElse: () => offset.min),\n        offset.max,\n      ),\n      true when extent.max < offset.max - to => (\n        ticks\n            .firstKeysAfter(to)\n            .takeWhile((tick) => tick < offset.min)\n            .firstWhere((tick) => offset.max - tick <= extent.max, orElse: () => offset.min),\n        offset.max,\n      ),\n      true => (to, offset.max),\n      false when to - offset.min < extent.min => (\n        offset.min,\n        ticks\n            .firstKeysAfter(to)\n            .takeWhile((tick) => tick < offset.max)\n            .firstWhere((tick) => extent.min <= tick - offset.min, orElse: () => offset.max),\n      ),\n      false when extent.max < to - offset.min => (\n        offset.min,\n        ticks\n            .lastKeysBefore(to)\n            .takeWhile((tick) => offset.max < tick)\n            .firstWhere((tick) => tick - offset.min <= extent.max, orElse: () => offset.max),\n      ),\n      false => (offset.min, to),\n    };\n\n    return DiscreteSelection._(\n      ticks: ticks,\n      offset: (min: minOffset, max: maxOffset),\n      extent: extent,\n      rawExtent: rawExtent,\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('ticks', ticks));\n  }\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is DiscreteSelection &&\n          runtimeType == other.runtimeType &&\n          extent == other.extent &&\n          offset == other.offset &&\n          rawExtent == other.rawExtent &&\n          rawOffset == other.rawOffset &&\n          mapEquals(ticks, other.ticks);\n\n  @override\n  int get hashCode => extent.hashCode ^ offset.hashCode ^ rawExtent.hashCode ^ rawOffset.hashCode ^ ticks.hashCode;\n}\n\n@internal\nextension SplayTreeMaps on SplayTreeMap<double, void> {\n  Iterable<double> firstKeysAfter(double value) sync* {\n    var current = value;\n    while (true) {\n      final after = firstKeyAfter(current);\n      if (after == null) {\n        return;\n      }\n\n      yield current = after;\n    }\n  }\n\n  Iterable<double> lastKeysBefore(double value) sync* {\n    var current = value;\n    while (true) {\n      final before = lastKeyBefore(current);\n      if (before == null) {\n        return;\n      }\n\n      yield current = before;\n    }\n  }\n\n  double round(double value) {\n    if (containsKey(value)) {\n      return value;\n    }\n\n    switch ((lastKeyBefore(value), firstKeyAfter(value))) {\n      case (final before?, null):\n        return before;\n\n      case (null, final after?):\n        return after;\n\n      case (final before?, final after?):\n        final diffBefore = (value - before).abs();\n        final diffAfter = (value - after).abs();\n\n        return diffBefore <= diffAfter ? before : after;\n\n      default:\n        throw ArgumentError('before and after must not be null.');\n    }\n  }\n}\n",
      "slider_styles": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'slider_styles.design.dart';\n\n/// A slider's styles.\nclass FSliderStyles with Diagnosticable, _$FSliderStylesFunctions {\n  /// The enabled slider's horizontal style.\n  @override\n  final FSliderStyle horizontalStyle;\n\n  /// The enabled slider's vertical style.\n  @override\n  final FSliderStyle verticalStyle;\n\n  /// Creates a [FSliderStyles].\n  FSliderStyles({required this.horizontalStyle, required this.verticalStyle});\n\n  /// Creates a [FSliderStyles] that inherits its properties.\n  FSliderStyles.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        horizontalStyle: FSliderStyle.inherit(\n          colors: colors,\n          typography: typography,\n          style: style,\n          labelAnchor: Alignment.topCenter,\n          labelOffset: 10,\n          descriptionPadding: const EdgeInsets.only(top: 10),\n          childPadding: const EdgeInsets.only(top: 10, bottom: 20, left: 10, right: 10),\n        ),\n        verticalStyle: FSliderStyle.inherit(\n          colors: colors,\n          typography: typography,\n          style: style,\n          labelAnchor: Alignment.centerRight,\n          labelOffset: -10,\n          tooltipTipAnchor: FTouch.primary ? Alignment.bottomCenter : Alignment.centerLeft,\n          tooltipThumbAnchor: FTouch.primary ? Alignment.topCenter : Alignment.centerRight,\n          descriptionPadding: const EdgeInsets.only(top: 5),\n          childPadding: const EdgeInsets.all(10),\n        ),\n      );\n}\n\n/// A slider's style.\nclass FSliderStyle extends FLabelStyle with _$FSliderStyleFunctions {\n  /// The slider's active track colors.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.form}\n  @override\n  final FWidgetStateMap<Color> activeColor;\n\n  /// The slider's inactive track colors.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.form}\n  @override\n  final FWidgetStateMap<Color> inactiveColor;\n\n  /// The slider's border radius.\n  @override\n  final BorderRadius borderRadius;\n\n  /// The slider's cross-axis extent. Defaults to 8.\n  ///\n  /// ## Contract:\n  /// Throws [AssertionError] if it is not positive.\n  @override\n  final double crossAxisExtent;\n\n  /// The thumb's size. Defaults to `25` on touch platforms and `20` on non-touch platforms.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [thumbSize] is not positive.\n  ///\n  /// ## Implementation details\n  /// This unfortunately has to be placed outside of FSliderThumbStyle because [FSliderThumbStyle] is inside\n  /// [FSliderStyle]. Putting the thumb size inside [FSliderThumbStyle] will cause a cyclic rebuild to occur\n  /// whenever the window is resized due to a bad interaction between an internal LayoutBuilder and SliderFormField.\n  @override\n  final double thumbSize;\n\n  /// The slider thumb's style.\n  @override\n  final FSliderThumbStyle thumbStyle;\n\n  /// The slider marks' style.\n  @override\n  final FSliderMarkStyle markStyle;\n\n  /// The tooltip's style.\n  @override\n  final FTooltipStyle tooltipStyle;\n\n  /// The tooltip's motion-related properties.\n  @override\n  final FTooltipMotion tooltipMotion;\n\n  /// The anchor of the tooltip to which the [tooltipThumbAnchor] is aligned.\n  ///\n  /// Defaults to [Alignment.bottomCenter] on primarily touch devices and [Alignment.centerLeft] on non-primarily touch\n  /// devices.\n  @override\n  final AlignmentGeometry tooltipTipAnchor;\n\n  /// The anchor of the thumb to which the [tooltipTipAnchor] is aligned.\n  ///\n  /// Defaults to [Alignment.topCenter] on primarily touch devices and [Alignment.centerRight] on non-primarily touch\n  /// devices.\n  @override\n  final AlignmentGeometry tooltipThumbAnchor;\n\n  /// Creates a [FSliderStyle].\n  FSliderStyle({\n    required this.activeColor,\n    required this.inactiveColor,\n    required this.thumbStyle,\n    required this.markStyle,\n    required this.tooltipStyle,\n    required super.labelTextStyle,\n    required super.descriptionTextStyle,\n    required super.errorTextStyle,\n    this.borderRadius = const BorderRadius.all(Radius.circular(4)),\n    this.crossAxisExtent = 8,\n    double? thumbSize,\n    this.tooltipMotion = const FTooltipMotion(),\n    this.tooltipTipAnchor = Alignment.bottomCenter,\n    this.tooltipThumbAnchor = Alignment.topCenter,\n    super.labelPadding = const EdgeInsets.only(bottom: 5),\n    super.descriptionPadding,\n    super.errorPadding = const EdgeInsets.only(top: 5),\n    super.childPadding,\n  }) : assert(thumbSize == null || 0 < thumbSize, 'thumbSize ($thumbSize) must be > 0'),\n       thumbSize = thumbSize ?? (FTouch.primary ? 25 : 20);\n\n  /// Creates a [FSliderStyle] that inherits its properties.\n  FSliderStyle.inherit({\n    required FColors colors,\n    required FTypography typography,\n    required FStyle style,\n    required AlignmentGeometry labelAnchor,\n    required double labelOffset,\n    required EdgeInsetsGeometry descriptionPadding,\n    required EdgeInsetsGeometry childPadding,\n    AlignmentGeometry tooltipTipAnchor = Alignment.bottomCenter,\n    AlignmentGeometry tooltipThumbAnchor = Alignment.topCenter,\n  }) : this(\n         activeColor: FWidgetStateMap({\n           WidgetState.error: colors.error,\n           WidgetState.disabled: colors.disable(colors.primary, colors.secondary),\n           WidgetState.any: colors.primary,\n         }),\n         inactiveColor: FWidgetStateMap.all(colors.secondary),\n         thumbStyle: FSliderThumbStyle(\n           color: FWidgetStateMap({\n             WidgetState.error: colors.errorForeground,\n             WidgetState.any: colors.primaryForeground,\n           }),\n           borderColor: FWidgetStateMap({\n             WidgetState.error: colors.error,\n             WidgetState.disabled: colors.disable(colors.primary),\n             WidgetState.any: colors.primary,\n           }),\n           focusedOutlineStyle: style.focusedOutlineStyle,\n         ),\n         markStyle: FSliderMarkStyle(\n           tickColor: FWidgetStateMap.all(colors.mutedForeground),\n           labelTextStyle: FWidgetStateMap({\n             WidgetState.error: typography.xs.copyWith(color: colors.error),\n             WidgetState.any: typography.xs.copyWith(color: colors.mutedForeground),\n           }),\n           labelAnchor: labelAnchor,\n           labelOffset: labelOffset,\n         ),\n         tooltipStyle: FTooltipStyle.inherit(colors: colors, typography: typography, style: style),\n         tooltipTipAnchor: tooltipTipAnchor,\n         tooltipThumbAnchor: tooltipThumbAnchor,\n         labelTextStyle: style.formFieldStyle.labelTextStyle,\n         descriptionTextStyle: style.formFieldStyle.descriptionTextStyle,\n         errorTextStyle: style.formFieldStyle.errorTextStyle,\n         descriptionPadding: descriptionPadding,\n         childPadding: childPadding,\n       );\n}\n",
      "slider_tooltips_controller": "import 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\n\n/// The controller for a slider's registered tooltips.\nfinal class FSliderTooltipsController {\n  /// The key for the min thumb.\n  static final min = UniqueKey();\n\n  /// The key for the max thumb.\n  static final max = UniqueKey();\n\n  /// True if the registered tooltip(s) should be shown when the user interacts with the slider. Defaults to true.\n  final bool enabled;\n\n  final Map<UniqueKey, FTooltipController> _tooltips;\n\n  /// Creates a [FSliderTooltipsController].\n  FSliderTooltipsController({required this.enabled}) : _tooltips = {};\n\n  /// Registers the tooltip to the slider.\n  void add(UniqueKey key, FTooltipController controller) {\n    if (enabled) {\n      _tooltips[key] = controller;\n    }\n  }\n\n  /// Toggles the visibility of the tooltip with the given key, or all tooltips if none is specified.\n  Future<void> toggle([UniqueKey? key]) async {\n    if (key != null) {\n      await _tooltips[key]?.toggle();\n      return;\n    }\n\n    await Future.wait([for (final tooltip in _tooltips.values) tooltip.toggle()]);\n  }\n\n  /// Shows the tooltip with the given key, or all tooltips if none is specified.\n  Future<void> show([UniqueKey? key]) async {\n    if (key != null) {\n      await _tooltips[key]?.show();\n      return;\n    }\n\n    await Future.wait([for (final tooltip in _tooltips.values) tooltip.show()]);\n  }\n\n  /// Hides the tooltip with the given key, or all tooltips if none is specified.\n  Future<void> hide([UniqueKey? key]) async {\n    if (key != null) {\n      await _tooltips[key]?.hide();\n      return;\n    }\n\n    await Future.wait([for (final tooltip in _tooltips.values) tooltip.hide()]);\n  }\n\n  /// Removes the tooltip from the slider.\n  void remove(UniqueKey? key, [FTooltipController? controller]) {\n    if (!enabled) {\n      return;\n    }\n\n    if (controller == null) {\n      _tooltips.remove(key);\n    } else {\n      _tooltips.removeWhere((key, controller) => key == key && controller == controller);\n    }\n  }\n}\n",
      "thumb": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/slider/inherited_controller.dart';\nimport 'package:forui/src/widgets/slider/inherited_data.dart';\nimport 'package:forui/src/widgets/slider/inherited_state.dart';\n\npart 'thumb.design.dart';\n\nclass _ShrinkIntent extends Intent {\n  const _ShrinkIntent();\n}\n\nclass _ExtendIntent extends Intent {\n  const _ExtendIntent();\n}\n\n@internal\nclass Thumb extends StatefulWidget {\n  final bool min;\n\n  const Thumb({required this.min, super.key});\n\n  @override\n  State<Thumb> createState() => _ThumbState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(FlagProperty('min', value: min, ifTrue: 'min', ifFalse: 'max'));\n  }\n}\n\nclass _ThumbState extends State<Thumb> with TickerProviderStateMixin {\n  late FSliderController _controller;\n  late UniqueKey _key;\n  FSliderStyle? _style;\n  FTooltipController? _tooltip;\n  MouseCursor _cursor = SystemMouseCursors.grab;\n  ({double min, double max})? _origin;\n  bool _gesture = false;\n  bool _focused = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _key = widget.min ? FSliderTooltipsController.min : FSliderTooltipsController.max;\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final style = InheritedData.of(context).style;\n    if (_style != style) {\n      _tooltip?.dispose();\n      _tooltip = FTooltipController(vsync: this, motion: style.tooltipMotion);\n      _style = style;\n    }\n\n    _controller = InheritedController.of(context);\n    _controller.tooltips.add(_key, _tooltip!);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final states = InheritedStates.of(context).states;\n    final InheritedData(\n      style: FSliderStyle(:thumbSize, :thumbStyle, :tooltipTipAnchor, :tooltipThumbAnchor),\n      :layout,\n      :tooltipBuilder,\n      :semanticValueFormatterCallback,\n      :enabled,\n    ) = InheritedData.of(\n      context,\n    );\n\n    String? increasedValue;\n    if (_controller.selection.step(min: widget.min, extend: !widget.min) case final selection\n        when _controller.selection != selection) {\n      increasedValue = semanticValueFormatterCallback(_offset(selection));\n    }\n\n    String? decreasedValue;\n    if (_controller.selection.step(min: widget.min, extend: widget.min) case final selection\n        when _controller.selection != selection) {\n      decreasedValue = semanticValueFormatterCallback(_offset(selection));\n    }\n\n    Widget thumb = Semantics(\n      enabled: enabled,\n      value: semanticValueFormatterCallback(_offset(_controller.selection)),\n      increasedValue: increasedValue,\n      decreasedValue: decreasedValue,\n      child: FocusableActionDetector(\n        shortcuts: _shortcuts(layout),\n        actions: {\n          _ExtendIntent: CallbackAction(onInvoke: (_) => _controller.step(min: widget.min, extend: true)),\n          _ShrinkIntent: CallbackAction(onInvoke: (_) => _controller.step(min: widget.min, extend: false)),\n        },\n        enabled: enabled,\n        mouseCursor: enabled ? _cursor : MouseCursor.defer,\n        includeFocusSemantics: false,\n        onFocusChange: (focused) => setState(() => _focused = focused),\n        child: FFocusedOutline(\n          style: thumbStyle.focusedOutlineStyle,\n          focused: _focused,\n          child: DecoratedBox(\n            decoration: BoxDecoration(\n              shape: BoxShape.circle,\n              color: thumbStyle.color.resolve(states),\n              border: Border.all(color: thumbStyle.borderColor.resolve(states), width: thumbStyle.borderWidth),\n            ),\n            child: SizedBox.square(dimension: thumbSize),\n          ),\n        ),\n      ),\n    );\n\n    if (!enabled) {\n      return thumb;\n    }\n\n    if (_controller.tooltips.enabled) {\n      thumb = MouseRegion(\n        onEnter: (_) => _controller.tooltips.show(_key),\n        onExit: (_) {\n          if (!_gesture) {\n            _controller.tooltips.hide(_key);\n          }\n        },\n        child: FTooltip(\n          controller: _tooltip,\n          tipAnchor: tooltipTipAnchor,\n          childAnchor: tooltipThumbAnchor,\n          tipBuilder: (_, controller) => tooltipBuilder(controller, _offset(_controller.selection)),\n          longPress: false,\n          hover: false,\n          child: thumb,\n        ),\n      );\n    }\n\n    void down(TapDownDetails _) {\n      setState(() => _cursor = SystemMouseCursors.grabbing);\n      _gesture = true;\n      _controller.tooltips.show(_key);\n    }\n\n    void up(TapUpDetails _) {\n      setState(() => _cursor = SystemMouseCursors.grab);\n      _gesture = false;\n      _controller.tooltips.hide(_key);\n    }\n\n    void start(DragStartDetails _) {\n      setState(() => _cursor = SystemMouseCursors.grabbing);\n      _origin = null;\n      _origin = _controller.selection.rawOffset;\n      _gesture = true;\n      _controller.tooltips.show(_key);\n    }\n\n    void end(DragEndDetails _) {\n      setState(() => _cursor = SystemMouseCursors.grab);\n      _origin = null;\n      _gesture = false;\n      _controller.tooltips.hide(_key);\n    }\n\n    if (layout.vertical) {\n      return GestureDetector(\n        onTapDown: down,\n        onTapUp: up,\n        onVerticalDragStart: start,\n        onVerticalDragUpdate: _drag(_controller, thumbSize, layout),\n        onVerticalDragEnd: end,\n        child: thumb,\n      );\n    } else {\n      return GestureDetector(\n        onTapDown: down,\n        onTapUp: up,\n        onHorizontalDragStart: start,\n        onHorizontalDragUpdate: _drag(_controller, thumbSize, layout),\n        onHorizontalDragEnd: end,\n        child: thumb,\n      );\n    }\n  }\n\n  double _offset(FSliderSelection selection) => widget.min ? selection.offset.min : selection.offset.max;\n\n  Map<ShortcutActivator, Intent> _shortcuts(FLayout layout) => switch ((layout, widget.min)) {\n    (FLayout.ltr, true) || (FLayout.rtl, false) => const {\n      SingleActivator(LogicalKeyboardKey.arrowLeft): _ExtendIntent(),\n      SingleActivator(LogicalKeyboardKey.arrowRight): _ShrinkIntent(),\n    },\n    (FLayout.ltr, false) || (FLayout.rtl, true) => const {\n      SingleActivator(LogicalKeyboardKey.arrowLeft): _ShrinkIntent(),\n      SingleActivator(LogicalKeyboardKey.arrowRight): _ExtendIntent(),\n    },\n    (FLayout.ttb, true) || (FLayout.btt, false) => const {\n      SingleActivator(LogicalKeyboardKey.arrowUp): _ExtendIntent(),\n      SingleActivator(LogicalKeyboardKey.arrowDown): _ShrinkIntent(),\n    },\n    (FLayout.ttb, false) || (FLayout.btt, true) => const {\n      SingleActivator(LogicalKeyboardKey.arrowUp): _ShrinkIntent(),\n      SingleActivator(LogicalKeyboardKey.arrowDown): _ExtendIntent(),\n    },\n  };\n\n  GestureDragUpdateCallback? _drag(FSliderController controller, double thumbSize, FLayout layout) {\n    if (controller.allowedInteraction == FSliderInteraction.tap) {\n      return null;\n    }\n\n    final translate = layout.translateThumbDrag(thumbSize);\n\n    void drag(DragUpdateDetails details) {\n      final origin = widget.min ? _origin!.min : _origin!.max;\n      controller.slide(origin + translate(details.localPosition), min: widget.min);\n    }\n\n    return drag;\n  }\n\n  @override\n  void dispose() {\n    _controller.tooltips.remove(_key);\n    _tooltip?.dispose();\n    super.dispose();\n  }\n}\n\n/// A slider thumb's style.\n///\n/// **Note**:\n/// The thumb size can be configured inside [FSliderStyle] instead. This is due to an unfortunate limitation of the\n/// implementation.\nclass FSliderThumbStyle with Diagnosticable, _$FSliderThumbStyleFunctions {\n  /// The thumb's color.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.form}\n  @override\n  final FWidgetStateMap<Color> color;\n\n  /// The border's color.\n  ///\n  /// {@macro forui.foundation.doc_templates.WidgetStates.form}\n  @override\n  final FWidgetStateMap<Color> borderColor;\n\n  /// The border's width. Defaults to `2`.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [borderWidth] is not positive.\n  @override\n  final double borderWidth;\n\n  /// The thumb's focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// Creates a [FSliderThumbStyle].\n  FSliderThumbStyle({\n    required this.color,\n    required this.borderColor,\n    required this.focusedOutlineStyle,\n    this.borderWidth = 2,\n  }) : assert(0 < borderWidth, 'borderWidth ($borderWidth) must be > 0');\n}\n\n@internal\nextension Layouts on FLayout {\n  double Function(Offset) translateThumbDrag(double thumbSize) => switch (this) {\n    FLayout.ltr => (delta) => delta.dx - thumbSize / 2,\n    FLayout.rtl => (delta) => -delta.dx + thumbSize / 2,\n    FLayout.ttb => (delta) => delta.dy - thumbSize / 2,\n    FLayout.btt => (delta) => -delta.dy + thumbSize / 2,\n  };\n}\n",
      "track": "import 'dart:math';\n\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/slider/inherited_controller.dart';\nimport 'package:forui/src/widgets/slider/inherited_data.dart';\nimport 'package:forui/src/widgets/slider/inherited_state.dart';\nimport 'package:forui/src/widgets/slider/thumb.dart';\n\n@internal\nclass Track extends StatelessWidget {\n  const Track({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedData(:style, :layout, :semanticFormatterCallback) = InheritedData.of(context);\n    final controller = InheritedController.of(context);\n    final position = layout.position;\n\n    final crossAxisExtent = max(style.thumbSize, style.crossAxisExtent);\n    final (height, width) = layout.vertical ? (null, crossAxisExtent) : (crossAxisExtent, null);\n\n    return SizedBox(\n      height: height,\n      width: width,\n      child: Semantics(\n        container: true,\n        slider: true,\n        enabled: true,\n        value: semanticFormatterCallback(controller.selection),\n        child: Stack(\n          alignment: Alignment.center,\n          children: [\n            const _GestureDetector(),\n            if (controller.extendable.min)\n              position(\n                offset: controller.selection.offset.min * controller.selection.rawExtent.total,\n                child: const Thumb(min: true),\n              ),\n            if (controller.extendable.max)\n              position(\n                offset: controller.selection.offset.max * controller.selection.rawExtent.total,\n                child: const Thumb(min: false),\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass _GestureDetector extends StatefulWidget {\n  const _GestureDetector();\n\n  @override\n  State<_GestureDetector> createState() => _GestureDetectorState();\n}\n\nclass _GestureDetectorState extends State<_GestureDetector> {\n  static const tappable = {FSliderInteraction.tap, FSliderInteraction.tapAndSlideThumb};\n\n  ({double min, double max})? _origin;\n  Offset? _pointerOrigin;\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedData(:style, :layout, :trackHitRegionCrossExtent, :enabled) = InheritedData.of(context);\n    final controller = InheritedController.of(context);\n\n    Widget track = const Center(child: _Track());\n\n    if (!enabled) {\n      return track;\n    }\n\n    if (FTouch.primary || trackHitRegionCrossExtent != null) {\n      final crossAxisExtent = trackHitRegionCrossExtent ?? max(style.thumbSize, style.crossAxisExtent);\n      final (height, width) = layout.vertical ? (null, crossAxisExtent) : (crossAxisExtent, null);\n\n      track = Container(height: height, width: width, color: const Color(0x00000000), child: track);\n    }\n\n    void start(DragStartDetails details) {\n      _origin = controller.selection.rawOffset;\n      _pointerOrigin = details.localPosition;\n      controller.tooltips.show();\n    }\n\n    void end(DragEndDetails _) {\n      _origin = null;\n      _pointerOrigin = null;\n      controller.tooltips.hide();\n    }\n\n    if (layout.vertical) {\n      return GestureDetector(\n        onTapDown: _tap(controller, style.thumbSize, layout),\n        onTapUp: (_) => controller.tooltips.hide(),\n        onVerticalDragStart: start,\n        onVerticalDragUpdate: _drag(controller, layout),\n        onVerticalDragEnd: end,\n        child: track,\n      );\n    } else {\n      return GestureDetector(\n        onTapDown: _tap(controller, style.thumbSize, layout),\n        onTapUp: (_) => controller.tooltips.hide(),\n        onHorizontalDragStart: start,\n        onHorizontalDragUpdate: _drag(controller, layout),\n        onHorizontalDragEnd: end,\n        child: track,\n      );\n    }\n  }\n\n  GestureTapDownCallback? _tap(FSliderController controller, double thumbSize, FLayout layout) {\n    final translate = layout.translateTrackTap(controller.selection.rawExtent.total, thumbSize);\n\n    void down(TapDownDetails details) {\n      final offset = switch (translate(details.localPosition)) {\n        < 0 => 0.0,\n        final translated when controller.selection.rawExtent.total < translated => controller.selection.rawExtent.total,\n        final translated => translated,\n      };\n\n      switch (controller.tap(offset)) {\n        case true:\n          controller.tooltips.show(FSliderTooltipsController.min);\n        case false:\n          controller.tooltips.show(FSliderTooltipsController.max);\n        default:\n      }\n    }\n\n    return tappable.contains(controller.allowedInteraction) ? down : null;\n  }\n\n  GestureDragUpdateCallback? _drag(FSliderController controller, FLayout layout) {\n    if (controller.allowedInteraction != FSliderInteraction.slide) {\n      return null;\n    }\n\n    assert(\n      controller.extendable.min ^ controller.extendable.max,\n      'Slider must be extendable at one edge when ${controller.allowedInteraction}.',\n    );\n\n    final translate = layout.translateTrackDrag();\n\n    return (details) {\n      final origin = controller.extendable.min ? _origin!.min : _origin!.max;\n      controller.slide(origin + translate(details.localPosition - _pointerOrigin!), min: controller.extendable.min);\n    };\n  }\n}\n\nclass _Track extends StatelessWidget {\n  const _Track();\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedData(:style, :layout, :marks, :enabled) = InheritedData.of(context);\n    final states = InheritedStates.of(context).states;\n    final crossAxisExtent = style.crossAxisExtent;\n\n    final extent = InheritedController.of(context, InheritedController.rawExtent).selection.rawExtent.total;\n\n    final position = layout.position;\n    final half = style.thumbSize / 2;\n    final (height, width) = layout.vertical ? (null, crossAxisExtent) : (crossAxisExtent, null);\n\n    return DecoratedBox(\n      decoration: BoxDecoration(borderRadius: style.borderRadius, color: style.inactiveColor.resolve(states)),\n      child: SizedBox(\n        height: height,\n        width: width,\n        child: Stack(\n          alignment: Alignment.center,\n          children: [\n            for (var FSliderMark(style: markStyle, :value, :tick) in marks)\n              if (tick)\n                position(\n                  offset: value * extent + half - ((markStyle ??= style.markStyle).tickSize / 2),\n                  child: DecoratedBox(\n                    decoration: BoxDecoration(shape: BoxShape.circle, color: markStyle.tickColor.resolve(states)),\n                    child: SizedBox.square(dimension: markStyle.tickSize),\n                  ),\n                ),\n            const ActiveTrack(),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n@internal\nclass ActiveTrack extends StatelessWidget {\n  const ActiveTrack({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final InheritedData(:style, :layout) = InheritedData.of(context);\n    final states = InheritedStates.of(context).states;\n    final crossAxisExtent = style.crossAxisExtent;\n    final rawOffset = InheritedController.of(context, InheritedController.rawOffset).selection.rawOffset;\n\n    final mainAxisExtent = rawOffset.max - rawOffset.min + style.thumbSize / 2;\n    final (height, width) = layout.vertical ? (mainAxisExtent, crossAxisExtent) : (crossAxisExtent, mainAxisExtent);\n\n    return layout.position(\n      offset: rawOffset.min,\n      child: DecoratedBox(\n        decoration: BoxDecoration(borderRadius: style.borderRadius, color: style.activeColor.resolve(states)),\n        child: SizedBox(height: height, width: width),\n      ),\n    );\n  }\n}\n\n@internal\nextension Layouts on FLayout {\n  double Function(Offset) translateTrackTap(double extent, double thumbSize) => switch (this) {\n    FLayout.ltr => (offset) => offset.dx - thumbSize / 2,\n    FLayout.rtl => (offset) => extent - offset.dx + thumbSize / 2,\n    FLayout.ttb => (offset) => offset.dy - thumbSize / 2,\n    FLayout.btt => (offset) => extent - offset.dy + thumbSize / 2,\n  };\n\n  double Function(Offset) translateTrackDrag() => switch (this) {\n    FLayout.ltr => (delta) => delta.dx,\n    FLayout.rtl => (delta) => -delta.dx,\n    FLayout.ttb => (delta) => delta.dy,\n    FLayout.btt => (delta) => -delta.dy,\n  };\n\n  Positioned Function({required double offset, required Widget child}) get position => switch (this) {\n    FLayout.ltr => ({required offset, required child}) => Positioned(left: offset, child: child),\n    FLayout.rtl => ({required offset, required child}) => Positioned(right: offset, child: child),\n    FLayout.ttb => ({required offset, required child}) => Positioned(top: offset, child: child),\n    FLayout.btt => ({required offset, required child}) => Positioned(bottom: offset, child: child),\n  };\n}\n"
    },
    "Tabs": {
      "tabs": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:flutter_localizations/flutter_localizations.dart';\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'tab_controller.dart';\npart 'tabs.design.dart';\npart 'tabs_style.dart';\n\n/// An object that represents a tab entry in a group of tabs.\nclass FTabEntry {\n  /// A label.\n  final Widget label;\n\n  /// The content of a tab.\n  final Widget child;\n\n  /// Creates a [FTabs].\n  const FTabEntry({required this.label, required this.child});\n\n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is FTabEntry && runtimeType == other.runtimeType && label == other.label && child == other.child;\n\n  @override\n  int get hashCode => label.hashCode ^ child.hashCode;\n}\n\n/// Allows switching between widgets through tabs.\n///\n/// See:\n/// * https://forui.dev/docs/navigation/tabs for working examples.\n/// * [FTabsStyle] for customizing tabs' appearance.\nclass FTabs extends StatefulWidget {\n  /// The tab controller.\n  final FTabController? controller;\n\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create tabs\n  /// ```\n  final FTabsStyle Function(FTabsStyle style)? style;\n\n  /// The initial tab that is selected.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * [initialIndex] is not within the range '0 <= initialIndex < tabs.length`.\n  final int initialIndex;\n\n  /// Whether this tab bar can be scrolled horizontally. Defaults to false.\n  ///\n  /// If [scrollable] is true, then each tab is as wide as needed for its label and the entire [TabBar] is scrollable.\n  /// Otherwise each tab gets an equal share of the available space.\n  final bool scrollable;\n\n  /// How the tab should respond to user input.\n  ///\n  /// Defaults to matching platform conventions.\n  final ScrollPhysics? physics;\n\n  /// Handler for when a tab is changed. It is called **after** the tab switching animation has completed and the\n  /// controller has been updated.\n  final ValueChanged<int>? onChange;\n\n  /// A callback that is triggered when a tab is pressed. It is called **before** the tab switching animation begins\n  /// and the controller is updated.\n  final ValueChanged<int>? onPress;\n\n  /// The tabs.\n  final List<FTabEntry> children;\n\n  /// Creates a [FTabs].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * [children] is empty.\n  /// * [initialIndex] is not within the range '0 <= initialIndex < tabs.length`.\n  /// * [controller] index does not match the [initialIndex].\n  FTabs({\n    required this.children,\n    this.scrollable = false,\n    this.physics,\n    this.controller,\n    this.style,\n    this.onChange,\n    this.onPress,\n    this.initialIndex = 0,\n    super.key,\n  }) : assert(children.isNotEmpty, 'Must provide at least 1 tab.'),\n       assert(\n         0 <= initialIndex && initialIndex < children.length,\n         'initialIndex ($initialIndex) must be between 0 and the number of children (${children.length})',\n       ),\n       assert(\n         controller == null || initialIndex == 0,\n         'Cannot provide both controller and initialIndex. To fix, set the initialIndex on the controller.',\n       ),\n       assert(\n         controller == null || controller.length == children.length,\n         \"Controller's number of tabs (${controller.length} must match the number of children (${children.length}).\",\n       );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(ObjectFlagProperty.has('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(IntProperty('initialIndex', initialIndex))\n      ..add(FlagProperty('scrollable', value: scrollable, ifTrue: 'scrollable'))\n      ..add(DiagnosticsProperty('physics', physics))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(IterableProperty('children', children));\n  }\n\n  @override\n  State<FTabs> createState() => _FTabsState();\n}\n\nclass _FTabsState extends State<FTabs> with SingleTickerProviderStateMixin {\n  late FTabController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller =\n        widget.controller ??\n        FTabController(initialIndex: widget.initialIndex, length: widget.children.length, vsync: this);\n    _controller.addListener(_update);\n  }\n\n  @override\n  void didUpdateWidget(covariant FTabs old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        _controller.removeListener(_update);\n      }\n\n      _controller =\n          widget.controller ??\n          FTabController(initialIndex: widget.initialIndex, length: widget.children.length, vsync: this);\n      _controller.addListener(_update);\n    }\n  }\n\n  void _update() {\n    if (!_controller._controller.indexIsChanging) {\n      widget.onChange?.call(_controller.index);\n    }\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final theme = context.theme;\n    final style = widget.style?.call(context.theme.tabsStyle) ?? context.theme.tabsStyle;\n    final localizations = Localizations.of<MaterialLocalizations>(context, MaterialLocalizations);\n\n    final tabs = Material(\n      color: Colors.transparent,\n      child: Column(\n        children: [\n          DecoratedBox(\n            decoration: style.decoration,\n            child: TabBar(\n              tabAlignment: widget.scrollable ? TabAlignment.start : TabAlignment.fill,\n              tabs: [for (final tab in widget.children) _Tab(style: style, label: tab.label)],\n              controller: _controller._controller,\n              isScrollable: widget.scrollable,\n              physics: widget.physics,\n              padding: style.padding,\n              indicator: style.indicatorDecoration,\n              indicatorSize: style.indicatorSize._value,\n              dividerColor: Colors.transparent,\n              labelStyle: style.selectedLabelTextStyle,\n              unselectedLabelStyle: style.unselectedLabelTextStyle,\n              onTap: widget.onPress,\n            ),\n          ),\n          SizedBox(height: style.spacing),\n          DefaultTextStyle(\n            style: theme.typography.base.copyWith(\n              fontFamily: theme.typography.defaultFontFamily,\n              color: theme.colors.foreground,\n            ),\n            child: widget.children[_controller.index].child,\n          ),\n        ],\n      ),\n    );\n\n    if (localizations == null) {\n      return Localizations(\n        locale: Localizations.maybeLocaleOf(context) ?? const Locale('en', 'US'),\n        delegates: const [\n          GlobalMaterialLocalizations.delegate,\n          GlobalWidgetsLocalizations.delegate,\n          GlobalCupertinoLocalizations.delegate,\n        ],\n        child: tabs,\n      );\n    }\n\n    return tabs;\n  }\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeListener(_update);\n    }\n    super.dispose();\n  }\n}\n\nclass _Tab extends StatefulWidget {\n  final FTabsStyle style;\n  final Widget label;\n\n  const _Tab({required this.style, required this.label});\n\n  @override\n  State<_Tab> createState() => _TabState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\nclass _TabState extends State<_Tab> {\n  FocusNode? _focus;\n  bool _focused = false;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final updated = Focus.of(context);\n    if (_focus != updated) {\n      _focus?.removeListener(_handleFocusChange);\n      _focus = updated..addListener(_handleFocusChange);\n    }\n  }\n\n  @override\n  Widget build(BuildContext _) => FFocusedOutline(\n    style: widget.style.focusedOutlineStyle,\n    focused: _focused,\n    child: Tab(height: widget.style.height, child: widget.label),\n  );\n\n  void _handleFocusChange() => setState(() => _focused = _focus?.hasFocus ?? false);\n\n  @override\n  void dispose() {\n    _focus?.removeListener(_handleFocusChange);\n    super.dispose();\n  }\n}\n",
      "tabs_style": "part of 'tabs.dart';\n\n/// Defines how the bounds of the selected tab indicator are computed.\nenum FTabBarIndicatorSize {\n  /// The tab indicator's bounds are as wide as the space occupied by the tab\n  /// in the tab bar: from the right edge of the previous tab to the left edge\n  /// of the next tab.\n  tab(TabBarIndicatorSize.tab),\n\n  /// The tab's bounds are only as wide as the (centered) tab widget itself.\n  ///\n  /// This value is used to align the tab's label, typically a [Tab]\n  /// widget's text or icon, with the selected tab indicator.\n  label(TabBarIndicatorSize.label);\n\n  final TabBarIndicatorSize _value;\n\n  const FTabBarIndicatorSize(this._value);\n}\n\n/// [FTabs]'s style.\nclass FTabsStyle with Diagnosticable, _$FTabsStyleFunctions {\n  /// The decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// The padding.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The [TextStyle] of the label.\n  @override\n  final TextStyle selectedLabelTextStyle;\n\n  /// The [TextStyle] of the label.\n  @override\n  final TextStyle unselectedLabelTextStyle;\n\n  /// The indicator.\n  @override\n  final BoxDecoration indicatorDecoration;\n\n  /// The indicator size.\n  @override\n  final FTabBarIndicatorSize indicatorSize;\n\n  /// The height.\n  @override\n  final double height;\n\n  /// The spacing between the tab bar and the views.\n  @override\n  final double spacing;\n\n  /// The focused outline style.\n  @override\n  final FFocusedOutlineStyle focusedOutlineStyle;\n\n  /// Creates a [FTabsStyle].\n  FTabsStyle({\n    required this.decoration,\n    required this.selectedLabelTextStyle,\n    required this.unselectedLabelTextStyle,\n    required this.indicatorDecoration,\n    required this.focusedOutlineStyle,\n    this.padding = const EdgeInsets.all(4),\n    this.indicatorSize = FTabBarIndicatorSize.tab,\n    this.height = 35,\n    this.spacing = 10,\n  });\n\n  /// Creates a [FTabsStyle] that inherits its properties.\n  FTabsStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        decoration: BoxDecoration(\n          border: Border.all(color: colors.muted),\n          borderRadius: style.borderRadius,\n          color: colors.muted,\n        ),\n        selectedLabelTextStyle: typography.sm.copyWith(\n          fontWeight: FontWeight.w500,\n          fontFamily: typography.defaultFontFamily,\n          color: colors.foreground,\n        ),\n        unselectedLabelTextStyle: typography.sm.copyWith(\n          fontWeight: FontWeight.w500,\n          fontFamily: typography.defaultFontFamily,\n          color: colors.mutedForeground,\n        ),\n        indicatorDecoration: BoxDecoration(color: colors.background, borderRadius: style.borderRadius),\n        focusedOutlineStyle: style.focusedOutlineStyle,\n      );\n}\n",
      "tab_controller": "part of 'tabs.dart';\n\n/// A controller that controls selection in a [FTabs].\nfinal class FTabController extends FChangeNotifier {\n  final TabController _controller;\n  final Curve _curve;\n\n  /// Creates a [FTabController].\n  FTabController({\n    required int length,\n    required TickerProvider vsync,\n    int initialIndex = 0,\n    FTabMotion motion = const FTabMotion(),\n  }) : _controller = TabController(\n         initialIndex: initialIndex,\n         length: length,\n         animationDuration: motion.duration,\n         vsync: vsync,\n       ),\n       _curve = motion.curve;\n\n  /// Animates to the given [index].\n  ///\n  /// [curve] defaults to the [FTabMotion.curve] if not provided.\n  void animateTo(int index, {Duration? duration, Curve? curve}) =>\n      _controller.animateTo(index, duration: duration, curve: curve ?? _curve);\n\n  @override\n  void addListener(VoidCallback listener) => _controller.addListener(listener);\n\n  @override\n  void notifyListeners() => _controller.notifyListeners();\n\n  @override\n  void removeListener(VoidCallback listener) => _controller.removeListener(listener);\n\n  /// The index of the selected tab.\n  int get index => _controller.index;\n\n  set index(int value) => _controller.index = value;\n\n  /// The number of tabs.\n  int get length => _controller.length;\n\n  @override\n  bool get hasListeners => _controller.hasListeners;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}\n\n/// Motion-related properties for [FTabs].\nclass FTabMotion with Diagnosticable, _$FTabMotionFunctions {\n  /// The duration of the tab change animation. Defaults to 300 ms.\n  @override\n  final Duration duration;\n\n  /// The curve of the tab change animation. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve curve;\n\n  /// Creates a [FTabMotion].\n  const FTabMotion({this.duration = const Duration(milliseconds: 300), this.curve = Curves.easeOutCubic});\n}\n"
    },
    "TextField": {
      "field": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\n@internal\nclass Field extends FormField<String> {\n  final TextEditingController? controller;\n\n  Field({\n    required this.controller,\n    required super.initialValue,\n    required super.onSaved,\n    required super.onReset,\n    required super.validator,\n    required super.enabled,\n    required super.autovalidateMode,\n    required super.forceErrorText,\n    required super.restorationId,\n    required Widget Function(FieldState state) builder,\n    super.key,\n  }) : super(\n         builder: (state) => UnmanagedRestorationScope(bucket: state.bucket, child: builder(state as FieldState)),\n       );\n\n  @override\n  FormFieldState<String> createState() => FieldState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('controller', controller));\n  }\n}\n\n// This class is based on Material's _TextFormFieldState implementation.\n@internal\nclass FieldState extends FormFieldState<String> {\n  RestorableTextEditingController? _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    if (widget.controller case final controller?) {\n      controller.addListener(_handleTextEditingChange);\n    } else {\n      _registerController(RestorableTextEditingController(text: widget.initialValue));\n    }\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    super.restoreState(oldBucket, initialRestore);\n    if (_controller case final controller?) {\n      registerForRestoration(controller, 'controller');\n    }\n\n    // Make sure to update the internal [FormFieldState] value to sync up with text editing controller value.\n    setValue(effectiveController.text);\n  }\n\n  void _registerController(RestorableTextEditingController controller) {\n    assert(_controller == null, '_controller is already initialized.');\n    _controller = controller;\n    if (!restorePending) {\n      registerForRestoration(controller, 'controller');\n    }\n  }\n\n  @override\n  void didUpdateWidget(covariant Field old) {\n    super.didUpdateWidget(old);\n    if (widget.controller == old.controller) {\n      return;\n    }\n\n    widget.controller?.addListener(_handleTextEditingChange);\n    old.controller?.removeListener(_handleTextEditingChange);\n\n    switch ((widget.controller, old.controller)) {\n      case (final current?, _):\n        setValue(current.text);\n        if (_controller != null) {\n          unregisterFromRestoration(_controller!);\n          _controller?.dispose();\n          _controller = null;\n        }\n\n      case (null, final old?):\n        _registerController(RestorableTextEditingController.fromValue(old.value));\n    }\n  }\n\n  @override\n  void dispose() {\n    widget.controller?.removeListener(_handleTextEditingChange);\n    _controller?.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didChange(String? value) {\n    super.didChange(value);\n    if (effectiveController.text != value) {\n      effectiveController.text = value ?? '';\n    }\n  }\n\n  @override\n  void reset() {\n    // Set the controller value before calling super.reset() to let _handleControllerChanged suppress the change.\n    effectiveController.text = widget.initialValue ?? '';\n    super.reset();\n  }\n\n  // Suppress changes that originated from within this class.\n  //\n  // In the case where a controller has been passed in to this widget, we register this change listener. In these\n  // cases, we'll also receive change notifications for changes originating from within this class -- for example, the\n  // reset() method. In such cases, the FormField value will already have been set.\n  void _handleTextEditingChange() {\n    if (effectiveController.text != value) {\n      didChange(effectiveController.text);\n    }\n  }\n\n  @override\n  Field get widget => super.widget as Field;\n\n  /// The effective controller for this field.\n  TextEditingController get effectiveController => widget.controller ?? _controller!.value;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('effectiveController', effectiveController));\n  }\n}\n",
      "password_field": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nimport 'package:forui/forui.dart';\n\n/// A callback for building a field's icon.\n///\n/// [style] is the field's style.\n/// [obscure] controls the visibility of the password.\n/// [states] is the current states of the widget.\n///\n/// See [FTextField.prefixBuilder] and [FTextField.suffixBuilder].\ntypedef FPasswordFieldIconBuilder<T> =\n    Widget Function(BuildContext context, T style, ValueNotifier<bool> obscure, Set<WidgetState> states);\n\n@internal\nclass PasswordFieldProperties with Diagnosticable {\n  final FTextFieldStyle Function(FTextFieldStyle style)? style;\n  final FFieldBuilder<FTextFieldStyle> builder;\n  final Widget? label;\n  final String? hint;\n  final Widget? description;\n  final Widget? error;\n  final TextMagnifierConfiguration? magnifierConfiguration;\n  final Object groupId;\n  final TextEditingController? controller;\n  final FocusNode? focusNode;\n  final TextInputType? keyboardType;\n  final TextInputAction textInputAction;\n  final TextCapitalization textCapitalization;\n  final TextAlign textAlign;\n  final TextAlignVertical? textAlignVertical;\n  final TextDirection? textDirection;\n  final bool autofocus;\n  final WidgetStatesController? statesController;\n  final String obscuringCharacter;\n  final bool autocorrect;\n  final SmartDashesType? smartDashesType;\n  final SmartQuotesType? smartQuotesType;\n  final bool enableSuggestions;\n  final int? minLines;\n  final int maxLines;\n  final bool expands;\n  final bool readOnly;\n  final bool? showCursor;\n  final int? maxLength;\n  final MaxLengthEnforcement? maxLengthEnforcement;\n  final ValueChanged<String>? onChange;\n  final GestureTapCallback? onTap;\n  final TapRegionCallback? onTapOutside;\n  final bool onTapAlwaysCalled;\n  final VoidCallback? onEditingComplete;\n  final ValueChanged<String>? onSubmit;\n  final AppPrivateCommandCallback? onAppPrivateCommand;\n  final List<TextInputFormatter>? inputFormatters;\n  final bool enabled;\n  final bool? ignorePointers;\n  final bool enableInteractiveSelection;\n  final bool? selectAllOnFocus;\n  final TextSelectionControls? selectionControls;\n  final DragStartBehavior dragStartBehavior;\n  final MouseCursor? mouseCursor;\n  final FTextFieldCounterBuilder? counterBuilder;\n  final ScrollPhysics? scrollPhysics;\n  final ScrollController? scrollController;\n  final Iterable<String> autofillHints;\n  final String? restorationId;\n  final bool stylusHandwritingEnabled;\n  final bool enableIMEPersonalizedLearning;\n  final ContentInsertionConfiguration? contentInsertionConfiguration;\n  final EditableTextContextMenuBuilder? contextMenuBuilder;\n  final bool canRequestFocus;\n  final UndoHistoryController? undoController;\n  final SpellCheckConfiguration? spellCheckConfiguration;\n  final FPasswordFieldIconBuilder<FTextFieldStyle>? prefixBuilder;\n  final FPasswordFieldIconBuilder<FTextFieldStyle>? suffixBuilder;\n  final bool Function(TextEditingValue) clearable;\n  final String? initialText;\n  final ValueNotifier<bool>? obscureTextController;\n\n  PasswordFieldProperties({\n    required this.style,\n    required this.builder,\n    required this.label,\n    required this.hint,\n    required this.description,\n    required this.error,\n    required this.magnifierConfiguration,\n    required this.groupId,\n    required this.controller,\n    required this.focusNode,\n    required this.keyboardType,\n    required this.textInputAction,\n    required this.textCapitalization,\n    required this.textAlign,\n    required this.textAlignVertical,\n    required this.textDirection,\n    required this.autofocus,\n    required this.statesController,\n    required this.obscuringCharacter,\n    required this.autocorrect,\n    required this.smartDashesType,\n    required this.smartQuotesType,\n    required this.enableSuggestions,\n    required this.minLines,\n    required this.maxLines,\n    required this.expands,\n    required this.readOnly,\n    required this.showCursor,\n    required this.maxLength,\n    required this.maxLengthEnforcement,\n    required this.onChange,\n    required this.onTap,\n    required this.onTapOutside,\n    required this.onTapAlwaysCalled,\n    required this.onEditingComplete,\n    required this.onSubmit,\n    required this.onAppPrivateCommand,\n    required this.inputFormatters,\n    required this.enabled,\n    required this.ignorePointers,\n    required this.enableInteractiveSelection,\n    required this.selectAllOnFocus,\n    required this.selectionControls,\n    required this.dragStartBehavior,\n    required this.mouseCursor,\n    required this.counterBuilder,\n    required this.scrollPhysics,\n    required this.scrollController,\n    required this.autofillHints,\n    required this.restorationId,\n    required this.stylusHandwritingEnabled,\n    required this.enableIMEPersonalizedLearning,\n    required this.contentInsertionConfiguration,\n    required this.contextMenuBuilder,\n    required this.canRequestFocus,\n    required this.undoController,\n    required this.spellCheckConfiguration,\n    required this.prefixBuilder,\n    required this.suffixBuilder,\n    required this.clearable,\n    required this.initialText,\n    required this.obscureTextController,\n  });\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(StringProperty('hint', hint))\n      ..add(DiagnosticsProperty('magnifierConfiguration', magnifierConfiguration))\n      ..add(DiagnosticsProperty('groupId', groupId))\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(DiagnosticsProperty('keyboardType', keyboardType))\n      ..add(EnumProperty('textInputAction', textInputAction))\n      ..add(EnumProperty('textCapitalization', textCapitalization))\n      ..add(EnumProperty('textAlign', textAlign))\n      ..add(DiagnosticsProperty('textAlignVertical', textAlignVertical))\n      ..add(EnumProperty('textDirection', textDirection))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('statesController', statesController))\n      ..add(StringProperty('obscuringCharacter', obscuringCharacter, defaultValue: '\u2022'))\n      ..add(FlagProperty('autocorrect', value: autocorrect, ifTrue: 'autocorrect'))\n      ..add(EnumProperty('smartDashesType', smartDashesType))\n      ..add(EnumProperty('smartQuotesType', smartQuotesType))\n      ..add(FlagProperty('enableSuggestions', value: enableSuggestions, ifTrue: 'enableSuggestions'))\n      ..add(IntProperty('minLines', minLines))\n      ..add(IntProperty('maxLines', maxLines))\n      ..add(FlagProperty('expands', value: expands, ifTrue: 'expands'))\n      ..add(FlagProperty('readOnly', value: readOnly, ifTrue: 'readOnly'))\n      ..add(FlagProperty('showCursor', value: showCursor, ifTrue: 'showCursor'))\n      ..add(IntProperty('maxLength', maxLength))\n      ..add(EnumProperty('maxLengthEnforcement', maxLengthEnforcement))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onTap', onTap))\n      ..add(ObjectFlagProperty.has('onTapOutside', onTapOutside))\n      ..add(FlagProperty('onTapAlwaysCalled', value: onTapAlwaysCalled, ifTrue: 'onTapAlwaysCalled'))\n      ..add(ObjectFlagProperty.has('onEditingComplete', onEditingComplete))\n      ..add(ObjectFlagProperty.has('onSubmit', onSubmit))\n      ..add(ObjectFlagProperty.has('onAppPrivateCommand', onAppPrivateCommand))\n      ..add(IterableProperty('inputFormatters', inputFormatters))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(FlagProperty('ignorePointers', value: ignorePointers, ifTrue: 'ignorePointers'))\n      ..add(\n        FlagProperty('enableInteractSelection', value: enableInteractiveSelection, ifTrue: 'enableInteractSelection'),\n      )\n      ..add(FlagProperty('selectAllOnFocus', value: selectAllOnFocus, ifTrue: 'selectAllOnFocus'))\n      ..add(DiagnosticsProperty('selectionControls', selectionControls))\n      ..add(EnumProperty('dragStartBehavior', dragStartBehavior))\n      ..add(DiagnosticsProperty('mouseCursor', mouseCursor))\n      ..add(ObjectFlagProperty.has('buildCounter', counterBuilder))\n      ..add(DiagnosticsProperty('scrollPhysics', scrollPhysics))\n      ..add(DiagnosticsProperty('scrollController', scrollController))\n      ..add(IterableProperty('autofillHints', autofillHints))\n      ..add(StringProperty('restorationId', restorationId))\n      ..add(\n        FlagProperty('stylusHandwritingEnabled', value: stylusHandwritingEnabled, ifTrue: 'stylusHandwritingEnabled'),\n      )\n      ..add(\n        FlagProperty(\n          'enableIMEPersonalizedLearning',\n          value: enableIMEPersonalizedLearning,\n          ifTrue: 'enableIMEPersonalizedLearning',\n        ),\n      )\n      ..add(DiagnosticsProperty('contentInsertionConfiguration', contentInsertionConfiguration))\n      ..add(ObjectFlagProperty.has('contextMenuBuilder', contextMenuBuilder))\n      ..add(FlagProperty('canRequestFocus', value: canRequestFocus, ifTrue: 'canRequestFocus'))\n      ..add(DiagnosticsProperty('undoController', undoController))\n      ..add(DiagnosticsProperty('spellCheckConfiguration', spellCheckConfiguration))\n      ..add(ObjectFlagProperty.has('prefixBuilder', prefixBuilder))\n      ..add(ObjectFlagProperty.has('suffixBuilder', suffixBuilder))\n      ..add(ObjectFlagProperty.has('clearable', clearable))\n      ..add(StringProperty('initialText', initialText))\n      ..add(DiagnosticsProperty('obscureTextController', obscureTextController));\n  }\n}\n\n@internal\nclass PasswordField extends StatefulWidget {\n  static Widget defaultToggleBuilder(\n    BuildContext context,\n    FTextFieldStyle style,\n    ValueNotifier<bool> obscure,\n    Set<WidgetState> states,\n  ) {\n    final localizations = FLocalizations.of(context) ?? FDefaultLocalizations();\n    return Padding(\n      padding: style.obscureButtonPadding,\n      child: FButton.icon(\n        style: style.obscureButtonStyle,\n        onPress: () => obscure.value = !obscure.value,\n        child: Icon(\n          obscure.value ? FIcons.eye : FIcons.eyeClosed,\n          semanticLabel: obscure.value\n              ? localizations.passwordFieldUnobscureTextButtonSemanticsLabel\n              : localizations.passwordFieldObscureTextButtonSemanticsLabel,\n        ),\n      ),\n    );\n  }\n\n  final PasswordFieldProperties properties;\n\n  const PasswordField({required this.properties, super.key});\n\n  @override\n  State<PasswordField> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('properties', this.properties));\n  }\n}\n\nclass _State extends State<PasswordField> {\n  late ValueNotifier<bool> _controller = widget.properties.obscureTextController ?? ValueNotifier(true);\n\n  @override\n  void didUpdateWidget(PasswordField old) {\n    super.didUpdateWidget(old);\n    if (widget.properties.obscureTextController != old.properties.obscureTextController) {\n      if (old.properties.obscureTextController == null) {\n        _controller.dispose();\n      }\n      _controller = widget.properties.obscureTextController ?? ValueNotifier(true);\n    }\n  }\n\n  @override\n  void dispose() {\n    if (widget.properties.obscureTextController == null) {\n      _controller.dispose();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => ValueListenableBuilder(\n    valueListenable: _controller,\n    builder: (context, obscured, child) => FTextField(\n      style: widget.properties.style,\n      builder: widget.properties.builder,\n      label: widget.properties.label,\n      hint: widget.properties.hint,\n      description: widget.properties.description,\n      error: widget.properties.error,\n      magnifierConfiguration: widget.properties.magnifierConfiguration,\n      groupId: widget.properties.groupId,\n      controller: widget.properties.controller,\n      focusNode: widget.properties.focusNode,\n      keyboardType: widget.properties.keyboardType,\n      textInputAction: widget.properties.textInputAction,\n      textCapitalization: widget.properties.textCapitalization,\n      textAlign: widget.properties.textAlign,\n      textAlignVertical: widget.properties.textAlignVertical,\n      textDirection: widget.properties.textDirection,\n      autofocus: widget.properties.autofocus,\n      statesController: widget.properties.statesController,\n      obscuringCharacter: widget.properties.obscuringCharacter,\n      obscureText: obscured,\n      autocorrect: widget.properties.autocorrect,\n      smartDashesType: widget.properties.smartDashesType,\n      smartQuotesType: widget.properties.smartQuotesType,\n      enableSuggestions: widget.properties.enableSuggestions,\n      minLines: widget.properties.minLines,\n      maxLines: widget.properties.maxLines,\n      expands: widget.properties.expands,\n      readOnly: widget.properties.readOnly,\n      showCursor: widget.properties.showCursor,\n      maxLength: widget.properties.maxLength,\n      maxLengthEnforcement: widget.properties.maxLengthEnforcement,\n      onChange: widget.properties.onChange,\n      onTap: widget.properties.onTap,\n      onTapOutside: widget.properties.onTapOutside,\n      onTapAlwaysCalled: widget.properties.onTapAlwaysCalled,\n      onEditingComplete: widget.properties.onEditingComplete,\n      onSubmit: widget.properties.onSubmit,\n      onAppPrivateCommand: widget.properties.onAppPrivateCommand,\n      inputFormatters: widget.properties.inputFormatters,\n      enabled: widget.properties.enabled,\n      ignorePointers: widget.properties.ignorePointers,\n      enableInteractiveSelection: widget.properties.enableInteractiveSelection,\n      selectAllOnFocus: widget.properties.selectAllOnFocus,\n      selectionControls: widget.properties.selectionControls,\n      dragStartBehavior: widget.properties.dragStartBehavior,\n      mouseCursor: widget.properties.mouseCursor,\n      counterBuilder: widget.properties.counterBuilder,\n      scrollPhysics: widget.properties.scrollPhysics,\n      scrollController: widget.properties.scrollController,\n      autofillHints: widget.properties.autofillHints,\n      restorationId: widget.properties.restorationId,\n      stylusHandwritingEnabled: widget.properties.stylusHandwritingEnabled,\n      enableIMEPersonalizedLearning: widget.properties.enableIMEPersonalizedLearning,\n      contentInsertionConfiguration: widget.properties.contentInsertionConfiguration,\n      contextMenuBuilder: widget.properties.contextMenuBuilder,\n      canRequestFocus: widget.properties.canRequestFocus,\n      undoController: widget.properties.undoController,\n      spellCheckConfiguration: widget.properties.spellCheckConfiguration,\n      prefixBuilder: widget.properties.prefixBuilder == null\n          ? null\n          : (context, style, states) => widget.properties.prefixBuilder!(context, style, _controller, states),\n      suffixBuilder: widget.properties.suffixBuilder == null\n          ? null\n          : (context, style, states) => widget.properties.suffixBuilder!(context, style, _controller, states),\n      clearable: widget.properties.clearable,\n      initialText: widget.properties.initialText,\n    ),\n  );\n}\n",
      "password_form_field": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/text_field/field.dart';\nimport 'package:forui/src/widgets/text_field/password_field.dart';\n\n/// Internal password form field implementation used by [FTextFormField.password].\n@internal\nclass PasswordFormField extends StatelessWidget with FFormFieldProperties<String> {\n  final PasswordFieldProperties properties;\n\n  @override\n  final FormFieldSetter<String>? onSaved;\n\n  @override\n  final VoidCallback? onReset;\n\n  @override\n  final FormFieldValidator<String>? validator;\n\n  @override\n  final AutovalidateMode autovalidateMode;\n\n  @override\n  final String? forceErrorText;\n\n  @override\n  final Widget Function(BuildContext context, String message) errorBuilder;\n\n  PasswordFormField({\n    required this.properties,\n    required this.onSaved,\n    required this.onReset,\n    required this.validator,\n    required this.autovalidateMode,\n    required this.forceErrorText,\n    required this.errorBuilder,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) => Field(\n    controller: properties.controller,\n    onSaved: onSaved,\n    onReset: onReset,\n    validator: validator,\n    initialValue: properties.controller?.text ?? properties.initialText,\n    enabled: enabled,\n    autovalidateMode: autovalidateMode,\n    forceErrorText: forceErrorText,\n    restorationId: properties.restorationId,\n    builder: (state) => PasswordField(\n      properties: PasswordFieldProperties(\n        style: properties.style,\n        builder: properties.builder,\n        label: properties.label,\n        hint: properties.hint,\n        description: properties.description,\n        error: switch (state.errorText) {\n          null => null,\n          final error => errorBuilder(state.context, error),\n        },\n        magnifierConfiguration: properties.magnifierConfiguration,\n        groupId: properties.groupId,\n        controller: state.effectiveController,\n        initialText: null,\n        // We set this to null to avoid conflicts with controller.\n        focusNode: properties.focusNode,\n        keyboardType: properties.keyboardType,\n        textInputAction: properties.textInputAction,\n        textCapitalization: properties.textCapitalization,\n        textAlign: properties.textAlign,\n        textAlignVertical: properties.textAlignVertical,\n        textDirection: properties.textDirection,\n        autofocus: properties.autofocus,\n        statesController: properties.statesController,\n        obscuringCharacter: properties.obscuringCharacter,\n        autocorrect: properties.autocorrect,\n        smartDashesType: properties.smartDashesType,\n        smartQuotesType: properties.smartQuotesType,\n        enableSuggestions: properties.enableSuggestions,\n        minLines: properties.minLines,\n        maxLines: properties.maxLines,\n        expands: properties.expands,\n        readOnly: properties.readOnly,\n        showCursor: properties.showCursor,\n        maxLength: properties.maxLength,\n        maxLengthEnforcement: properties.maxLengthEnforcement,\n        onChange: (value) {\n          state.didChange(value);\n          properties.onChange?.call(value);\n        },\n        onTap: properties.onTap,\n        onTapOutside: properties.onTapOutside,\n        onTapAlwaysCalled: properties.onTapAlwaysCalled,\n        onEditingComplete: properties.onEditingComplete,\n        onSubmit: properties.onSubmit,\n        onAppPrivateCommand: properties.onAppPrivateCommand,\n        inputFormatters: properties.inputFormatters,\n        enabled: properties.enabled,\n        ignorePointers: properties.ignorePointers,\n        enableInteractiveSelection: properties.enableInteractiveSelection,\n        selectAllOnFocus: properties.selectAllOnFocus,\n        selectionControls: properties.selectionControls,\n        dragStartBehavior: properties.dragStartBehavior,\n        mouseCursor: properties.mouseCursor,\n        counterBuilder: properties.counterBuilder,\n        scrollPhysics: properties.scrollPhysics,\n        scrollController: properties.scrollController,\n        autofillHints: properties.autofillHints,\n        restorationId: properties.restorationId,\n        stylusHandwritingEnabled: properties.stylusHandwritingEnabled,\n        enableIMEPersonalizedLearning: properties.enableIMEPersonalizedLearning,\n        contentInsertionConfiguration: properties.contentInsertionConfiguration,\n        contextMenuBuilder: properties.contextMenuBuilder,\n        canRequestFocus: properties.canRequestFocus,\n        undoController: properties.undoController,\n        spellCheckConfiguration: properties.spellCheckConfiguration,\n        prefixBuilder: properties.prefixBuilder,\n        suffixBuilder: properties.suffixBuilder,\n        clearable: properties.clearable,\n        obscureTextController: properties.obscureTextController,\n      ),\n      key: key,\n    ),\n  );\n\n  @override\n  Widget? get label => properties.label;\n\n  @override\n  Widget? get description => properties.description;\n\n  @override\n  bool get enabled => properties.enabled;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('properties', properties));\n  }\n}\n",
      "text_field": "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'package:flutter_localizations/flutter_localizations.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/localizations/localized_text.dart';\nimport 'package:forui/src/widgets/text_field/password_field.dart';\n\n/// A callback for building a custom counter for a text field.\n///\n/// [currentLength] is the length of the text field's input.\n/// [maxLength] is the maximum length of the text field's input.\n/// [focused] is whether the text field is currently focused.\n///\n/// See [FTextField.counterBuilder].\ntypedef FTextFieldCounterBuilder =\n    // ignore: avoid_positional_boolean_parameters\n    Widget? Function(BuildContext context, int currentLength, int? maxLength, bool focused);\n\n/// A callback for decorating a field. It should always use the given field.\n///\n/// [style] is the field's style.\n/// [states] is the current states of the widget.\n/// [field] is the field that will be decorated.\n///\n/// See [FTextField.builder].\ntypedef FFieldBuilder<T> = Widget Function(BuildContext context, T style, Set<WidgetState> states, Widget field);\n\n/// A callback for building a field's icon.\n///\n/// [style] is the field's style.\n/// [states] is the current states of the widget.\n///\n/// See [FTextField.prefixBuilder] and [FTextField.suffixBuilder].\ntypedef FFieldIconBuilder<T> = Widget Function(BuildContext context, T style, Set<WidgetState> states);\n\n@internal\nextension Defaults on Never {\n  static bool clearable(TextEditingValue _) => false;\n\n  static Widget contextMenuBuilder(BuildContext _, EditableTextState state) =>\n      AdaptiveTextSelectionToolbar.editableText(editableTextState: state);\n\n  static Widget builder(BuildContext _, FTextFieldStyle _, Set<WidgetState> _, Widget child) => child;\n}\n\n/// A text field.\n///\n/// It lets the user enter text, either with a hardware keyboard or with an onscreen keyboard.\n///\n/// See:\n/// * https://forui.dev/docs/form/text-field for working examples.\n/// * [FTextFieldStyle] for customizing a text field's appearance.\n/// * [FTextFormField] for creating a text field that can be used in a form.\n/// * [TextField] for more details about working with a text field.\nclass FTextField extends StatefulWidget {\n  /// Creates a [FTextField] configured for password entry with a visibility toggle.\n  ///\n  /// By default, [suffixBuilder] is an eye icon that toggles showing and hiding the password. Replace the toggle by\n  /// providing a custom [suffixBuilder], or disable it by setting it to `null`.\n  ///\n  /// The [obscureTextController] parameter is a [ValueNotifier] that controls the obscuring state.\n  ///\n  /// [autofillHints] defaults to [AutofillHints.password]. Use [AutofillHints.newPassword] for new-password inputs.\n  static Widget password({\n    FTextFieldStyle Function(FTextFieldStyle style)? style,\n    FFieldBuilder<FTextFieldStyle> builder = Defaults.builder,\n    Widget? label = const LocalizedText.password(),\n    String? hint,\n    Widget? description,\n    Widget? error,\n    TextMagnifierConfiguration? magnifierConfiguration,\n    Object groupId = EditableText,\n    TextEditingController? controller,\n    FocusNode? focusNode,\n    TextInputType? keyboardType,\n    TextInputAction textInputAction = TextInputAction.next,\n    TextCapitalization textCapitalization = TextCapitalization.none,\n    TextAlign textAlign = TextAlign.start,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    bool autofocus = false,\n    WidgetStatesController? statesController,\n    String obscuringCharacter = '\u2022',\n    bool autocorrect = false,\n    SmartDashesType? smartDashesType,\n    SmartQuotesType? smartQuotesType,\n    bool enableSuggestions = false,\n    int? minLines,\n    int maxLines = 1,\n    bool expands = false,\n    bool readOnly = false,\n    bool? showCursor,\n    int? maxLength,\n    MaxLengthEnforcement? maxLengthEnforcement,\n    ValueChanged<String>? onChange,\n    GestureTapCallback? onTap,\n    TapRegionCallback? onTapOutside,\n    bool onTapAlwaysCalled = false,\n    VoidCallback? onEditingComplete,\n    ValueChanged<String>? onSubmit,\n    AppPrivateCommandCallback? onAppPrivateCommand,\n    List<TextInputFormatter>? inputFormatters,\n    bool enabled = true,\n    bool? ignorePointers,\n    bool enableInteractiveSelection = true,\n    bool? selectAllOnFocus,\n    TextSelectionControls? selectionControls,\n    DragStartBehavior dragStartBehavior = DragStartBehavior.start,\n    MouseCursor? mouseCursor,\n    FTextFieldCounterBuilder? counterBuilder,\n    ScrollPhysics? scrollPhysics,\n    ScrollController? scrollController,\n    Iterable<String> autofillHints = const [AutofillHints.password],\n    String? restorationId,\n    bool stylusHandwritingEnabled = true,\n    bool enableIMEPersonalizedLearning = true,\n    ContentInsertionConfiguration? contentInsertionConfiguration,\n    EditableTextContextMenuBuilder contextMenuBuilder = Defaults.contextMenuBuilder,\n    bool canRequestFocus = true,\n    UndoHistoryController? undoController,\n    SpellCheckConfiguration? spellCheckConfiguration,\n    FPasswordFieldIconBuilder<FTextFieldStyle>? prefixBuilder,\n    FPasswordFieldIconBuilder<FTextFieldStyle>? suffixBuilder = PasswordField.defaultToggleBuilder,\n    bool Function(TextEditingValue) clearable = Defaults.clearable,\n    String? initialText,\n    ValueNotifier<bool>? obscureTextController,\n    Key? key,\n  }) => PasswordField(\n    properties: PasswordFieldProperties(\n      style: style,\n      builder: builder,\n      label: label,\n      hint: hint,\n      description: description,\n      error: error,\n      magnifierConfiguration: magnifierConfiguration,\n      groupId: groupId,\n      controller: controller,\n      focusNode: focusNode,\n      keyboardType: keyboardType,\n      textInputAction: textInputAction,\n      textCapitalization: textCapitalization,\n      textAlign: textAlign,\n      textAlignVertical: textAlignVertical,\n      textDirection: textDirection,\n      autofocus: autofocus,\n      statesController: statesController,\n      obscuringCharacter: obscuringCharacter,\n      autocorrect: autocorrect,\n      smartDashesType: smartDashesType,\n      smartQuotesType: smartQuotesType,\n      enableSuggestions: enableSuggestions,\n      minLines: minLines,\n      maxLines: maxLines,\n      expands: expands,\n      readOnly: readOnly,\n      showCursor: showCursor,\n      maxLength: maxLength,\n      maxLengthEnforcement: maxLengthEnforcement,\n      onChange: onChange,\n      onTap: onTap,\n      onTapOutside: onTapOutside,\n      onTapAlwaysCalled: onTapAlwaysCalled,\n      onEditingComplete: onEditingComplete,\n      onSubmit: onSubmit,\n      onAppPrivateCommand: onAppPrivateCommand,\n      inputFormatters: inputFormatters,\n      enabled: enabled,\n      ignorePointers: ignorePointers,\n      enableInteractiveSelection: enableInteractiveSelection,\n      selectAllOnFocus: selectAllOnFocus,\n      selectionControls: selectionControls,\n      dragStartBehavior: dragStartBehavior,\n      mouseCursor: mouseCursor,\n      counterBuilder: counterBuilder,\n      scrollPhysics: scrollPhysics,\n      scrollController: scrollController,\n      autofillHints: autofillHints,\n      restorationId: restorationId,\n      stylusHandwritingEnabled: stylusHandwritingEnabled,\n      enableIMEPersonalizedLearning: enableIMEPersonalizedLearning,\n      contentInsertionConfiguration: contentInsertionConfiguration,\n      contextMenuBuilder: contextMenuBuilder,\n      canRequestFocus: canRequestFocus,\n      undoController: undoController,\n      spellCheckConfiguration: spellCheckConfiguration,\n      prefixBuilder: prefixBuilder,\n      suffixBuilder: suffixBuilder,\n      clearable: clearable,\n      initialText: initialText,\n      obscureTextController: obscureTextController,\n    ),\n    key: key,\n  );\n\n  /// {@template forui.text_field.style}\n  /// The text field's style. Defaults to [FThemeData.textFieldStyle].\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create text-field\n  /// ```\n  /// {@endtemplate}\n  final FTextFieldStyle Function(FTextFieldStyle style)? style;\n\n  /// {@template forui.text_field.builder}\n  /// The builder used to decorate the text-field. It should always use the given child.\n  ///\n  /// Defaults to returning the given child.\n  /// {@endtemplate}\n  final FFieldBuilder<FTextFieldStyle> builder;\n\n  /// {@template forui.text_field.label}\n  /// A builder that creates a widget to display validation errors.\n  /// {@endtemplate}\n  final Widget? label;\n\n  /// {@template forui.text_field.hint}\n  /// The text to display when the text field is empty.\n  ///\n  /// See [InputDecoration.hintText] for more information.\n  /// {@endtemplate}\n  final String? hint;\n\n  /// {@template forui.text_field.description}\n  /// The description text.\n  ///\n  /// See [InputDecoration.helper] for more information.\n  /// {@endtemplate}\n  final Widget? description;\n\n  /// {@template forui.text_field.error}\n  /// The error message.\n  /// {@endtemplate}\n  final Widget? error;\n\n  /// {@template forui.text_field.magnifier_configuration}\n  /// The configuration for the magnifier of this text field.\n  ///\n  /// By default, builds a [CupertinoTextMagnifier] on iOS and [TextMagnifier] on Android, and builds nothing on all\n  /// other platforms. To suppress the magnifier, consider passing [TextMagnifierConfiguration.disabled].\n  /// {@endtemplate}\n  final TextMagnifierConfiguration? magnifierConfiguration;\n\n  /// {@template forui.text_field_groupId}\n  /// The group identifier for the [TextFieldTapRegion] of this text field.\n  ///\n  /// Text fields with the same group identifier share the same tap region. Defaults to the type of [EditableText].\n  /// {@endtemplate}\n  final Object groupId;\n\n  /// {@template forui.text_field.controller}\n  /// Controls the text being edited. If null, this widget will create its own [TextEditingController].\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if both [controller] and [initialText] are provided.\n  /// {@endtemplate}\n  final TextEditingController? controller;\n\n  /// {@template forui.text_field.keyboardType}\n  /// The type of keyboard to use for editing the text. Defaults to [TextInputType.text] if maxLines is one and\n  /// [TextInputType.multiline] otherwise.\n  /// {@endtemplate}\n  final TextInputType? keyboardType;\n\n  /// {@template forui.text_field.textInputAction}\n  /// The type of action button to use for the keyboard.\n  ///\n  /// Defaults to [TextInputAction.newline] if [keyboardType] is [TextInputType.multiline] and [TextInputAction.done]\n  /// otherwise.\n  /// {@endtemplate}\n  final TextInputAction? textInputAction;\n\n  /// {@template forui.text_field.textCapitalization}\n  /// Configures how the platform keyboard will select an uppercase or lowercase keyboard. Defaults to\n  /// [TextCapitalization.none].\n  ///\n  /// Only supports text keyboards, other keyboard types will ignore this configuration. Capitalization is locale-aware.\n  ///\n  /// See [TextCapitalization] for a description of each capitalization behavior.\n  /// {@endtemplate}\n  final TextCapitalization textCapitalization;\n\n  /// {@template forui.text_field.textAlign}\n  /// How the text should be aligned horizontally.\n  ///\n  /// Defaults to [TextAlign.start].\n  /// {@endtemplate}\n  final TextAlign textAlign;\n\n  /// {@template forui.text_field.textAlignVertical}\n  /// How the text should be aligned vertically.\n  ///\n  /// See [TextAlignVertical] for more information.\n  /// {@endtemplate}\n  final TextAlignVertical? textAlignVertical;\n\n  /// {@template forui.text_field.textDirection}\n  /// The directionality of the text. Defaults to the ambient [Directionality], if any.\n  ///\n  /// See [TextField.textDirection] for more information.\n  /// {@endtemplate}\n  final TextDirection? textDirection;\n\n  /// {@template forui.text_field.autofocus}\n  /// Whether this text field should focus itself if nothing else is already focused. Defaults to false.\n  ///\n  /// If true, the keyboard will open as soon as this text field obtains focus. Otherwise, the keyboard is only shown\n  /// after the user taps the text field.\n  /// {@endtemplate}\n  final bool autofocus;\n\n  /// {@template forui.text_field.focusNode}\n  /// Defines the keyboard focus for this [FTextField].\n  ///\n  /// See [TextField.focusNode] for more information.\n  /// {@endtemplate}\n  final FocusNode? focusNode;\n\n  /// {@template forui.text_field.statesController}\n  /// Represents the interactive \"state\" of this widget in terms of a set of [WidgetState]s, including\n  /// [WidgetState.disabled], [WidgetState.hovered], [WidgetState.error], and [WidgetState.focused].\n  ///\n  /// See [TextField.statesController] for more information.\n  /// {@endtemplate}\n  final WidgetStatesController? statesController;\n\n  /// {@template forui.text_field.obscuringCharacter}\n  /// Character used for obscuring text if [obscureText] is true.\n  ///\n  /// Must be only a single character.\n  ///\n  /// Defaults to the character U+2022 BULLET (\u2022).\n  /// {@endtemplate}\n  final String obscuringCharacter;\n\n  /// {@template forui.text_field.obscureText}\n  /// Whether to hide the text being edited (e.g., for passwords). Defaults to false.\n  ///\n  /// When this is set to true, all the characters in the text field are obscured, and the text in the field cannot be\n  /// copied with copy or cut. If [readOnly] is also true, then the text cannot be selected.\n  /// {@endtemplate}\n  final bool obscureText;\n\n  /// {@template forui.text_field.autocorrect}\n  /// Whether to enable autocorrection. Defaults to true.\n  /// {@endtemplate}\n  final bool autocorrect;\n\n  /// {@template forui.text_field.smartDashesType}\n  /// Whether to allow the platform to automatically format dashes.\n  ///\n  /// See [TextField.smartDashesType] for more information.\n  /// {@endtemplate}\n  final SmartDashesType? smartDashesType;\n\n  /// {@template forui.text_field.smartQuotesType}\n  /// Whether to allow the platform to automatically format quotes.\n  ///\n  /// See [TextField.smartQuotesType] for more information.\n  /// {@endtemplate}\n  final SmartQuotesType? smartQuotesType;\n\n  /// {@template forui.text_field.enableSuggestions}\n  /// Whether to show input suggestions as the user types. Defaults to true.\n  ///\n  /// This flag only affects Android. On iOS, suggestions are tied directly to [autocorrect], so that suggestions are\n  /// only shown when [autocorrect] is true. On Android autocorrection and suggestion are controlled separately.\n  ///\n  /// See also:\n  ///  * <https://developer.android.com/reference/android/text/InputType.html#TYPE_TEXT_FLAG_NO_SUGGESTIONS>\n  /// {@endtemplate}\n  final bool enableSuggestions;\n\n  /// {@template forui.text_field.minLines}\n  /// The minimum number of lines to occupy when the content spans fewer lines.\n  ///\n  /// This affects the height of the field itself and does not limit the number of lines that can be entered into the field.\n  ///\n  /// If this is null (default), text container starts with enough vertical space for one line and grows to accommodate\n  /// additional lines as they are entered.\n  ///\n  /// This can be used in combination with [maxLines] for a varying set of behaviors.\n  ///\n  /// If the value is set, it must be greater than zero. If the value is greater than 1, [maxLines] should also be set\n  /// to either null or greater than this value.\n  ///\n  /// When [maxLines] is set as well, the height will grow between the indicated range of lines. When [maxLines] is null,\n  /// it will grow as high as needed, starting from [minLines].\n  ///\n  /// Defaults to null.\n  ///\n  /// See also:\n  ///  * [maxLines], which sets the maximum number of lines visible, and has several examples of how minLines and\n  ///    maxLines interact to produce various behaviors.\n  ///  * [expands], which determines whether the field should fill the height of its widget.\n  /// {@endtemplate}\n  final int? minLines;\n\n  /// {@template forui.text_field.maxLines}\n  /// The maximum number of lines to show at one time, wrapping if necessary.\n  ///\n  /// This affects the height of the field itself and does not limit the number of lines that can be entered into the\n  /// field.\n  ///\n  /// If this is 1 (the default), the text will not wrap, but will scroll horizontally instead.\n  ///\n  /// If this is null, there is no limit to the number of lines, and the text container will start with enough vertical\n  /// space for one line and automatically grow to accommodate additional lines as they are entered, up to the height of\n  /// its constraints.\n  ///\n  /// If this is not null, the value must be greater than zero, and it will lock the input to the given number of lines\n  /// and take up enough horizontal space to accommodate that number of lines. Setting [minLines] as well allows the\n  /// input to grow and shrink between the indicated range.\n  ///\n  /// See also:\n  ///  * [minLines], which sets the minimum number of lines visible.\n  ///  * [expands], which determines whether the field should fill the height of its widget.\n  /// {@endtemplate}\n  final int? maxLines;\n\n  /// {@template forui.text_field.expands}\n  /// Whether this widget's height will be sized to fill its widget. Defaults to false.\n  ///\n  /// If set to true and wrapped in a widget widget like [Expanded] or [SizedBox], the input will expand to fill the\n  /// widget.\n  ///\n  /// [maxLines] and [minLines] must both be null when this is set to true, otherwise an error is thrown.\n  ///\n  /// See the examples in [maxLines] for the complete picture of how [maxLines], [minLines], and [expands] interact to\n  /// produce various behaviors.\n  ///\n  /// Input that matches the height of its widget:\n  /// ```dart\n  /// const Expanded(\n  ///   child: FTextField(maxLines: null, expands: true),\n  /// )\n  /// ```\n  /// {@endtemplate}\n  final bool expands;\n\n  /// {@template forui.text_field.readOnly}\n  /// Whether the text can be changed. Defaults to false.\n  ///\n  /// When this is set to true, the text cannot be modified by any shortcut or keyboard operation. The text is still\n  /// selectable.\n  /// {@endtemplate}\n  final bool readOnly;\n\n  /// {@template forui.text_field.showCursor}\n  /// Whether to show cursor.\n  ///\n  /// The cursor refers to the blinking caret when this [FTextField] is focused.\n  /// {@endtemplate}\n  final bool? showCursor;\n\n  /// {@template forui.text_field.maxLength}\n  /// The maximum number of characters (Unicode grapheme clusters) to allow in the text field.\n  ///\n  /// If set, a character counter will be displayed below the field showing how many characters have been entered. If\n  /// set to a number greater than 0, it will also display the maximum number allowed. If set to [TextField.noMaxLength]\n  /// then only the current character count is displayed.\n  ///\n  /// After [maxLength] characters have been input, additional input is ignored, unless [maxLengthEnforcement] is set to\n  /// [MaxLengthEnforcement.none].\n  ///\n  /// The text field enforces the length with a [LengthLimitingTextInputFormatter], which is evaluated after the supplied\n  /// [inputFormatters], if any.\n  ///\n  /// This value must be either null, [TextField.noMaxLength], or greater than 0. If null (the default) then there is no\n  /// limit to the number of characters that can be entered. If set to [TextField.noMaxLength], then no limit will be\n  /// enforced, but the number of characters entered will still be displayed.\n  ///\n  /// Whitespace characters (e.g. newline, space, tab) are included in the character count.\n  ///\n  /// If [maxLengthEnforcement] is [MaxLengthEnforcement.none], then more than [maxLength] characters may be entered,\n  /// but the error counter and divider will switch to the [style]'s error style when the limit is exceeded.\n  /// {@endtemplate}\n  final int? maxLength;\n\n  /// {@template forui.text_field.maxLengthEnforcement}\n  /// Determines how the [maxLength] limit should be enforced.\n  /// {@endtemplate}\n  final MaxLengthEnforcement? maxLengthEnforcement;\n\n  /// {@template forui.text_field.onChange}\n  /// Called when the user initiates a change to the TextField's value: when they have inserted or deleted text.\n  ///\n  /// This callback doesn't run when the TextField's text is changed programmatically, via the TextField's [controller].\n  /// Typically it isn't necessary to be notified of such changes, since they're initiated by the app itself.\n  ///\n  /// To be notified of all changes to the TextField's text, cursor, and selection, one can add a listener to its\n  /// [controller] with [TextEditingController.addListener].\n  ///\n  /// [onChange] is called before [onSubmit] when user indicates completion of editing, such as when pressing the \"done\"\n  /// button on the keyboard. That default behavior can be overridden. See [onEditingComplete] for details.\n  ///\n  /// See also:\n  ///  * [inputFormatters], which are called before [onChange] runs and can validate and change (\"format\") the input value.\n  ///  * [onEditingComplete], [onSubmit]: which are more specialized input change notifications.\n  /// {@endtemplate}\n  final ValueChanged<String>? onChange;\n\n  /// {@template forui.text_field.onTap}\n  /// Called for the first tap in a series of taps.\n  ///\n  /// The text field builds a [GestureDetector] to handle input events like tap, to trigger focus requests, to move the\n  /// caret, adjust the selection, etc. Handling some of those events by wrapping the text field with a competing\n  /// GestureDetector is problematic.\n  ///\n  /// To unconditionally handle taps, without interfering with the text field's internal gesture detector, provide this\n  /// callback.\n  ///\n  /// If the text field is created with [enabled] false, taps will not be recognized.\n  ///\n  /// To be notified when the text field gains or loses the focus, provide a [focusNode] and add a listener to that.\n  ///\n  /// To listen to arbitrary pointer events without competing with the text field's internal gesture detector, use a\n  /// [Listener].\n  ///\n  /// If [onTapAlwaysCalled] is enabled, this will also be called for consecutive taps.\n  /// {@endtemplate}\n  final GestureTapCallback? onTap;\n\n  /// {@template forui.text_field.onTapOutside}\n  /// Called for each tap down that occurs outside of the [TextFieldTapRegion]\n  /// group when the text field is focused.\n  ///\n  /// If this is null, [EditableTextTapOutsideIntent] will be invoked. In the\n  /// default implementation, [FocusNode.unfocus] will be called on the\n  /// [focusNode] for this text field when a [PointerDownEvent] is received on\n  /// another part of the UI. However, it will not unfocus as a result of mobile\n  /// application touch events (which does not include mouse clicks), to conform\n  /// with the platform conventions. To change this behavior, a callback may be\n  /// set here or [EditableTextTapOutsideIntent] may be overridden.\n  ///\n  /// When adding additional controls to a text field (for example, a spinner, a\n  /// button that copies the selected text, or modifies formatting), it is\n  /// helpful if tapping on that control doesn't unfocus the text field. In\n  /// order for an external widget to be considered as part of the text field\n  /// for the purposes of tapping \"outside\" of the field, wrap the control in a\n  /// [TextFieldTapRegion].\n  ///\n  /// The [PointerDownEvent] passed to the function is the event that caused the\n  /// notification. It is possible that the event may occur outside of the\n  /// immediate bounding box defined by the text field, although it will be\n  /// within the bounding box of a [TextFieldTapRegion] member.\n  /// {@endtemplate}\n  final TapRegionCallback? onTapOutside;\n\n  /// {@template forui.text_field.onTapAlwaysCalled}\n  /// Whether [onTap] should be called for every tap.\n  ///\n  /// Defaults to false, so [onTap] is only called for each distinct tap. When enabled, [onTap] is called for every tap\n  /// including consecutive taps.\n  /// {@endtemplate}\n  final bool onTapAlwaysCalled;\n\n  /// {@template forui.text_field.onEditingComplete}\n  /// Called when the user submits editable content (e.g., user presses the \"done\" button on the keyboard).\n  ///\n  /// The default implementation of [onEditingComplete] executes 2 different behaviors based on the situation:\n  ///\n  ///  - When a completion action is pressed, such as \"done\", \"go\", \"send\", or \"search\", the user's content is submitted\n  ///    to the [controller] and then focus is given up.\n  ///\n  ///  - When a non-completion action is pressed, such as \"next\" or \"previous\", the user's content is submitted to the\n  ///    [controller], but focus is not given up because developers may want to immediately move focus to another input\n  ///    widget within [onSubmit].\n  ///\n  /// Providing [onEditingComplete] prevents the aforementioned default behavior.\n  /// {@endtemplate}\n  final VoidCallback? onEditingComplete;\n\n  /// {@template forui.text_field.onSubmit}\n  /// Called when the user indicates that they are done editing the text in the field.\n  ///\n  /// By default, [onSubmit] is called after [onChange] when the user has finalized editing; or, if the default behavior\n  /// has been overridden, after [onEditingComplete]. See [onEditingComplete] for details.\n  ///\n  /// ## Testing\n  /// The following is the recommended way to trigger [onSubmit] in a test:\n  ///\n  /// ```dart\n  /// await tester.testTextInput.receiveAction(TextInputAction.done);\n  /// ```\n  ///\n  /// Sending a `LogicalKeyboardKey.enter` via `tester.sendKeyEvent` will not trigger [onSubmit]. This is because on a\n  /// real device, the engine translates the enter key to a done action, but `tester.sendKeyEvent` sends the key to the\n  /// framework only.\n  /// {@endtemplate}\n  final ValueChanged<String>? onSubmit;\n\n  /// {@template forui.text_field.onAppPrivateCommand}\n  /// This is used to receive a private command from the input method.\n  ///\n  /// Called when the result of [TextInputClient.performPrivateCommand] is received.\n  ///\n  /// This can be used to provide domain-specific features that are only known between certain input methods and their\n  /// clients.\n  ///\n  /// See also:\n  ///   * [performPrivateCommand](https://developer.android.com/reference/android/view/inputmethod/InputConnection#performPrivateCommand\\(java.lang.String,%20android.os.Bundle\\)),\n  ///     which is the Android documentation for performPrivateCommand, used to send a command from the input method.\n  ///   * [sendAppPrivateCommand](https://developer.android.com/reference/android/view/inputmethod/InputMethodManager#sendAppPrivateCommand),\n  ///     which is the Android documentation for sendAppPrivateCommand, used to send a command to the input method.\n  /// {@endtemplate}\n  final AppPrivateCommandCallback? onAppPrivateCommand;\n\n  /// {@template forui.text_field.inputFormatters}\n  /// Optional input validation and formatting overrides.\n  ///\n  /// Formatters are run in the provided order when the user changes the text this widget contains. When this parameter\n  /// changes, the new formatters will not be applied until the next time the user inserts or deletes text. Similar to\n  /// the [onChange] callback, formatters don't run when the text is changed programmatically via [controller].\n  ///\n  /// See also:\n  ///  * [TextEditingController], which implements the [Listenable] interface and notifies its listeners on\n  ///    [TextEditingValue] changes.\n  /// {@endtemplate}\n  final List<TextInputFormatter>? inputFormatters;\n\n  /// {@template forui.text_field.enabled}\n  /// If false the text field is \"disabled\": it ignores taps. Defaults to true.\n  /// {@endtemplate}\n  final bool enabled;\n\n  /// {@template forui.text_field.ignorePointers}\n  /// Determines whether this widget ignores pointer events. Defaults to null, and when null, does nothing.\n  /// {@endtemplate}\n  final bool? ignorePointers;\n\n  /// {@template forui.text_field.enableInteractiveSelection}\n  /// Whether to enable user interface affordances for changing the text selection. Defaults to true.\n  ///\n  /// For example, setting this to true will enable features such as long-pressing the TextField to select text and show\n  /// the cut/copy/paste menu, and tapping to move the text caret.\n  ///\n  /// When this is false, the text selection cannot be adjusted by the user, text cannot be copied, and the user cannot\n  /// paste into the text field from the clipboard.\n  /// {@endtemplate}\n  final bool enableInteractiveSelection;\n\n  /// {@template forui.text_field.selectAllOnFocus}\n  /// Whether this field should select all text when gaining focus.\n  ///\n  /// When false, focusing this text field will leave its existing text selection unchanged.\n  ///\n  /// Defaults to true on web and desktop platforms, and false on mobile platforms.\n  /// {@endtemplate}\n  final bool? selectAllOnFocus;\n\n  /// {@template forui.text_field.selectionControls}\n  /// Optional delegate for building the text selection handles.\n  ///\n  /// Historically, this field also controlled the toolbar. This is now handled by [contextMenuBuilder] instead. However,\n  /// for backwards compatibility, when [selectionControls] is set to an object that does not mix in\n  // ignore: deprecated_member_use\n  /// [TextSelectionHandleControls], [contextMenuBuilder] is ignored and the [TextSelectionControls.buildToolbar] method\n  /// is used instead.\n  /// {@endtemplate}\n  final TextSelectionControls? selectionControls;\n\n  /// {@template forui.text_field.dragStartBehavior}\n  /// Determines the way that drag start behavior is handled. By default, the drag start behavior is [DragStartBehavior.start].\n  ///\n  /// If set to [DragStartBehavior.start], scrolling drag behavior will begin at the position where the drag gesture won\n  /// the arena. If set to [DragStartBehavior.down] it will begin at the position where a down event is first detected.\n  ///\n  /// In general, setting this to [DragStartBehavior.start] will make drag animation smoother and setting it to\n  /// [DragStartBehavior.down] will make drag behavior feel slightly more reactive.\n  ///\n  /// See also:\n  ///  * [DragGestureRecognizer.dragStartBehavior], which gives an example for the different behaviors.\n  /// {@endtemplate}\n  final DragStartBehavior dragStartBehavior;\n\n  /// {@template forui.text_field.mouseCursor}\n  /// The cursor for a mouse pointer when it enters or is hovering over the widget.\n  /// {@endtemplate}\n  final MouseCursor? mouseCursor;\n\n  /// {@template forui.text_field.counterBuilder}\n  /// The [FTextFieldCounterBuilder] used to build a custom counter for the text field.\n  ///\n  /// The returned widget will be wrapped in a Semantics widget for accessibility, but it also needs to be accessible\n  /// itself. For example, if returning a [Text] widget, set the [Text.semanticsLabel] property.\n  /// {@endtemplate}\n  final FTextFieldCounterBuilder? counterBuilder;\n\n  /// {@template forui.text_field.scrollPhysics}\n  /// The [ScrollPhysics] to use when vertically scrolling the input. If not specified, it will behave according to the\n  /// current platform.\n  ///\n  /// See [Scrollable.physics].\n  /// {@endtemplate}\n  final ScrollPhysics? scrollPhysics;\n\n  /// {@template forui.text_field.scrollController}\n  /// The [ScrollController] to use when vertically scrolling the input. If null, it will instantiate a new ScrollController.\n  ///\n  /// See [Scrollable.controller].\n  /// {@endtemplate}\n  final ScrollController? scrollController;\n\n  /// {@template forui.text_field.autofillHints}\n  /// A list of strings that helps the autofill service identify the type of this text input.\n  ///\n  /// See [TextField.autofillHints] for more information.\n  /// {@endtemplate}\n  final Iterable<String>? autofillHints;\n\n  /// {@template forui.text_field.restorationId}\n  /// Restoration ID to save and restore the state of the text field.\n  ///\n  /// See [TextField.restorationId] for more information.\n  /// {@endtemplate}\n  final String? restorationId;\n\n  /// {@template forui.text_field.stylusHandwritingEnabled}\n  /// Whether this input supports stylus handwriting, where the user can write directly on top of a field.\n  ///\n  /// Currently only the following devices are supported:\n  ///\n  ///  * iPads running iOS 14 and above using an Apple Pencil.\n  ///  * Android devices running API 34 and above and using an active stylus.\n  ///\n  /// On Android, Scribe gestures are detected outside of [EditableText], typically by\n  /// [TextSelectionGestureDetectorBuilder]. This is handled automatically in [FTextField].\n  ///\n  /// See also:\n  ///   * [ScribbleClient], which can be mixed into an arbitrary widget to provide iOS Scribble functionality.\n  ///   * [Scribe], which can be used to interact with Android Scribe directly.\n  /// {@endtemplate}\n  final bool stylusHandwritingEnabled;\n\n  /// {@template forui.text_field.enableIMEPersonalizedLearning}\n  /// Whether to enable that the IME update personalized data such as typing history and user dictionary data.\n  ///\n  /// See [TextField.enableIMEPersonalizedLearning] for more information.\n  /// {@endtemplate}\n  final bool enableIMEPersonalizedLearning;\n\n  /// {@template forui.text_field.contentInsertionConfiguration}\n  /// Configuration of handler for media content inserted via the system input method.\n  ///\n  /// Defaults to null in which case media content insertion will be disabled, and the system will display a message\n  /// informing the user that the text field\n  /// does not support inserting media content.\n  ///\n  /// Set [ContentInsertionConfiguration.onContentInserted] to provide a handler. Additionally,\n  /// set [ContentInsertionConfiguration.allowedMimeTypes] to limit the allowable mime types for inserted content.\n  ///\n  /// If [contentInsertionConfiguration] is not provided, by default an empty list of mime types will be sent to the\n  /// Flutter Engine. A handler function must be provided in order to customize the allowable mime types for inserted\n  /// content.\n  ///\n  /// If rich content is inserted without a handler, the system will display a message informing the user that the\n  /// current text input does not support inserting rich content.\n  /// {@endtemplate}\n  final ContentInsertionConfiguration? contentInsertionConfiguration;\n\n  /// {@template forui.text_field.contextMenuBuilder}\n  /// Builds the text selection toolbar when requested by the user.\n  ///\n  /// See [TextField.contextMenuBuilder] for more information.\n  /// {@endtemplate}\n  final EditableTextContextMenuBuilder? contextMenuBuilder;\n\n  /// {@template forui.text_field.canRequestFocus}\n  /// Determine whether this text field can request the primary focus.\n  ///\n  /// Defaults to true. If false, the text field will not request focus when tapped, or when its context menu is\n  /// displayed. If false it will not be possible to move the focus to the text field with tab key.\n  /// {@endtemplate}\n  final bool canRequestFocus;\n\n  /// {@template forui.text_field.undoController}\n  /// Controls the undo state.\n  ///\n  /// If null, this widget will create its own [UndoHistoryController].\n  /// {@endtemplate}\n  final UndoHistoryController? undoController;\n\n  /// {@template forui.text_field.spellCheckConfiguration}\n  /// Configuration that details how spell check should be performed.\n  ///\n  /// Specifies the [SpellCheckService] used to spell check text input and the [TextStyle] used to style text with\n  /// misspelled words.\n  ///\n  /// If the [SpellCheckService] is left null, spell check is disabled by default unless the [DefaultSpellCheckService]\n  /// is supported, in which case it is used. It is currently supported only on Android and iOS.\n  ///\n  /// If this configuration is left null, then spell check is disabled by default.\n  /// {@endtemplate}\n  final SpellCheckConfiguration? spellCheckConfiguration;\n\n  /// {@template forui.text_field.prefixBuilder}\n  /// The prefix's builder.\n  ///\n  /// See [InputDecoration.prefixIcon] for more information.\n  /// {@endtemplate}\n  final FFieldIconBuilder<FTextFieldStyle>? prefixBuilder;\n\n  /// {@template forui.text_field.suffixBuilder}\n  /// The suffix's builder.\n  ///\n  /// See [InputDecoration.suffixIcon] for more information.\n  /// {@endtemplate}\n  final FFieldIconBuilder<FTextFieldStyle>? suffixBuilder;\n\n  /// {@template forui.text_field.clearable}\n  /// A predicate that returns true if a clear icon should be shown at the end when the text field is not empty.\n  ///\n  /// It is never shown when the text field is disabled.\n  ///\n  /// Defaults to always returning false.\n  /// {@endtemplate}\n  final bool Function(TextEditingValue) clearable;\n\n  /// {@template forui.text_field.initialValue}\n  /// The initial text.\n  ///\n  /// ## Contract\n  /// Throws an [AssertionError] if both [controller] and [initialText] are provided.\n  /// {@endtemplate}\n  final String? initialText;\n\n  /// Creates a [FTextField].\n  const FTextField({\n    this.style,\n    this.builder = Defaults.builder,\n    this.label,\n    this.hint,\n    this.description,\n    this.error,\n    this.magnifierConfiguration,\n    this.groupId = EditableText,\n    this.controller,\n    this.focusNode,\n    this.keyboardType,\n    this.textInputAction,\n    this.textCapitalization = TextCapitalization.none,\n    this.textAlign = TextAlign.start,\n    this.textAlignVertical,\n    this.textDirection,\n    this.autofocus = false,\n    this.statesController,\n    this.obscuringCharacter = '\u2022',\n    this.obscureText = false,\n    this.autocorrect = true,\n    this.smartDashesType,\n    this.smartQuotesType,\n    this.enableSuggestions = true,\n    this.minLines,\n    this.maxLines = 1,\n    this.expands = false,\n    this.readOnly = false,\n    this.showCursor,\n    this.maxLength,\n    this.maxLengthEnforcement,\n    this.onChange,\n    this.onTap,\n    this.onTapOutside,\n    this.onTapAlwaysCalled = false,\n    this.onEditingComplete,\n    this.onSubmit,\n    this.onAppPrivateCommand,\n    this.inputFormatters,\n    this.enabled = true,\n    this.ignorePointers,\n    this.enableInteractiveSelection = true,\n    this.selectAllOnFocus,\n    this.selectionControls,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.mouseCursor,\n    this.counterBuilder,\n    this.scrollPhysics,\n    this.scrollController,\n    this.autofillHints,\n    this.restorationId,\n    this.stylusHandwritingEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contentInsertionConfiguration,\n    this.contextMenuBuilder = Defaults.contextMenuBuilder,\n    this.canRequestFocus = true,\n    this.undoController,\n    this.spellCheckConfiguration,\n    this.prefixBuilder,\n    this.suffixBuilder,\n    this.clearable = Defaults.clearable,\n    this.initialText,\n    super.key,\n  }) : assert(\n         controller == null || initialText == null,\n         'Cannot provide both a controller and an initialText. '\n         'To fix, set the initial text directly in the controller.',\n       );\n\n  /// Creates a [FTextField] configured for emails.\n  const FTextField.email({\n    this.style,\n    this.builder = Defaults.builder,\n    this.label = const LocalizedText.email(),\n    this.hint,\n    this.description,\n    this.error,\n    this.magnifierConfiguration,\n    this.groupId = EditableText,\n    this.controller,\n    this.focusNode,\n    this.keyboardType = TextInputType.emailAddress,\n    this.textInputAction = TextInputAction.next,\n    this.textCapitalization = TextCapitalization.none,\n    this.textAlign = TextAlign.start,\n    this.textAlignVertical,\n    this.textDirection,\n    this.autofocus = false,\n    this.statesController,\n    this.obscuringCharacter = '\u2022',\n    this.obscureText = false,\n    this.autocorrect = false,\n    this.smartDashesType,\n    this.smartQuotesType,\n    this.enableSuggestions = true,\n    this.minLines,\n    this.maxLines = 1,\n    this.expands = false,\n    this.readOnly = false,\n    this.showCursor,\n    this.maxLength,\n    this.maxLengthEnforcement,\n    this.onChange,\n    this.onTap,\n    this.onTapOutside,\n    this.onTapAlwaysCalled = false,\n    this.onEditingComplete,\n    this.onSubmit,\n    this.onAppPrivateCommand,\n    this.inputFormatters,\n    this.enabled = true,\n    this.ignorePointers,\n    this.enableInteractiveSelection = true,\n    this.selectAllOnFocus,\n    this.selectionControls,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.mouseCursor,\n    this.counterBuilder,\n    this.scrollPhysics,\n    this.scrollController,\n    this.autofillHints = const [AutofillHints.email],\n    this.restorationId,\n    this.stylusHandwritingEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contentInsertionConfiguration,\n    this.contextMenuBuilder = Defaults.contextMenuBuilder,\n    this.canRequestFocus = true,\n    this.undoController,\n    this.spellCheckConfiguration,\n    this.prefixBuilder,\n    this.suffixBuilder,\n    this.clearable = Defaults.clearable,\n    this.initialText,\n    super.key,\n  }) : assert(\n         controller == null || initialText == null,\n         'Cannot provide both a controller and an initialText. '\n         'To fix, set the initial text directly in the controller.',\n       );\n\n  /// Creates a [FTextField] configured for multiline inputs.\n  ///\n  /// The text field's height can be configured by adjusting [minLines]. By default, the text field will expand every\n  /// time a new line is added. To limit the maximum height of the text field and make it scrollable, consider setting\n  /// [maxLines].\n  const FTextField.multiline({\n    this.style,\n    this.builder = Defaults.builder,\n    this.label,\n    this.hint,\n    this.description,\n    this.error,\n    this.magnifierConfiguration,\n    this.groupId = EditableText,\n    this.controller,\n    this.focusNode,\n    this.keyboardType,\n    this.textInputAction,\n    this.textCapitalization = TextCapitalization.sentences,\n    this.textAlign = TextAlign.start,\n    this.textAlignVertical,\n    this.textDirection,\n    this.autofocus = false,\n    this.statesController,\n    this.obscuringCharacter = '\u2022',\n    this.obscureText = false,\n    this.autocorrect = true,\n    this.smartDashesType,\n    this.smartQuotesType,\n    this.enableSuggestions = true,\n    this.minLines = 4,\n    this.maxLines,\n    this.expands = false,\n    this.readOnly = false,\n    this.showCursor,\n    this.maxLength,\n    this.maxLengthEnforcement,\n    this.onChange,\n    this.onTap,\n    this.onTapOutside,\n    this.onTapAlwaysCalled = false,\n    this.onEditingComplete,\n    this.onSubmit,\n    this.onAppPrivateCommand,\n    this.inputFormatters,\n    this.enabled = true,\n    this.ignorePointers,\n    this.enableInteractiveSelection = true,\n    this.selectAllOnFocus,\n    this.selectionControls,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.mouseCursor,\n    this.counterBuilder,\n    this.scrollPhysics,\n    this.scrollController,\n    this.autofillHints,\n    this.restorationId,\n    this.stylusHandwritingEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contentInsertionConfiguration,\n    this.contextMenuBuilder = Defaults.contextMenuBuilder,\n    this.canRequestFocus = true,\n    this.undoController,\n    this.spellCheckConfiguration,\n    this.prefixBuilder,\n    this.suffixBuilder,\n    this.clearable = Defaults.clearable,\n    this.initialText,\n    super.key,\n  }) : assert(\n         controller == null || initialText == null,\n         'Cannot provide both a controller and an initialText. '\n         'To fix, set the initial text directly in the controller.',\n       );\n\n  @override\n  State<FTextField> createState() => _State();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(StringProperty('hint', hint))\n      ..add(DiagnosticsProperty('magnifierConfiguration', magnifierConfiguration))\n      ..add(DiagnosticsProperty('groupId', groupId))\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(DiagnosticsProperty('keyboardType', keyboardType))\n      ..add(EnumProperty('textInputAction', textInputAction))\n      ..add(EnumProperty('textCapitalization', textCapitalization))\n      ..add(EnumProperty('textAlign', textAlign))\n      ..add(DiagnosticsProperty('textAlignVertical', textAlignVertical))\n      ..add(EnumProperty('textDirection', textDirection))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('statesController', statesController))\n      ..add(StringProperty('obscuringCharacter', obscuringCharacter, defaultValue: '\u2022'))\n      ..add(FlagProperty('obscureText', value: obscureText, ifTrue: 'obscureText'))\n      ..add(FlagProperty('autocorrect', value: autocorrect, ifTrue: 'autocorrect'))\n      ..add(EnumProperty('smartDashesType', smartDashesType))\n      ..add(EnumProperty('smartQuotesType', smartQuotesType))\n      ..add(FlagProperty('enableSuggestions', value: enableSuggestions, ifTrue: 'enableSuggestions'))\n      ..add(IntProperty('minLines', minLines))\n      ..add(IntProperty('maxLines', maxLines))\n      ..add(FlagProperty('expands', value: expands, ifTrue: 'expands'))\n      ..add(FlagProperty('readOnly', value: readOnly, ifTrue: 'readOnly'))\n      ..add(FlagProperty('showCursor', value: showCursor, ifTrue: 'showCursor'))\n      ..add(IntProperty('maxLength', maxLength))\n      ..add(EnumProperty('maxLengthEnforcement', maxLengthEnforcement))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onTap', onTap))\n      ..add(ObjectFlagProperty.has('onTapOutside', onTapOutside))\n      ..add(FlagProperty('onTapAlwaysCalled', value: onTapAlwaysCalled, ifTrue: 'onTapAlwaysCalled'))\n      ..add(ObjectFlagProperty.has('onEditingComplete', onEditingComplete))\n      ..add(ObjectFlagProperty.has('onSubmit', onSubmit))\n      ..add(ObjectFlagProperty.has('onAppPrivateCommand', onAppPrivateCommand))\n      ..add(IterableProperty('inputFormatters', inputFormatters))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(FlagProperty('ignorePointers', value: ignorePointers, ifTrue: 'ignorePointers'))\n      ..add(\n        FlagProperty('enableInteractSelection', value: enableInteractiveSelection, ifTrue: 'enableInteractSelection'),\n      )\n      ..add(FlagProperty('selectAllOnFocus', value: selectAllOnFocus, ifTrue: 'selectAllOnFocus'))\n      ..add(DiagnosticsProperty('selectionControls', selectionControls))\n      ..add(EnumProperty('dragStartBehavior', dragStartBehavior))\n      ..add(DiagnosticsProperty('mouseCursor', mouseCursor))\n      ..add(ObjectFlagProperty.has('buildCounter', counterBuilder))\n      ..add(DiagnosticsProperty('scrollPhysics', scrollPhysics))\n      ..add(DiagnosticsProperty('scrollController', scrollController))\n      ..add(IterableProperty('autofillHints', autofillHints))\n      ..add(StringProperty('restorationId', restorationId))\n      ..add(\n        FlagProperty('stylusHandwritingEnabled', value: stylusHandwritingEnabled, ifTrue: 'stylusHandwritingEnabled'),\n      )\n      ..add(\n        FlagProperty(\n          'enableIMEPersonalizedLearning',\n          value: enableIMEPersonalizedLearning,\n          ifTrue: 'enableIMEPersonalizedLearning',\n        ),\n      )\n      ..add(DiagnosticsProperty('contentInsertionConfiguration', contentInsertionConfiguration))\n      ..add(ObjectFlagProperty.has('contextMenuBuilder', contextMenuBuilder))\n      ..add(FlagProperty('canRequestFocus', value: canRequestFocus, ifTrue: 'canRequestFocus'))\n      ..add(DiagnosticsProperty('undoController', undoController))\n      ..add(DiagnosticsProperty('spellCheckConfiguration', spellCheckConfiguration))\n      ..add(ObjectFlagProperty.has('prefixBuilder', prefixBuilder))\n      ..add(ObjectFlagProperty.has('suffixBuilder', suffixBuilder))\n      ..add(ObjectFlagProperty.has('clearable', clearable))\n      ..add(StringProperty('initialText', initialText));\n  }\n}\n\nclass _State extends State<FTextField> {\n  late TextEditingController _controller;\n  late WidgetStatesController _statesController;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = widget.controller ?? TextEditingController(text: widget.initialText);\n    _controller.addListener(_handleOnChange);\n\n    _statesController = widget.statesController ?? WidgetStatesController();\n    _statesController.addListener(_handleStatesChange);\n  }\n\n  @override\n  void didUpdateWidget(covariant FTextField old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        _controller.removeListener(_handleOnChange);\n      }\n\n      _controller = widget.controller ?? TextEditingController(text: widget.initialText);\n      _controller.addListener(_handleOnChange);\n    }\n\n    if (widget.statesController != old.statesController) {\n      if (old.statesController == null) {\n        _statesController.dispose();\n      } else {\n        _statesController.removeListener(_handleStatesChange);\n      }\n\n      _statesController = widget.statesController ?? WidgetStatesController();\n      _statesController.addListener(_handleStatesChange);\n    }\n  }\n\n  void _handleOnChange() => widget.onChange?.call(_controller.text);\n\n  void _handleStatesChange() => SchedulerBinding.instance.addPostFrameCallback((_) {\n    if (mounted) {\n      setState(() {});\n    }\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.textFieldStyle) ?? context.theme.textFieldStyle;\n    final states = {..._statesController.value};\n\n    final textfield = TextField(\n      controller: _controller,\n      decoration: _decoration(style),\n      focusNode: widget.focusNode,\n      undoController: widget.undoController,\n      cursorErrorColor: style.cursorColor,\n      keyboardType: widget.keyboardType,\n      textInputAction: widget.textInputAction,\n      textCapitalization: widget.textCapitalization,\n      style: style.contentTextStyle.resolve(states),\n      textAlign: widget.textAlign,\n      textAlignVertical: widget.textAlignVertical,\n      textDirection: widget.textDirection,\n      readOnly: widget.readOnly,\n      showCursor: widget.showCursor,\n      autofocus: widget.autofocus,\n      statesController: _statesController,\n      obscuringCharacter: widget.obscuringCharacter,\n      obscureText: widget.obscureText,\n      autocorrect: widget.autocorrect,\n      smartDashesType: widget.smartDashesType,\n      smartQuotesType: widget.smartQuotesType,\n      enableSuggestions: widget.enableSuggestions,\n      maxLines: widget.maxLines,\n      minLines: widget.minLines,\n      expands: widget.expands,\n      maxLength: widget.maxLength,\n      maxLengthEnforcement: widget.maxLengthEnforcement,\n      onTap: widget.onTap,\n      onTapOutside: widget.onTapOutside,\n      onTapAlwaysCalled: widget.onTapAlwaysCalled,\n      onEditingComplete: widget.onEditingComplete,\n      onSubmitted: widget.onSubmit,\n      onAppPrivateCommand: widget.onAppPrivateCommand,\n      inputFormatters: widget.inputFormatters,\n      enabled: widget.enabled,\n      ignorePointers: widget.ignorePointers,\n      enableInteractiveSelection: widget.enableInteractiveSelection,\n      keyboardAppearance: style.keyboardAppearance,\n      scrollPadding: style.scrollPadding,\n      dragStartBehavior: widget.dragStartBehavior,\n      mouseCursor: widget.mouseCursor,\n      buildCounter: (context, {required currentLength, required isFocused, required maxLength}) {\n        final counter = widget.counterBuilder?.call(context, currentLength, maxLength, isFocused);\n        return counter == null\n            ? null\n            : DefaultTextStyle.merge(style: style.counterTextStyle.resolve(states), child: counter);\n      },\n      selectAllOnFocus: widget.selectAllOnFocus,\n      selectionControls: widget.selectionControls,\n      scrollController: widget.scrollController,\n      scrollPhysics: widget.scrollPhysics,\n      autofillHints: widget.autofillHints,\n      restorationId: widget.restorationId,\n      stylusHandwritingEnabled: widget.stylusHandwritingEnabled,\n      enableIMEPersonalizedLearning: widget.enableIMEPersonalizedLearning,\n      contentInsertionConfiguration: widget.contentInsertionConfiguration,\n      contextMenuBuilder: widget.contextMenuBuilder,\n      canRequestFocus: widget.canRequestFocus,\n      spellCheckConfiguration: widget.spellCheckConfiguration,\n      magnifierConfiguration: widget.magnifierConfiguration,\n      groupId: widget.groupId,\n    );\n\n    Widget field = FLabel(\n      axis: Axis.vertical,\n      states: states,\n      label: widget.label,\n      style: style,\n      description: widget.description,\n      // Error should never be null as doing so causes the widget tree to change. This causes overlays attached to\n      // the textfield to fail as it is not smart enough to track the new location of the textfield in the widget tree.\n      error: widget.error ?? const SizedBox(),\n      expands: widget.expands,\n      child: widget.builder(context, style, states, textfield),\n    );\n\n    field = MergeSemantics(\n      child: Material(\n        color: Colors.transparent,\n        child: Theme(\n          // The selection colors are defined in a Theme instead of TextField since TextField does not expose parameters\n          // for overriding selectionHandleColor.\n          data: Theme.of(context).copyWith(\n            visualDensity: VisualDensity.standard,\n            textSelectionTheme: TextSelectionThemeData(\n              cursorColor: style.cursorColor,\n              selectionColor: style.cursorColor.withValues(alpha: 0.4),\n              selectionHandleColor: style.cursorColor,\n            ),\n          ),\n          child: CupertinoTheme(\n            // Theme.cupertinoOverrideTheme cannot be used because of https://github.com/flutter/flutter/issues/161573.\n            data: CupertinoTheme.of(context).copyWith(primaryColor: style.cursorColor),\n            child: field,\n          ),\n        ),\n      ),\n    );\n\n    final materialLocalizations = Localizations.of<MaterialLocalizations>(context, MaterialLocalizations);\n    if (materialLocalizations == null) {\n      field = Localizations(\n        locale: Localizations.maybeLocaleOf(context) ?? const Locale('en', 'US'),\n        delegates: const [\n          GlobalMaterialLocalizations.delegate,\n          GlobalWidgetsLocalizations.delegate,\n          GlobalCupertinoLocalizations.delegate,\n        ],\n        child: field,\n      );\n    }\n\n    return field;\n  }\n\n  InputDecoration _decoration(FTextFieldStyle style) {\n    final localizations = FLocalizations.of(context) ?? FDefaultLocalizations();\n    final textDirection = Directionality.maybeOf(context) ?? TextDirection.ltr;\n    final padding = style.contentPadding.resolve(textDirection);\n    final states = _statesController.value;\n\n    final suffix = widget.suffixBuilder?.call(context, style, states);\n    final clear = widget.clearable(_controller.value)\n        ? Padding(\n            padding: style.clearButtonPadding,\n            child: FButton.icon(\n              style: style.clearButtonStyle,\n              onPress: () => _controller.text = '',\n              child: Icon(FIcons.x, semanticLabel: localizations.textFieldClearButtonSemanticsLabel),\n            ),\n          )\n        : null;\n\n    return InputDecoration(\n      isDense: true,\n      prefixIcon: widget.prefixBuilder?.call(context, style, states),\n      suffixIcon: switch ((suffix, clear)) {\n        (final icon?, final clear?) when !states.contains(WidgetState.disabled) => Row(\n          mainAxisAlignment: MainAxisAlignment.end,\n          mainAxisSize: MainAxisSize.min,\n          children: [clear, icon],\n        ),\n        (null, final clear?) when !states.contains(WidgetState.disabled) => clear,\n        (final icon, _) => icon,\n      },\n      // See https://stackoverflow.com/questions/70771410/flutter-how-can-i-remove-the-content-padding-for-error-in-textformfield\n      prefix: Padding(\n        padding: switch (textDirection) {\n          TextDirection.ltr => EdgeInsets.only(left: widget.prefixBuilder == null ? padding.left : 0),\n          TextDirection.rtl => EdgeInsets.only(right: widget.prefixBuilder == null ? padding.right : 0),\n        },\n      ),\n      prefixIconConstraints: const BoxConstraints(),\n      suffixIconConstraints: const BoxConstraints(),\n      contentPadding: switch (textDirection) {\n        TextDirection.ltr => padding.copyWith(left: 0),\n        TextDirection.rtl => padding.copyWith(right: 0),\n      },\n      hintText: widget.hint,\n      hintStyle: WidgetStateTextStyle.resolveWith(style.hintTextStyle.resolve),\n      fillColor: style.fillColor,\n      filled: style.filled,\n      border: WidgetStateInputBorder.resolveWith(style.border.resolve),\n      // This is done to trigger the error state. We don't pass in error directly since we build our own using FLabel.\n      error: widget.error == null ? null : const SizedBox(),\n    );\n  }\n\n  @override\n  void dispose() {\n    if (widget.statesController == null) {\n      _statesController.dispose();\n    } else {\n      _statesController.removeListener(_handleStatesChange);\n    }\n\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeListener(_handleOnChange);\n    }\n    super.dispose();\n  }\n}\n",
      "text_field_style": "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'text_field_style.design.dart';\n\n/// The text field style.\nclass FTextFieldStyle extends FLabelStyle with _$FTextFieldStyleFunctions {\n  /// The appearance of the keyboard. Defaults to [FColors.brightness].\n  ///\n  /// This setting is only honored on iOS devices.\n  @override\n  final Brightness keyboardAppearance;\n\n  /// The color of the cursor. Defaults to [CupertinoColors.activeBlue].\n  ///\n  /// The cursor indicates the current location of text insertion point in the field.\n  @override\n  final Color cursorColor;\n\n  /// The base fill color of the decoration's container colors.\n  @override\n  final Color? fillColor;\n\n  /// If true the decoration's container is filled with [fillColor]. Defaults to false.\n  @override\n  final bool filled;\n\n  /// The padding surrounding this text field's content.\n  ///\n  /// Defaults to `const EdgeInsets.symmetric(horizontal: 14, vertical: 14)`.\n  @override\n  final EdgeInsetsGeometry contentPadding;\n\n  /// The padding surrounding the clear button. Defaults to `EdgeInsetsDirectional.only(end: 4)`.\n  @override\n  final EdgeInsetsGeometry clearButtonPadding;\n\n  /// The padding surrounding the obscured text toggle. Defaults to `EdgeInsetsDirectional.only(end: 4)`.\n  @override\n  final EdgeInsetsGeometry obscureButtonPadding;\n\n  /// Configures padding to edges surrounding a [Scrollable] when this text field scrolls into view.\n  ///\n  /// Defaults to `EdgeInsets.all(20)`.\n  ///\n  /// When this widget receives focus and is not completely visible (for example scrolled partially off the screen or\n  /// overlapped by the keyboard) then it will attempt to make itself visible by scrolling a surrounding [Scrollable],\n  /// if one is present. This value controls how far from the edges of a [Scrollable] the TextField will be positioned\n  /// after the scroll.\n  @override\n  final EdgeInsets scrollPadding;\n\n  /// The clear button's style when [FTextField.clearable] is true.\n  @override\n  final FButtonStyle clearButtonStyle;\n\n  /// The obscured text toggle's style when enabled in [FTextField.password].\n  @override\n  final FButtonStyle obscureButtonStyle;\n\n  /// The content's [TextStyle].\n  ///\n  /// The supported states are:\n  /// * [WidgetState.disabled]\n  /// * [WidgetState.error]\n  /// * [WidgetState.focused]\n  /// * [WidgetState.hovered]\n  /// * [WidgetState.pressed]\n  @override\n  final FWidgetStateMap<TextStyle> contentTextStyle;\n\n  /// The hint's [TextStyle].\n  ///\n  /// The supported states are:\n  /// * [WidgetState.disabled]\n  /// * [WidgetState.error]\n  /// * [WidgetState.focused]\n  /// * [WidgetState.hovered]\n  /// * [WidgetState.pressed]\n  @override\n  final FWidgetStateMap<TextStyle> hintTextStyle;\n\n  /// The counter's [TextStyle].\n  ///\n  /// The supported states are:\n  /// * [WidgetState.disabled]\n  /// * [WidgetState.error]\n  /// * [WidgetState.focused]\n  /// * [WidgetState.hovered]\n  /// * [WidgetState.pressed]\n  @override\n  final FWidgetStateMap<TextStyle> counterTextStyle;\n\n  /// The border.\n  ///\n  /// The supported states are:\n  /// * [WidgetState.disabled]\n  /// * [WidgetState.error]\n  /// * [WidgetState.focused]\n  /// * [WidgetState.hovered]\n  /// * [WidgetState.pressed]\n  @override\n  final FWidgetStateMap<InputBorder> border;\n\n  /// Creates a [FTextFieldStyle].\n  FTextFieldStyle({\n    required this.keyboardAppearance,\n    required this.clearButtonStyle,\n    required this.obscureButtonStyle,\n    required this.contentTextStyle,\n    required this.hintTextStyle,\n    required this.counterTextStyle,\n    required this.border,\n    required super.labelTextStyle,\n    required super.descriptionTextStyle,\n    required super.errorTextStyle,\n    this.cursorColor = CupertinoColors.activeBlue,\n    this.fillColor,\n    this.filled = false,\n    this.contentPadding = const EdgeInsets.symmetric(horizontal: 10, vertical: 10),\n    this.clearButtonPadding = const EdgeInsetsDirectional.only(end: 4),\n    this.obscureButtonPadding = const EdgeInsetsDirectional.only(end: 4),\n    this.scrollPadding = const EdgeInsets.all(20),\n    super.labelPadding,\n    super.descriptionPadding,\n    super.errorPadding,\n    super.childPadding,\n  });\n\n  /// Creates a [FTextFieldStyle] that inherits its properties.\n  factory FTextFieldStyle.inherit({required FColors colors, required FTypography typography, required FStyle style}) {\n    final label = FLabelStyles.inherit(style: style).verticalStyle;\n    final ghost = FButtonStyles.inherit(colors: colors, typography: typography, style: style).ghost;\n    final textStyle = typography.sm.copyWith(fontFamily: typography.defaultFontFamily);\n    final buttonStyle = ghost.copyWith(\n      iconContentStyle: ghost.iconContentStyle.copyWith(\n        iconStyle: FWidgetStateMap({\n          WidgetState.disabled: IconThemeData(color: colors.disable(colors.mutedForeground), size: 17),\n          WidgetState.any: IconThemeData(color: colors.mutedForeground, size: 17),\n        }),\n      ),\n    );\n\n    return FTextFieldStyle(\n      keyboardAppearance: colors.brightness,\n      clearButtonStyle: buttonStyle,\n      obscureButtonStyle: buttonStyle,\n      contentTextStyle: FWidgetStateMap({\n        WidgetState.disabled: textStyle.copyWith(color: colors.disable(colors.primary)),\n        WidgetState.any: textStyle.copyWith(color: colors.primary),\n      }),\n      hintTextStyle: FWidgetStateMap({\n        WidgetState.disabled: textStyle.copyWith(color: colors.disable(colors.border)),\n        WidgetState.any: textStyle.copyWith(color: colors.mutedForeground),\n      }),\n      counterTextStyle: FWidgetStateMap({\n        WidgetState.disabled: textStyle.copyWith(color: colors.disable(colors.primary)),\n        WidgetState.any: textStyle.copyWith(color: colors.primary),\n      }),\n      border: FWidgetStateMap({\n        WidgetState.error: OutlineInputBorder(\n          borderSide: BorderSide(color: colors.error, width: style.borderWidth),\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.disabled: OutlineInputBorder(\n          borderSide: BorderSide(color: colors.disable(colors.border), width: style.borderWidth),\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.focused: OutlineInputBorder(\n          borderSide: BorderSide(color: colors.primary, width: style.borderWidth),\n          borderRadius: style.borderRadius,\n        ),\n        WidgetState.any: OutlineInputBorder(\n          borderSide: BorderSide(color: colors.border, width: style.borderWidth),\n          borderRadius: style.borderRadius,\n        ),\n      }),\n      labelTextStyle: style.formFieldStyle.labelTextStyle,\n      descriptionTextStyle: style.formFieldStyle.descriptionTextStyle,\n      errorTextStyle: style.formFieldStyle.errorTextStyle,\n      labelPadding: label.labelPadding,\n      descriptionPadding: label.descriptionPadding,\n      errorPadding: label.errorPadding,\n      childPadding: label.childPadding,\n    );\n  }\n}\n",
      "text_form_field": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/localizations/localized_text.dart';\nimport 'package:forui/src/widgets/text_field/field.dart';\nimport 'package:forui/src/widgets/text_field/password_field.dart';\nimport 'package:forui/src/widgets/text_field/password_form_field.dart';\nimport 'package:forui/src/widgets/text_field/text_field.dart';\n\n/// A text field that is wrapped is a [FormField] for convenience.\n///\n/// It lets the user enter text, either with a hardware keyboard or with an onscreen keyboard.\n///\n/// See:\n/// * https://forui.dev/docs/form/text-form-field for working examples.\n/// * [FTextFieldStyle] for customizing a text field's appearance.\n/// * [FTextField] for creating a text field that can be used in a form.\n/// * [TextField] for more details about working with a text field.\nclass FTextFormField extends StatelessWidget with FFormFieldProperties<String> {\n  /// Creates a [FTextFormField] configured for password entry with a visibility toggle.\n  ///\n  /// By default, [suffixBuilder] is an eye icon that toggles showing and hiding the password. Replace the toggle by\n  /// providing a custom [suffixBuilder], or disable it by setting it to `null`.\n  ///\n  /// The [obscureTextController] parameter is a [ValueNotifier] that controls the obscuring state.\n  ///\n  /// [autofillHints] defaults to [AutofillHints.password]. Use [AutofillHints.newPassword] for new-password inputs.\n  static Widget password({\n    FTextFieldStyle Function(FTextFieldStyle style)? style,\n    FFieldBuilder<FTextFieldStyle> builder = Defaults.builder,\n    Widget? label = const LocalizedText.password(),\n    String? hint,\n    Widget? description,\n    Widget? error,\n    TextMagnifierConfiguration? magnifierConfiguration,\n    Object groupId = EditableText,\n    TextEditingController? controller,\n    FocusNode? focusNode,\n    TextInputType? keyboardType,\n    TextInputAction textInputAction = TextInputAction.next,\n    TextCapitalization textCapitalization = TextCapitalization.none,\n    TextAlign textAlign = TextAlign.start,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    bool autofocus = false,\n    WidgetStatesController? statesController,\n    String obscuringCharacter = '\u2022',\n    bool autocorrect = false,\n    SmartDashesType? smartDashesType,\n    SmartQuotesType? smartQuotesType,\n    bool enableSuggestions = false,\n    int? minLines,\n    int maxLines = 1,\n    bool expands = false,\n    bool readOnly = false,\n    bool? showCursor,\n    int? maxLength,\n    MaxLengthEnforcement? maxLengthEnforcement,\n    ValueChanged<String>? onChange,\n    GestureTapCallback? onTap,\n    TapRegionCallback? onTapOutside,\n    bool onTapAlwaysCalled = false,\n    VoidCallback? onEditingComplete,\n    ValueChanged<String>? onSubmit,\n    AppPrivateCommandCallback? onAppPrivateCommand,\n    List<TextInputFormatter>? inputFormatters,\n    bool enabled = true,\n    bool? ignorePointers,\n    bool enableInteractiveSelection = true,\n    bool? selectAllOnFocus,\n    TextSelectionControls? selectionControls,\n    DragStartBehavior dragStartBehavior = DragStartBehavior.start,\n    MouseCursor? mouseCursor,\n    FTextFieldCounterBuilder? counterBuilder,\n    ScrollPhysics? scrollPhysics,\n    ScrollController? scrollController,\n    Iterable<String> autofillHints = const [AutofillHints.password],\n    String? restorationId,\n    bool stylusHandwritingEnabled = true,\n    bool enableIMEPersonalizedLearning = true,\n    ContentInsertionConfiguration? contentInsertionConfiguration,\n    EditableTextContextMenuBuilder contextMenuBuilder = Defaults.contextMenuBuilder,\n    bool canRequestFocus = true,\n    UndoHistoryController? undoController,\n    SpellCheckConfiguration? spellCheckConfiguration,\n    FPasswordFieldIconBuilder<FTextFieldStyle>? prefixBuilder,\n    FPasswordFieldIconBuilder<FTextFieldStyle>? suffixBuilder = PasswordField.defaultToggleBuilder,\n    bool Function(TextEditingValue) clearable = Defaults.clearable,\n    ValueNotifier<bool>? obscureTextController,\n    FormFieldSetter<String>? onSaved,\n    VoidCallback? onReset,\n    FormFieldValidator<String>? validator,\n    String? initialText,\n    AutovalidateMode autovalidateMode = AutovalidateMode.disabled,\n    String? forceErrorText,\n    Widget Function(BuildContext context, String message) errorBuilder = _errorBuilder,\n    Key? key,\n  }) => PasswordFormField(\n    properties: PasswordFieldProperties(\n      style: style,\n      builder: builder,\n      label: label,\n      hint: hint,\n      description: description,\n      error: null,\n      magnifierConfiguration: magnifierConfiguration,\n      groupId: groupId,\n      controller: controller,\n      focusNode: focusNode,\n      keyboardType: keyboardType,\n      textInputAction: textInputAction,\n      textCapitalization: textCapitalization,\n      textAlign: textAlign,\n      textAlignVertical: textAlignVertical,\n      textDirection: textDirection,\n      autofocus: autofocus,\n      statesController: statesController,\n      obscuringCharacter: obscuringCharacter,\n      autocorrect: autocorrect,\n      smartDashesType: smartDashesType,\n      smartQuotesType: smartQuotesType,\n      enableSuggestions: enableSuggestions,\n      minLines: minLines,\n      maxLines: maxLines,\n      expands: expands,\n      readOnly: readOnly,\n      showCursor: showCursor,\n      maxLength: maxLength,\n      maxLengthEnforcement: maxLengthEnforcement,\n      onChange: onChange,\n      onTap: onTap,\n      onTapOutside: onTapOutside,\n      onTapAlwaysCalled: onTapAlwaysCalled,\n      onEditingComplete: onEditingComplete,\n      onSubmit: onSubmit,\n      onAppPrivateCommand: onAppPrivateCommand,\n      inputFormatters: inputFormatters,\n      enabled: enabled,\n      ignorePointers: ignorePointers,\n      enableInteractiveSelection: enableInteractiveSelection,\n      selectAllOnFocus: selectAllOnFocus,\n      selectionControls: selectionControls,\n      dragStartBehavior: dragStartBehavior,\n      mouseCursor: mouseCursor,\n      counterBuilder: counterBuilder,\n      scrollPhysics: scrollPhysics,\n      scrollController: scrollController,\n      autofillHints: autofillHints,\n      restorationId: restorationId,\n      stylusHandwritingEnabled: stylusHandwritingEnabled,\n      enableIMEPersonalizedLearning: enableIMEPersonalizedLearning,\n      contentInsertionConfiguration: contentInsertionConfiguration,\n      contextMenuBuilder: contextMenuBuilder,\n      canRequestFocus: canRequestFocus,\n      undoController: undoController,\n      spellCheckConfiguration: spellCheckConfiguration,\n      prefixBuilder: prefixBuilder,\n      suffixBuilder: suffixBuilder,\n      clearable: clearable,\n      initialText: initialText,\n      obscureTextController: obscureTextController,\n    ),\n    onSaved: onSaved,\n    onReset: onReset,\n    validator: validator,\n    autovalidateMode: autovalidateMode,\n    forceErrorText: forceErrorText,\n    errorBuilder: errorBuilder,\n    key: key,\n  );\n\n  static Widget _errorBuilder(BuildContext _, String text) => Text(text);\n\n  /// {@macro forui.text_field.style}\n  final FTextFieldStyle Function(FTextFieldStyle style)? style;\n\n  /// {@macro forui.text_field.builder}\n  final Widget Function(BuildContext context, FTextFieldStyle style, Set<WidgetState> states, Widget field) builder;\n\n  /// {@macro forui.text_field.label}\n  @override\n  final Widget? label;\n\n  /// {@macro forui.text_field.hint}\n  final String? hint;\n\n  /// {@macro forui.text_field.description}\n  @override\n  final Widget? description;\n\n  /// {@macro forui.text_field.magnifier_configuration}\n  final TextMagnifierConfiguration? magnifierConfiguration;\n\n  /// {@macro forui.text_field_groupId}\n  final Object groupId;\n\n  /// {@macro forui.text_field.controller}\n  final TextEditingController? controller;\n\n  /// {@macro forui.text_field.keyboardType}\n  final TextInputType? keyboardType;\n\n  /// {@macro forui.text_field.textInputAction}\n  final TextInputAction? textInputAction;\n\n  /// {@macro forui.text_field.textCapitalization}\n  final TextCapitalization textCapitalization;\n\n  /// {@macro forui.text_field.textAlign}\n  final TextAlign textAlign;\n\n  /// {@macro forui.text_field.textAlignVertical}\n  final TextAlignVertical? textAlignVertical;\n\n  /// {@macro forui.text_field.textDirection}\n  final TextDirection? textDirection;\n\n  /// {@macro forui.text_field.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.text_field.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.text_field.statesController}\n  final WidgetStatesController? statesController;\n\n  /// {@macro forui.text_field.obscuringCharacter}\n  final String obscuringCharacter;\n\n  /// {@macro forui.text_field.obscureText}\n  final bool obscureText;\n\n  /// {@macro forui.text_field.autocorrect}\n  final bool autocorrect;\n\n  /// {@macro forui.text_field.smartDashesType}\n  final SmartDashesType? smartDashesType;\n\n  /// {@macro forui.text_field.smartQuotesType}\n  final SmartQuotesType? smartQuotesType;\n\n  /// {@macro forui.text_field.enableSuggestions}\n  final bool enableSuggestions;\n\n  /// {@macro forui.text_field.minLines}\n  final int? minLines;\n\n  /// {@macro forui.text_field.maxLines}\n  final int? maxLines;\n\n  /// {@macro forui.text_field.expands}\n  final bool expands;\n\n  /// {@macro forui.text_field.readOnly}\n  final bool readOnly;\n\n  /// {@macro forui.text_field.showCursor}\n  final bool? showCursor;\n\n  /// {@macro forui.text_field.maxLength}\n  final int? maxLength;\n\n  /// {@macro forui.text_field.maxLengthEnforcement}\n  final MaxLengthEnforcement? maxLengthEnforcement;\n\n  /// {@macro forui.text_field.onChange}\n  final ValueChanged<String>? onChange;\n\n  /// {@macro forui.text_field.onTap}\n  final GestureTapCallback? onTap;\n\n  /// {@macro forui.text_field.onTapAlwaysCalled}\n  final TapRegionCallback? onTapOutside;\n\n  /// {@macro forui.text_field.onTap}\n  final bool onTapAlwaysCalled;\n\n  /// {@macro forui.text_field.onEditingComplete}\n  final VoidCallback? onEditingComplete;\n\n  /// {@macro forui.text_field.onSubmit}\n  final ValueChanged<String>? onSubmit;\n\n  /// {@macro forui.text_field.onAppPrivateCommand}\n  final AppPrivateCommandCallback? onAppPrivateCommand;\n\n  /// {@macro forui.text_field.inputFormatters}\n  final List<TextInputFormatter>? inputFormatters;\n\n  /// {@macro forui.text_field.enabled}\n  @override\n  final bool enabled;\n\n  /// {@macro forui.text_field.ignorePointers}\n  final bool? ignorePointers;\n\n  /// {@macro forui.text_field.enableInteractiveSelection}\n  final bool enableInteractiveSelection;\n\n  /// {@macro forui.text_field.selectAllOnFocus}\n  final bool? selectAllOnFocus;\n\n  /// {@macro forui.text_field.selectionControls}\n  final TextSelectionControls? selectionControls;\n\n  /// {@macro forui.text_field.dragStartBehavior}\n  final DragStartBehavior dragStartBehavior;\n\n  /// {@macro forui.text_field.mouseCursor}\n  final MouseCursor? mouseCursor;\n\n  /// {@macro forui.text_field.counterBuilder}\n  final FTextFieldCounterBuilder? counterBuilder;\n\n  /// {@macro forui.text_field.scrollPhysics}\n  final ScrollPhysics? scrollPhysics;\n\n  /// {@macro forui.text_field.scrollController}\n  final ScrollController? scrollController;\n\n  /// {@macro forui.text_field.autofillHints}\n  final Iterable<String>? autofillHints;\n\n  /// {@macro forui.text_field.restorationId}\n  final String? restorationId;\n\n  /// {@macro forui.text_field.stylusHandwritingEnabled}\n  final bool stylusHandwritingEnabled;\n\n  /// {@macro forui.text_field.enableIMEPersonalizedLearning}\n  final bool enableIMEPersonalizedLearning;\n\n  /// {@macro forui.text_field.contentInsertionConfiguration}\n  final ContentInsertionConfiguration? contentInsertionConfiguration;\n\n  /// {@macro forui.text_field.contextMenuBuilder}\n  final EditableTextContextMenuBuilder? contextMenuBuilder;\n\n  /// {@macro forui.text_field.canRequestFocus}\n  final bool canRequestFocus;\n\n  /// {@macro forui.text_field.undoController}\n  final UndoHistoryController? undoController;\n\n  /// {@macro forui.text_field.spellCheckConfiguration}\n  final SpellCheckConfiguration? spellCheckConfiguration;\n\n  /// {@macro forui.text_field.prefixBuilder}\n  final Widget Function(BuildContext context, FTextFieldStyle style, Set<WidgetState> states)? prefixBuilder;\n\n  /// {@macro forui.text_field.suffixBuilder}\n  final Widget Function(BuildContext context, FTextFieldStyle style, Set<WidgetState> states)? suffixBuilder;\n\n  /// {@macro forui.text_field.clearable}\n  final bool Function(TextEditingValue) clearable;\n\n  @override\n  final FormFieldSetter<String>? onSaved;\n\n  @override\n  final VoidCallback? onReset;\n\n  @override\n  final FormFieldValidator<String>? validator;\n\n  /// {@macro forui.text_field.initialValue}\n  final String? initialText;\n\n  @override\n  final AutovalidateMode autovalidateMode;\n\n  @override\n  final String? forceErrorText;\n\n  @override\n  final Widget Function(BuildContext context, String message) errorBuilder;\n\n  /// Creates a [FTextFormField].\n  const FTextFormField({\n    this.style,\n    this.builder = Defaults.builder,\n    this.label,\n    this.hint,\n    this.description,\n    this.magnifierConfiguration,\n    this.groupId = EditableText,\n    this.controller,\n    this.focusNode,\n    this.keyboardType,\n    this.textInputAction,\n    this.textCapitalization = TextCapitalization.none,\n    this.textAlign = TextAlign.start,\n    this.textAlignVertical,\n    this.textDirection,\n    this.autofocus = false,\n    this.statesController,\n    this.obscuringCharacter = '\u2022',\n    this.obscureText = false,\n    this.autocorrect = true,\n    this.smartDashesType,\n    this.smartQuotesType,\n    this.enableSuggestions = true,\n    this.minLines,\n    this.maxLines = 1,\n    this.expands = false,\n    this.readOnly = false,\n    this.showCursor,\n    this.maxLength,\n    this.maxLengthEnforcement,\n    this.onChange,\n    this.onTap,\n    this.onTapOutside,\n    this.onTapAlwaysCalled = false,\n    this.onEditingComplete,\n    this.onSubmit,\n    this.onAppPrivateCommand,\n    this.inputFormatters,\n    this.enabled = true,\n    this.ignorePointers,\n    this.enableInteractiveSelection = true,\n    this.selectAllOnFocus,\n    this.selectionControls,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.mouseCursor,\n    this.counterBuilder,\n    this.scrollPhysics,\n    this.scrollController,\n    this.autofillHints,\n    this.restorationId,\n    this.stylusHandwritingEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contentInsertionConfiguration,\n    this.contextMenuBuilder = Defaults.contextMenuBuilder,\n    this.canRequestFocus = true,\n    this.undoController,\n    this.spellCheckConfiguration,\n    this.prefixBuilder,\n    this.suffixBuilder,\n    this.clearable = Defaults.clearable,\n    this.onSaved,\n    this.onReset,\n    this.validator,\n    this.initialText,\n    this.autovalidateMode = AutovalidateMode.disabled,\n    this.forceErrorText,\n    this.errorBuilder = _errorBuilder,\n    super.key,\n  });\n\n  /// Creates a [FTextFormField] configured for emails.\n  const FTextFormField.email({\n    this.style,\n    this.builder = Defaults.builder,\n    this.label = const LocalizedText.email(),\n    this.hint,\n    this.description,\n    this.magnifierConfiguration,\n    this.groupId = EditableText,\n    this.controller,\n    this.focusNode,\n    this.keyboardType = TextInputType.emailAddress,\n    this.textInputAction = TextInputAction.next,\n    this.textCapitalization = TextCapitalization.none,\n    this.textAlign = TextAlign.start,\n    this.textAlignVertical,\n    this.textDirection,\n    this.autofocus = false,\n    this.statesController,\n    this.obscuringCharacter = '\u2022',\n    this.obscureText = false,\n    this.autocorrect = false,\n    this.smartDashesType,\n    this.smartQuotesType,\n    this.enableSuggestions = true,\n    this.minLines,\n    this.maxLines = 1,\n    this.expands = false,\n    this.readOnly = false,\n    this.showCursor,\n    this.maxLength,\n    this.maxLengthEnforcement,\n    this.onChange,\n    this.onTap,\n    this.onTapOutside,\n    this.onTapAlwaysCalled = false,\n    this.onEditingComplete,\n    this.onSubmit,\n    this.onAppPrivateCommand,\n    this.inputFormatters,\n    this.enabled = true,\n    this.ignorePointers,\n    this.enableInteractiveSelection = true,\n    this.selectAllOnFocus,\n    this.selectionControls,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.mouseCursor,\n    this.counterBuilder,\n    this.scrollPhysics,\n    this.scrollController,\n    this.autofillHints = const [AutofillHints.email],\n    this.restorationId,\n    this.stylusHandwritingEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contentInsertionConfiguration,\n    this.contextMenuBuilder = Defaults.contextMenuBuilder,\n    this.canRequestFocus = true,\n    this.undoController,\n    this.spellCheckConfiguration,\n    this.prefixBuilder,\n    this.suffixBuilder,\n    this.clearable = Defaults.clearable,\n    this.onSaved,\n    this.onReset,\n    this.validator,\n    this.initialText,\n    this.autovalidateMode = AutovalidateMode.disabled,\n    this.forceErrorText,\n    this.errorBuilder = _errorBuilder,\n    super.key,\n  });\n\n  /// Creates a [FTextFormField] configured for multiline inputs.\n  ///\n  /// The text field's height can be configured by adjusting [minLines]. By default, the text field will expand every\n  /// time a new line is added. To limit the maximum height of the text field and make it scrollable, consider setting\n  /// [maxLines].\n  const FTextFormField.multiline({\n    this.style,\n    this.builder = Defaults.builder,\n    this.label,\n    this.hint,\n    this.description,\n    this.magnifierConfiguration,\n    this.groupId = EditableText,\n    this.controller,\n    this.focusNode,\n    this.keyboardType,\n    this.textInputAction,\n    this.textCapitalization = TextCapitalization.sentences,\n    this.textAlign = TextAlign.start,\n    this.textAlignVertical,\n    this.textDirection,\n    this.autofocus = false,\n    this.statesController,\n    this.obscuringCharacter = '\u2022',\n    this.obscureText = false,\n    this.autocorrect = true,\n    this.smartDashesType,\n    this.smartQuotesType,\n    this.enableSuggestions = true,\n    this.minLines = 4,\n    this.maxLines,\n    this.expands = false,\n    this.readOnly = false,\n    this.showCursor,\n    this.maxLength,\n    this.maxLengthEnforcement,\n    this.onChange,\n    this.onTap,\n    this.onTapOutside,\n    this.onTapAlwaysCalled = false,\n    this.onEditingComplete,\n    this.onSubmit,\n    this.onAppPrivateCommand,\n    this.inputFormatters,\n    this.enabled = true,\n    this.ignorePointers,\n    this.enableInteractiveSelection = true,\n    this.selectAllOnFocus,\n    this.selectionControls,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.mouseCursor,\n    this.counterBuilder,\n    this.scrollPhysics,\n    this.scrollController,\n    this.autofillHints,\n    this.restorationId,\n    this.stylusHandwritingEnabled = true,\n    this.enableIMEPersonalizedLearning = true,\n    this.contentInsertionConfiguration,\n    this.contextMenuBuilder = Defaults.contextMenuBuilder,\n    this.canRequestFocus = true,\n    this.undoController,\n    this.spellCheckConfiguration,\n    this.prefixBuilder,\n    this.suffixBuilder,\n    this.clearable = Defaults.clearable,\n    this.onSaved,\n    this.onReset,\n    this.validator,\n    this.initialText,\n    this.autovalidateMode = AutovalidateMode.disabled,\n    this.forceErrorText,\n    this.errorBuilder = _errorBuilder,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) => Field(\n    controller: controller,\n    onSaved: onSaved,\n    onReset: onReset,\n    validator: validator,\n    initialValue: controller?.text ?? initialText,\n    enabled: enabled,\n    autovalidateMode: autovalidateMode,\n    forceErrorText: forceErrorText,\n    restorationId: restorationId,\n    builder: (state) => FTextField(\n      style: style,\n      builder: builder,\n      label: label,\n      hint: hint,\n      description: description,\n      error: switch (state.errorText) {\n        null => null,\n        final error => errorBuilder(state.context, error),\n      },\n      magnifierConfiguration: magnifierConfiguration,\n      groupId: groupId,\n      controller: state.effectiveController,\n      focusNode: focusNode,\n      keyboardType: keyboardType,\n      textInputAction: textInputAction,\n      textCapitalization: textCapitalization,\n      textAlign: textAlign,\n      textAlignVertical: textAlignVertical,\n      textDirection: textDirection,\n      autofocus: autofocus,\n      statesController: statesController,\n      obscuringCharacter: obscuringCharacter,\n      obscureText: obscureText,\n      autocorrect: autocorrect,\n      smartDashesType: smartDashesType,\n      smartQuotesType: smartQuotesType,\n      enableSuggestions: enableSuggestions,\n      minLines: minLines,\n      maxLines: maxLines,\n      expands: expands,\n      readOnly: readOnly,\n      showCursor: showCursor,\n      maxLength: maxLength,\n      maxLengthEnforcement: maxLengthEnforcement,\n      onChange: (value) {\n        state.didChange(value);\n        onChange?.call(value);\n      },\n      onTap: onTap,\n      onTapAlwaysCalled: onTapAlwaysCalled,\n      onEditingComplete: onEditingComplete,\n      onSubmit: onSubmit,\n      onAppPrivateCommand: onAppPrivateCommand,\n      inputFormatters: inputFormatters,\n      enabled: enabled,\n      ignorePointers: ignorePointers,\n      enableInteractiveSelection: enableInteractiveSelection,\n      selectionControls: selectionControls,\n      selectAllOnFocus: selectAllOnFocus,\n      dragStartBehavior: dragStartBehavior,\n      mouseCursor: mouseCursor,\n      counterBuilder: counterBuilder,\n      scrollPhysics: scrollPhysics,\n      scrollController: scrollController,\n      autofillHints: autofillHints,\n      restorationId: restorationId,\n      stylusHandwritingEnabled: stylusHandwritingEnabled,\n      enableIMEPersonalizedLearning: enableIMEPersonalizedLearning,\n      contentInsertionConfiguration: contentInsertionConfiguration,\n      contextMenuBuilder: contextMenuBuilder,\n      canRequestFocus: canRequestFocus,\n      undoController: undoController,\n      spellCheckConfiguration: spellCheckConfiguration,\n      prefixBuilder: prefixBuilder,\n      suffixBuilder: suffixBuilder,\n      clearable: clearable,\n      key: key,\n    ),\n  );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(StringProperty('hint', hint))\n      ..add(DiagnosticsProperty('magnifierConfiguration', magnifierConfiguration))\n      ..add(DiagnosticsProperty('groupId', groupId))\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(DiagnosticsProperty('keyboardType', keyboardType))\n      ..add(EnumProperty('textInputAction', textInputAction))\n      ..add(EnumProperty('textCapitalization', textCapitalization))\n      ..add(EnumProperty('textAlign', textAlign))\n      ..add(DiagnosticsProperty('textAlignVertical', textAlignVertical))\n      ..add(EnumProperty('textDirection', textDirection))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('statesController', statesController))\n      ..add(StringProperty('obscuringCharacter', obscuringCharacter, defaultValue: '\u2022'))\n      ..add(FlagProperty('obscureText', value: obscureText, ifTrue: 'obscureText'))\n      ..add(FlagProperty('autocorrect', value: autocorrect, ifTrue: 'autocorrect'))\n      ..add(EnumProperty('smartDashesType', smartDashesType))\n      ..add(EnumProperty('smartQuotesType', smartQuotesType))\n      ..add(FlagProperty('enableSuggestions', value: enableSuggestions, ifTrue: 'enableSuggestions'))\n      ..add(IntProperty('minLines', minLines))\n      ..add(IntProperty('maxLines', maxLines))\n      ..add(FlagProperty('expands', value: expands, ifTrue: 'expands'))\n      ..add(FlagProperty('readOnly', value: readOnly, ifTrue: 'readOnly'))\n      ..add(FlagProperty('showCursor', value: showCursor, ifTrue: 'showCursor'))\n      ..add(IntProperty('maxLength', maxLength))\n      ..add(EnumProperty('maxLengthEnforcement', maxLengthEnforcement))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onTap', onTap))\n      ..add(ObjectFlagProperty.has('onTapOutside', onTapOutside))\n      ..add(FlagProperty('onTapAlwaysCalled', value: onTapAlwaysCalled, ifTrue: 'onTapAlwaysCalled'))\n      ..add(ObjectFlagProperty.has('onEditingComplete', onEditingComplete))\n      ..add(ObjectFlagProperty.has('onSubmit', onSubmit))\n      ..add(ObjectFlagProperty.has('onAppPrivateCommand', onAppPrivateCommand))\n      ..add(IterableProperty('inputFormatters', inputFormatters))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(FlagProperty('ignorePointers', value: ignorePointers, ifTrue: 'ignorePointers'))\n      ..add(\n        FlagProperty('enableInteractSelection', value: enableInteractiveSelection, ifTrue: 'enableInteractSelection'),\n      )\n      ..add(FlagProperty('selectAllOnFocus', value: selectAllOnFocus, ifTrue: 'selectAllOnFocus'))\n      ..add(DiagnosticsProperty('selectionControls', selectionControls))\n      ..add(EnumProperty('dragStartBehavior', dragStartBehavior))\n      ..add(DiagnosticsProperty('mouseCursor', mouseCursor))\n      ..add(ObjectFlagProperty.has('buildCounter', counterBuilder))\n      ..add(DiagnosticsProperty('scrollPhysics', scrollPhysics))\n      ..add(DiagnosticsProperty('scrollController', scrollController))\n      ..add(IterableProperty('autofillHints', autofillHints))\n      ..add(StringProperty('restorationId', restorationId))\n      ..add(\n        FlagProperty('stylusHandwritingEnabled', value: stylusHandwritingEnabled, ifTrue: 'stylusHandwritingEnabled'),\n      )\n      ..add(\n        FlagProperty(\n          'enableIMEPersonalizedLearning',\n          value: enableIMEPersonalizedLearning,\n          ifTrue: 'enableIMEPersonalizedLearning',\n        ),\n      )\n      ..add(DiagnosticsProperty('contentInsertionConfiguration', contentInsertionConfiguration))\n      ..add(ObjectFlagProperty.has('contextMenuBuilder', contextMenuBuilder))\n      ..add(FlagProperty('canRequestFocus', value: canRequestFocus, ifTrue: 'canRequestFocus'))\n      ..add(DiagnosticsProperty('undoController', undoController))\n      ..add(DiagnosticsProperty('spellCheckConfiguration', spellCheckConfiguration))\n      ..add(ObjectFlagProperty.has('prefixBuilder', prefixBuilder))\n      ..add(ObjectFlagProperty.has('suffixBuilder', suffixBuilder))\n      ..add(ObjectFlagProperty.has('clearable', clearable))\n      ..add(ObjectFlagProperty.has('onSaved', onSaved))\n      ..add(ObjectFlagProperty.has('validator', validator))\n      ..add(StringProperty('initialText', initialText))\n      ..add(EnumProperty('autovalidateMode', autovalidateMode))\n      ..add(StringProperty('forceErrorText', forceErrorText))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder));\n  }\n}\n"
    },
    "Tile": {
      "tile": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'tile.design.dart';\n\n/// A marker interface which denotes that mixed-in widgets can be used in a [FTileGroup].\nmixin FTileMixin on Widget {}\n\n/// A specialized [FItem] for touch devices.\n///\n/// Multiple tiles can be grouped together in a [FTileGroup]. Tiles grouped together will be separated by a divider,\n/// specified by a [FItemDivider].\n///\n/// ## Using [FTile] in a [FPopover] when wrapped in a [FTileGroup]\n/// When a [FPopover] is used inside an [FTileGroup], tiles & groups inside the popover will inherit styling from the\n/// parent group. This happens because [FPopover]'s content shares the same `BuildContext` as its child, causing data\n/// inheritance that may lead to unexpected rendering issues.\n///\n/// To prevent this styling inheritance, wrap the popover in a [FInheritedItemData] with null data to reset the\n/// inherited data:\n/// ```dart\n/// FTileGroup(\n///   children: [\n///     FTile(title: Text('Tile with popover')),\n///     FPopoverWrapperTile(\n///       popoverBuilder: (_, _) => FInheritedItemData(\n///         child: FTileGroup(\n///           children: [\n///             FTile(title: Text('Popover Tile 1')),\n///             FTile(title: Text('Popover Tile 2')),\n///           ],\n///         ),\n///       ),\n///       child: FButton(child: Text('Open Popover')),\n///     ),\n///   ],\n/// );\n/// ```\n///\n///\n/// See:\n/// * https://forui.dev/docs/tile/tile for working examples.\n/// * [FItem] for a more generic item that can be used in any context.\n/// * [FTileGroup] for grouping tiles together.\n/// * [FTileStyle] for customizing a tile's appearance.\nclass FTile extends StatelessWidget with FTileMixin {\n  // The fields aren't strictly needed, but we keep them to improve documentation.\n\n  /// The tile's style. Defaults to the ancestor tile group's style if present.\n  ///\n  /// Provide a style to prevent inheritance from the ancestor tile group.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create tile\n  /// ```\n  final FItemStyle Function(FItemStyle style)? style;\n\n  /// Whether the tile is enabled. Defaults to true.\n  final bool? enabled;\n\n  /// True if this tile is currently selected. Defaults to false.\n  final bool selected;\n\n  /// {@macro forui.foundation.doc_templates.semanticsLabel}\n  final String? semanticsLabel;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro forui.foundation.doc_templates.onFocusChange}\n  final ValueChanged<bool>? onFocusChange;\n\n  /// {@macro forui.foundation.FTappable.onHoverChange}\n  final ValueChanged<bool>? onHoverChange;\n\n  /// {@macro forui.foundation.FTappable.onStateChange}\n  final ValueChanged<FWidgetStatesDelta>? onStateChange;\n\n  /// {@macro forui.foundation.FTappable.shortcuts}\n  final Map<ShortcutActivator, Intent>? shortcuts;\n\n  /// {@macro forui.foundation.FTappable.actions}\n  final Map<Type, Action<Intent>>? actions;\n\n  /// A callback for when the tile is pressed.\n  ///\n  /// The tile is not hoverable if both [onPress] and [onLongPress] are null.\n  final VoidCallback? onPress;\n\n  /// A callback for when the tile is long pressed.\n  ///\n  /// The tile is not hoverable if both [onPress] and [onLongPress] are null.\n  final VoidCallback? onLongPress;\n\n  /// A callback for when the widget is pressed with a secondary button (usually right-click on desktop).\n  ///\n  /// The item is not interactable if the following are all null:\n  /// * [onPress]\n  /// * [onLongPress]\n  /// * [onSecondaryPress]\n  /// * [onSecondaryLongPress]\n  final VoidCallback? onSecondaryPress;\n\n  /// A callback for when the widget is pressed with a secondary button (usually right-click on desktop).\n  ///\n  /// The item is not interactable if the following are all null:\n  /// * [onPress]\n  /// * [onLongPress]\n  /// * [onSecondaryPress]\n  /// * [onSecondaryLongPress]\n  final VoidCallback? onSecondaryLongPress;\n\n  final Widget _child;\n\n  /// Creates a [FTile].\n  ///\n  /// Assuming LTR locale:\n  /// ```diagram\n  /// -----------------------------------------------------\n  /// | [prefix] [title]       [details] [suffix]         |\n  /// |          [subtitle]                               |\n  /// -----------------------------------------------------\n  /// ```\n  ///\n  /// The order is reversed for RTL locales.\n  ///\n  /// ## Overflow behavior\n  /// [FTile] has custom layout behavior to handle overflow of its content. If [details] is text, it is truncated,\n  /// else [title] and [subtitle] are truncated.\n  ///\n  /// ## Why isn't my [title] [subtitle], or [details] rendered?\n  /// Using widgets that try to fill the available space, such as [Expanded] or [FTextField], as [details] will cause\n  /// the [title] and [subtitle] to never be rendered.\n  ///\n  /// Use [FTile.raw] in these cases.\n  FTile({\n    required Widget title,\n    this.style,\n    this.enabled,\n    this.selected = false,\n    this.semanticsLabel,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.onPress,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.shortcuts,\n    this.actions,\n    Widget? prefix,\n    Widget? subtitle,\n    Widget? details,\n    Widget? suffix,\n    super.key,\n  }) : _child = FItem(\n         title: title,\n         style: style,\n         enabled: enabled,\n         selected: selected,\n         semanticsLabel: semanticsLabel,\n         autofocus: autofocus,\n         focusNode: focusNode,\n         onFocusChange: onFocusChange,\n         onHoverChange: onHoverChange,\n         onStateChange: onStateChange,\n         onPress: onPress,\n         onLongPress: onLongPress,\n         onSecondaryPress: onSecondaryPress,\n         onSecondaryLongPress: onSecondaryLongPress,\n         shortcuts: shortcuts,\n         actions: actions,\n         prefix: prefix,\n         subtitle: subtitle,\n         details: details,\n         suffix: suffix,\n       );\n\n  /// Creates a [FTile] without custom layout behavior.\n  ///\n  /// Assuming LTR locale:\n  /// ```diagram\n  /// ----------------------------------------\n  /// | [prefix] [child]                     |\n  /// ----------------------------------------\n  /// ```\n  ///\n  /// The order is reversed for RTL locales.\n  FTile.raw({\n    required Widget child,\n    this.style,\n    this.enabled,\n    this.selected = false,\n    this.semanticsLabel,\n    this.autofocus = false,\n    this.focusNode,\n    this.onFocusChange,\n    this.onHoverChange,\n    this.onStateChange,\n    this.onPress,\n    this.onLongPress,\n    this.onSecondaryPress,\n    this.onSecondaryLongPress,\n    this.shortcuts,\n    this.actions,\n    Widget? prefix,\n    super.key,\n  }) : _child = FItem.raw(\n         style: style,\n         enabled: enabled,\n         selected: selected,\n         semanticsLabel: semanticsLabel,\n         autofocus: autofocus,\n         focusNode: focusNode,\n         onFocusChange: onFocusChange,\n         onHoverChange: onHoverChange,\n         onStateChange: onStateChange,\n         onPress: onPress,\n         onLongPress: onLongPress,\n         onSecondaryPress: onSecondaryPress,\n         onSecondaryLongPress: onSecondaryLongPress,\n         shortcuts: shortcuts,\n         actions: actions,\n         prefix: prefix,\n         child: child,\n       );\n\n  @override\n  Widget build(BuildContext context) {\n    final parent = FInheritedItemData.maybeOf(context);\n    final style = parent == null ? this.style?.call(context.theme.tileStyle) ?? context.theme.tileStyle : null;\n    return FInheritedItemData.merge(style: style, last: true, child: _child);\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(FlagProperty('selected', value: selected, ifTrue: 'selected'))\n      ..add(StringProperty('semanticsLabel', semanticsLabel, defaultValue: null, quoted: false))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('onFocusChange', onFocusChange))\n      ..add(ObjectFlagProperty.has('onHoverChange', onHoverChange))\n      ..add(ObjectFlagProperty.has('onChange', onStateChange))\n      ..add(ObjectFlagProperty.has('onPress', onPress))\n      ..add(ObjectFlagProperty.has('onLongPress', onLongPress))\n      ..add(ObjectFlagProperty.has('onSecondaryPress', onSecondaryPress))\n      ..add(ObjectFlagProperty.has('onSecondaryLongPress', onSecondaryLongPress))\n      ..add(DiagnosticsProperty('shortcuts', shortcuts))\n      ..add(DiagnosticsProperty('actions', actions));\n  }\n}\n\n/// A [FTile]'s style.\nclass FTileStyle extends FItemStyle with Diagnosticable, _$FTileStyleFunctions {\n  /// Creates a [FTileStyle].\n  FTileStyle({\n    required super.backgroundColor,\n    required super.decoration,\n    required super.contentStyle,\n    required super.rawItemContentStyle,\n    required super.tappableStyle,\n    required super.focusedOutlineStyle,\n    super.margin = EdgeInsets.zero,\n  });\n\n  /// Creates a [FTileStyle].\n  FTileStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        backgroundColor: FWidgetStateMap.all(colors.background),\n        decoration: FWidgetStateMap({\n          WidgetState.disabled: BoxDecoration(\n            color: colors.disable(colors.secondary),\n            border: Border.all(color: colors.border),\n            borderRadius: style.borderRadius,\n          ),\n          WidgetState.hovered | WidgetState.pressed: BoxDecoration(\n            color: colors.secondary,\n            border: Border.all(color: colors.border),\n            borderRadius: style.borderRadius,\n          ),\n          WidgetState.any: BoxDecoration(\n            color: colors.background,\n            border: Border.all(color: colors.border),\n            borderRadius: style.borderRadius,\n          ),\n        }),\n        contentStyle: FItemContentStyle(\n          padding: const EdgeInsetsDirectional.fromSTEB(15, 13, 10, 13),\n          prefixIconStyle: FWidgetStateMap({\n            WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 18),\n            WidgetState.any: IconThemeData(color: colors.primary, size: 18),\n          }),\n          titleTextStyle: FWidgetStateMap({\n            WidgetState.disabled: typography.base.copyWith(color: colors.disable(colors.primary)),\n            WidgetState.any: typography.base,\n          }),\n          subtitleTextStyle: FWidgetStateMap({\n            WidgetState.disabled: typography.xs.copyWith(color: colors.disable(colors.mutedForeground)),\n            WidgetState.any: typography.xs.copyWith(color: colors.mutedForeground),\n          }),\n          detailsTextStyle: FWidgetStateMap({\n            WidgetState.disabled: typography.base.copyWith(color: colors.disable(colors.mutedForeground)),\n            WidgetState.any: typography.base.copyWith(color: colors.mutedForeground),\n          }),\n          suffixIconStyle: FWidgetStateMap({\n            WidgetState.disabled: IconThemeData(color: colors.disable(colors.mutedForeground), size: 18),\n            WidgetState.any: IconThemeData(color: colors.mutedForeground, size: 18),\n          }),\n        ),\n        rawItemContentStyle: FRawItemContentStyle(\n          padding: const EdgeInsetsDirectional.fromSTEB(15, 13, 10, 13),\n          prefixIconStyle: FWidgetStateMap({\n            WidgetState.disabled: IconThemeData(color: colors.disable(colors.primary), size: 18),\n            WidgetState.any: IconThemeData(color: colors.primary, size: 18),\n          }),\n          childTextStyle: FWidgetStateMap({\n            WidgetState.disabled: typography.base.copyWith(color: colors.disable(colors.primary)),\n            WidgetState.any: typography.base,\n          }),\n        ),\n        tappableStyle: style.tappableStyle.copyWith(\n          motion: FTappableMotion.none,\n          pressedEnterDuration: Duration.zero,\n          pressedExitDuration: const Duration(milliseconds: 25),\n        ),\n        focusedOutlineStyle: style.focusedOutlineStyle,\n      );\n}\n",
      "tile_group": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'tile_group.design.dart';\n\n/// A marker interface which denotes that mixed-in widgets can group tiles and be used in a [FTileGroup.merge].\nmixin FTileGroupMixin on Widget {}\n\n/// A tile group that groups multiple [FTileMixin]s together.\n///\n/// Tiles grouped together will be separated by a divider, specified by [divider].\n///\n/// ## Using [FTileGroup] in a [FPopover] when wrapped in a [FTileGroup]\n/// When a [FPopover] is used inside an [FTileGroup], tiles & groups inside the popover will inherit styling from the\n/// parent group. This happens because [FPopover]'s content shares the same `BuildContext` as its child, causing data\n/// inheritance that may lead to unexpected rendering issues.\n///\n/// To prevent this styling inheritance, wrap the popover in a [FInheritedItemData] with null data to reset the\n/// inherited data:\n/// ```dart\n/// FTileGroup(\n///   children: [\n///     FTile(title: Text('Tile with popover')),\n///     FPopoverWrapperTile(\n///       popoverBuilder: (_, _) => FInheritedItemData(\n///         child: FTileGroup(\n///           children: [\n///             FTile(title: Text('Popover Tile 1')),\n///             FTile(title: Text('Popover Tile 2')),\n///           ],\n///         ),\n///       ),\n///       child: FButton(child: Text('Open Popover')),\n///     ),\n///   ],\n/// );\n/// ```\n///\n///\n/// See:\n/// * https://forui.dev/docs/tile/tile-group for working examples.\n/// * [FTileGroupStyle] for customizing a tile group's appearance.\nclass FTileGroup extends StatelessWidget with FTileGroupMixin {\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create tile-group\n  /// ```\n  final FTileGroupStyle Function(FTileGroupStyle style)? style;\n\n  /// {@template forui.widgets.FTileGroup.scrollController}\n  /// The scroll controller used to control the position to which this group is scrolled.\n  ///\n  /// Scrolling past the end of the group using the controller will result in undefined behavior.\n  ///\n  /// It is ignored if the group is part of a merged [FTileGroup].\n  /// {@endtemplate}\n  final ScrollController? scrollController;\n\n  /// {@template forui.widgets.FTileGroup.cacheExtent}\n  /// The scrollable area's cache extent in logical pixels.\n  ///\n  /// Items that fall in this cache area are laid out even though they are not (yet) visible on screen. It describes\n  /// how many pixels the cache area extends before the leading edge and after the trailing edge of the viewport.\n  ///\n  /// It is ignored if the group is part of a merged [FTileGroup].\n  /// {@endtemplate}\n  final double? cacheExtent;\n\n  /// {@template forui.widgets.FTileGroup.maxHeight}\n  /// The max height, in logical pixels. Defaults to infinity.\n  ///\n  /// It is ignored if the group is part of a merged [FTileGroup].\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [maxHeight] is not positive.\n  /// {@endtemplate}\n  final double maxHeight;\n\n  /// {@template forui.widgets.FTileGroup.dragStartBehavior}\n  /// Determines the way that drag start behavior is handled. Defaults to [DragStartBehavior.start].\n  ///\n  /// It is ignored if the group is part of a merged [FTileGroup].\n  /// {@endtemplate}\n  final DragStartBehavior dragStartBehavior;\n\n  /// {@template forui.widgets.FTileGroup.physics}\n  /// The scroll physics of the group. Defaults to [ClampingScrollPhysics].\n  /// {@endtemplate}\n  final ScrollPhysics physics;\n\n  /// {@template forui.widgets.FTileGroup.divider}\n  /// The divider between tiles.\n  /// {@endtemplate}\n  ///\n  /// Defaults to [FItemDivider.indented].\n  final FItemDivider divider;\n\n  /// True if the group is enabled. Defaults to true.\n  final bool? enabled;\n\n  /// The group's semantic label.\n  ///\n  /// It is ignored if the group is part of a merged [FTileGroup].\n  final String? semanticsLabel;\n\n  /// The label above the group.\n  ///\n  /// It is not rendered if the group is disabled or part of a merged [FTileGroup].\n  final Widget? label;\n\n  /// The description below the group.\n  ///\n  /// It is not rendered if the group is disabled or part of a merged [FTileGroup].\n  final Widget? description;\n\n  /// The error below the [description].\n  ///\n  /// It is not rendered if the group is disabled or part of a merged [FTileGroup].\n  final Widget? error;\n\n  /// The delegate that builds the sliver children.\n  // ignore: avoid_positional_boolean_parameters\n  final Widget Function(FTileGroupStyle style, bool scrollable) _builder;\n\n  /// Creates a [FTileGroup].\n  FTileGroup({\n    required List<FTileMixin> children,\n    this.style,\n    this.scrollController,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.enabled,\n    this.divider = FItemDivider.indented,\n    this.semanticsLabel,\n    this.label,\n    this.description,\n    this.error,\n    super.key,\n  }) : assert(0 < maxHeight, 'maxHeight ($maxHeight) must be > 0'),\n       _builder = ((style, enabled) => SliverList.list(\n         children: [\n           for (final (index, child) in children.indexed)\n             FInheritedItemData.merge(\n               style: style.tileStyle,\n               enabled: enabled,\n               dividerColor: style.dividerColor,\n               dividerWidth: style.dividerWidth,\n               divider: divider,\n               index: index,\n               last: index == children.length - 1,\n               child: child,\n             ),\n         ],\n       ));\n\n  /// Creates a [FTileGroup] that lazily builds its children.\n  ///\n  /// {@template forui.widgets.FTileGroup.builder}\n  /// The [tileBuilder] is called for each tile that should be built. The current level's [FInheritedItemData] is **not**\n  /// visible to `tileBuilder`.\n  /// * It may return null to signify the end of the group.\n  /// * It may be called more than once for the same index.\n  /// * It will be called only for indices <= [count] if [count] is given.\n  ///\n  /// The [count] is the number of tiles to build. If null, [tileBuilder] will be called until it returns null.\n  ///\n  /// ## Notes\n  /// May result in an infinite loop or run out of memory if:\n  /// * Placed in a parent widget that does not constrain its size, i.e. [Column].\n  /// * [count] is null and [tileBuilder] always provides a zero-size widget, i.e. SizedBox(). If possible, provide\n  ///   tiles with non-zero size, return null from builder, or set [count] to non-null.\n  /// {@endtemplate}\n  FTileGroup.builder({\n    required NullableIndexedWidgetBuilder tileBuilder,\n    int? count,\n    this.style,\n    this.scrollController,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.enabled,\n    this.divider = FItemDivider.indented,\n    this.semanticsLabel,\n    this.label,\n    this.description,\n    this.error,\n    super.key,\n  }) : assert(0 < maxHeight, 'maxHeight ($maxHeight) must be > 0'),\n       assert(count == null || 0 <= count, 'count ($count) must be >= 0'),\n       _builder = ((style, enabled) => SliverList.builder(\n         itemCount: count,\n         itemBuilder: (context, index) {\n           if (tileBuilder(context, index) case final tile?) {\n             return FInheritedItemData.merge(\n               style: style.tileStyle,\n               enabled: enabled,\n               dividerColor: style.dividerColor,\n               dividerWidth: style.dividerWidth,\n               divider: divider,\n               index: index,\n               last: (count != null && index == count - 1) || tileBuilder(context, index + 1) == null,\n               child: tile,\n             );\n           }\n\n           return null;\n         },\n       ));\n\n  /// Creates a [FTileGroup] that merges multiple [FTileGroupMixin]s together.\n  ///\n  /// All group labels will be ignored.\n  FTileGroup.merge({\n    required List<FTileGroupMixin> children,\n    this.style,\n    this.scrollController,\n    this.cacheExtent,\n    this.maxHeight = double.infinity,\n    this.dragStartBehavior = DragStartBehavior.start,\n    this.physics = const ClampingScrollPhysics(),\n    this.enabled,\n    this.divider = FItemDivider.full,\n    this.semanticsLabel,\n    this.label,\n    this.description,\n    this.error,\n    super.key,\n  }) : assert(0 < maxHeight, 'maxHeight ($maxHeight) must be > 0'),\n       _builder = ((style, enabled) => SliverMainAxisGroup(\n         slivers: [\n           for (final (index, child) in children.indexed)\n             FInheritedItemData.merge(\n               style: style.tileStyle,\n               enabled: enabled,\n               dividerColor: style.dividerColor,\n               dividerWidth: style.dividerWidth,\n               divider: divider,\n               index: index,\n               last: index == children.length - 1,\n               child: child,\n             ),\n         ],\n       ));\n\n  @override\n  Widget build(BuildContext context) {\n    final data = FInheritedItemData.maybeOf(context);\n    final inheritedStyle = FTileGroupStyleData.of(context);\n    final style = this.style?.call(inheritedStyle) ?? inheritedStyle;\n    final enabled = this.enabled ?? data?.enabled ?? true;\n\n    final sliver = _builder(style, enabled);\n    if (data != null) {\n      return sliver;\n    }\n\n    return FLabel(\n      style: style,\n      axis: Axis.vertical,\n      states: {if (!enabled) WidgetState.disabled, if (error != null) WidgetState.error},\n      label: label,\n      description: description,\n      error: error,\n      child: Semantics(\n        container: true,\n        label: semanticsLabel,\n        child: ConstrainedBox(\n          constraints: BoxConstraints(maxHeight: maxHeight),\n          // We use a Container instead of DecoratedBox as using a DecoratedBox will cause the border to be clipped.\n          // ignore: use_decorated_box\n          child: Container(\n            decoration: style.decoration,\n            child: ClipRRect(\n              borderRadius: style.decoration.borderRadius ?? BorderRadius.zero,\n              child: FTileGroupStyleData(\n                style: style,\n                child: CustomScrollView(\n                  controller: scrollController,\n                  cacheExtent: cacheExtent,\n                  dragStartBehavior: dragStartBehavior,\n                  shrinkWrap: true,\n                  physics: physics,\n                  slivers: [sliver],\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('controller', scrollController))\n      ..add(DoubleProperty('cacheExtent', cacheExtent))\n      ..add(DoubleProperty('maxHeight', maxHeight))\n      ..add(EnumProperty('dragStartBehavior', dragStartBehavior))\n      ..add(DiagnosticsProperty('physics', physics))\n      ..add(FlagProperty('enabled', value: enabled, ifTrue: 'enabled'))\n      ..add(EnumProperty('divider', divider))\n      ..add(StringProperty('semanticsLabel', semanticsLabel));\n  }\n}\n\n/// An inherited widget that provides the [FTileGroupStyle] to its descendants.\nclass FTileGroupStyleData extends InheritedWidget {\n  /// Returns the [FTileGroupStyle] in the given [context], or null if none is found.\n  static FTileGroupStyle? maybeOf(BuildContext context) =>\n      context.dependOnInheritedWidgetOfExactType<FTileGroupStyleData>()?.style;\n\n  /// Returns the [FTileGroupStyle] in the given [context].\n  static FTileGroupStyle of(BuildContext context) =>\n      context.dependOnInheritedWidgetOfExactType<FTileGroupStyleData>()?.style ?? context.theme.tileGroupStyle;\n\n  /// The style of the group.\n  final FTileGroupStyle style;\n\n  /// Creates a [FTileGroupStyleData].\n  const FTileGroupStyleData({required this.style, required super.child, super.key});\n\n  @override\n  bool updateShouldNotify(FTileGroupStyleData old) => style != old.style;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// A [FTileGroup]'s style.\nclass FTileGroupStyle extends FLabelStyle with _$FTileGroupStyleFunctions {\n  /// The group's decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// The tile's style.\n  @override\n  final FTileStyle tileStyle;\n\n  /// The divider's style.\n  ///\n  /// Supported states:\n  /// * [WidgetState.disabled]\n  @override\n  final FWidgetStateMap<Color> dividerColor;\n\n  /// The divider's width.\n  @override\n  final double dividerWidth;\n\n  /// Creates a [FTileGroupStyle].\n  FTileGroupStyle({\n    required this.decoration,\n    required this.tileStyle,\n    required this.dividerColor,\n    required this.dividerWidth,\n    required super.labelTextStyle,\n    required super.descriptionTextStyle,\n    required super.errorTextStyle,\n    super.labelPadding = const EdgeInsets.symmetric(vertical: 7.7),\n    super.descriptionPadding = const EdgeInsets.only(top: 7.5),\n    super.errorPadding = const EdgeInsets.only(top: 5),\n    super.childPadding,\n  });\n\n  /// Creates a [FTileGroupStyle] that inherits from the given arguments.\n  factory FTileGroupStyle.inherit({required FColors colors, required FTypography typography, required FStyle style}) {\n    final tileStyle = FTileStyle.inherit(colors: colors, typography: typography, style: style);\n    return FTileGroupStyle(\n      decoration: BoxDecoration(\n        border: Border.all(color: colors.border, width: style.borderWidth),\n        borderRadius: style.borderRadius,\n      ),\n\n      tileStyle: tileStyle.copyWith(\n        decoration: tileStyle.decoration.map(\n          (d) => d == null\n              ? null\n              : BoxDecoration(\n                  color: d.color,\n                  image: d.image,\n                  boxShadow: d.boxShadow,\n                  gradient: d.gradient,\n                  backgroundBlendMode: d.backgroundBlendMode,\n                  shape: d.shape,\n                ),\n        ),\n      ),\n      dividerColor: FWidgetStateMap.all(colors.border),\n      dividerWidth: style.borderWidth,\n      labelTextStyle: FWidgetStateMap({\n        WidgetState.error: typography.base.copyWith(\n          color: style.formFieldStyle.labelTextStyle.maybeResolve({})?.color ?? colors.primary,\n          fontWeight: FontWeight.w600,\n        ),\n        WidgetState.disabled: typography.base.copyWith(\n          color:\n              style.formFieldStyle.labelTextStyle.maybeResolve({WidgetState.disabled})?.color ??\n              colors.disable(colors.primary),\n          fontWeight: FontWeight.w600,\n        ),\n        WidgetState.any: typography.base.copyWith(\n          color: style.formFieldStyle.labelTextStyle.maybeResolve({})?.color ?? colors.primary,\n          fontWeight: FontWeight.w600,\n        ),\n      }),\n      descriptionTextStyle: style.formFieldStyle.descriptionTextStyle.map(\n        (s) => typography.xs.copyWith(color: s.color),\n      ),\n      errorTextStyle: typography.xs.copyWith(color: style.formFieldStyle.errorTextStyle.color),\n    );\n  }\n}\n"
    },
    "TimeField": {
      "time_field": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:intl/intl.dart' hide TextDirection;\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/time_field/input/time_input.dart';\nimport 'package:forui/src/widgets/time_field/picker/picker_form_field.dart';\nimport 'package:forui/src/widgets/time_field/picker/properties.dart';\n\npart 'input/input_time_field.dart';\n\npart 'picker/picker_time_field.dart';\n\n/// The time field's controller.\nclass FTimeFieldController extends FValueNotifier<FTime?> {\n  static String? _defaultValidator(FTime? _) => null;\n\n  /// The controller for the popover. Does nothing if the time field is input only.\n  ///\n  /// ## Contract\n  /// Manually disposing this controller is undefined behavior. Dispose this [FTimeFieldController] instead.\n  final FPopoverController popover;\n\n  /// Returns an error string to display if the input is invalid, or null otherwise. It is also used to determine\n  /// whether a time in a picker is selectable.\n  ///\n  /// Defaults to always returning null.\n  final FormFieldValidator<FTime> validator;\n\n  final FTimePickerController _picker;\n  bool _mutating = false;\n\n  /// Creates a [FTimeFieldController].\n  FTimeFieldController({\n    required TickerProvider vsync,\n    this.validator = _defaultValidator,\n    FTime? initialTime,\n    FPopoverMotion popoverMotion = const FPopoverMotion(),\n  }) : popover = FPopoverController(vsync: vsync, motion: popoverMotion),\n       _picker = FTimePickerController(initial: initialTime ?? const FTime()),\n       super(initialTime) {\n    _picker.addValueListener((time) {\n      try {\n        _mutating = true;\n        value = time;\n      } finally {\n        _mutating = false;\n      }\n    });\n\n    addValueListener(update);\n  }\n\n  @override\n  void dispose() {\n    _picker.dispose();\n    popover.dispose();\n    super.dispose();\n  }\n}\n\n@internal\nextension FTimeFieldControllers on FTimeFieldController {\n  void update(FTime? time) {\n    if (!_mutating && time != null) {\n      _picker.value = time;\n    }\n  }\n}\n\n/// A time field allows a time to be selected from a picker or input field.\n///\n/// A [FTimeField] is internally a [FormField], therefore it can be used in a [Form].\n///\n/// It is recommended to use [FTimeField.picker] on touch devices and [FTimeField.new] on non-touch devices.\n///\n/// The input field supports both arrow key navigation:\n/// * Up/Down arrows: Increment/decrement values\n/// * Left/Right arrows: Move between time segments\n///\n/// The input field does not support the following locales that use non-western numerals & scripts that require\n/// composing, it will default to English:\n/// {@macro forui.localizations.scriptNumerals}\n/// {@macro forui.localization.scriptPeriods}\n///\n/// The following locales will default to `zh`:\n///   * Chinese (Hong Kong) (\u7e41\u9ad4\u4e2d\u6587)\n///   * Chinese (Taiwan) (\u7e41\u9ad4\u4e2d\u6587)\n///\n/// Consider providing a [FTimeFieldController.validator] to perform custom time validation logic. By default, all\n/// times are valid.\n///\n/// See:\n/// * https://forui.dev/docs/form/time-field for working examples.\n/// * [FTimeFieldController] for controlling a time field.\n/// * [FTimeFieldStyle] for customizing a time field's appearance.\nabstract class FTimeField extends StatefulWidget {\n  /// The default prefix builder that shows a clock icon.\n  static Widget defaultIconBuilder(BuildContext _, FTimeFieldStyle style, Set<WidgetState> states) => Padding(\n    padding: const EdgeInsetsDirectional.only(start: 14.0, end: 8.0),\n    child: IconTheme(data: style.iconStyle, child: const Icon(FIcons.clock4)),\n  );\n\n  static Widget _fieldBuilder(BuildContext _, FTimeFieldStyle _, Set<WidgetState> _, Widget child) => child;\n\n  /// The controller.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * Both [controller] and [initialTime] are provided.\n  final FTimeFieldController? controller;\n\n  /// The style.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create time-field\n  /// ```\n  final FTimeFieldStyle Function(FTimeFieldStyle style)? style;\n\n  /// The initial time.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if:\n  /// * Both [controller] and [initialTime] are provided.\n  final FTime? initialTime;\n\n  /// True if the time field should use the 24-hour format.\n  ///\n  /// Setting this to false will use the locale's default format, which may be 24-hours. Defaults to false.\n  final bool hour24;\n\n  /// {@macro forui.foundation.doc_templates.autofocus}\n  final bool autofocus;\n\n  /// {@macro forui.foundation.doc_templates.focusNode}\n  final FocusNode? focusNode;\n\n  /// The builder used to decorate the time-field. It should use the given child.\n  ///\n  /// Defaults to returning the given child.\n  final FFieldBuilder<FTimeFieldStyle> builder;\n\n  /// Builds a widget at the start of the input field that can be pressed to toggle the popover. Defaults to\n  /// [defaultIconBuilder].\n  final FFieldIconBuilder<FTimeFieldStyle>? prefixBuilder;\n\n  /// Builds a widget at the end of the input field that can be pressed to toggle the popover. Defaults to\n  /// no suffix.\n  final FFieldIconBuilder<FTimeFieldStyle>? suffixBuilder;\n\n  /// The label.\n  final Widget? label;\n\n  /// The description.\n  final Widget? description;\n\n  /// {@macro forui.foundation.form_field_properties.errorBuilder}\n  final Widget Function(BuildContext context, String message) errorBuilder;\n\n  /// {@macro forui.foundation.form_field_properties.enabled}\n  final bool enabled;\n\n  /// Handler called when the time changes.\n  final ValueChanged<FTime?>? onChange;\n\n  /// {@macro forui.foundation.form_field_properties.onSaved}\n  final FormFieldSetter<FTime>? onSaved;\n\n  /// {@macro forui.foundation.form_field_properties.onReset}\n  final VoidCallback? onReset;\n\n  /// Used to enable/disable this checkbox auto validation and update its error text.\n  ///\n  /// Defaults to [AutovalidateMode.onUnfocus].\n  ///\n  /// If [AutovalidateMode.onUserInteraction], this checkbox will only auto-validate after its content changes. If\n  /// [AutovalidateMode.always], it will auto-validate even without user interaction. If [AutovalidateMode.disabled],\n  /// auto-validation will be disabled.\n  final AutovalidateMode autovalidateMode;\n\n  /// An optional property that forces the [FormFieldState] into an error state by directly setting the\n  /// [FormFieldState.errorText] property without running the validator function.\n  ///\n  /// When the [forceErrorText] property is provided, the [FormFieldState.errorText] will be set to the provided value,\n  /// causing the form field to be considered invalid and to display the error message specified.\n  ///\n  /// When [FTimeFieldController.validator] is provided, [forceErrorText] will override any error that it returns.\n  /// [FTimeFieldController.validator] will not be called unless [forceErrorText] is null.\n  final String? forceErrorText;\n\n  const FTimeField._({\n    this.controller,\n    this.style,\n    this.initialTime,\n    this.hour24 = false,\n    this.autofocus = false,\n    this.focusNode,\n    this.builder = _fieldBuilder,\n    this.prefixBuilder = defaultIconBuilder,\n    this.suffixBuilder,\n    this.label,\n    this.description,\n    this.enabled = true,\n    this.onChange,\n    this.onSaved,\n    this.onReset,\n    this.autovalidateMode = AutovalidateMode.onUnfocus,\n    this.forceErrorText,\n    this.errorBuilder = FFormFieldProperties.defaultErrorBuilder,\n    super.key,\n  }) : assert(\n         controller == null || initialTime == null,\n         'Cannot provide both a controller and initialTime. To fix, set the initial time directly in the controller.',\n       );\n\n  /// Creates a time field that wraps a text input field.\n  ///\n  /// The [textInputAction] property can be used to specify the action button on the soft keyboard. The [textAlign]\n  /// property is used to specify the alignment of the text within the input field.\n  ///\n  /// The [textAlignVertical] property is used to specify the vertical alignment of the text and can be useful when\n  /// used with a prefix or suffix.\n  ///\n  /// The [textDirection] property can be used to specify the directionality of the text input.\n  ///\n  /// If [expands] is true, the input field will expand to fill its parent's height.\n  ///\n  /// The [onEditingComplete] callback is called when the user submits the input field, such as by pressing the done\n  /// button on the keyboard.\n  ///\n  /// The [onSubmit] callback is called when the user submits a valid time value.\n  ///\n  /// The [mouseCursor] can be used to specify the cursor shown when hovering over the input field.\n  ///\n  /// If [canRequestFocus] is false, the input field cannot obtain focus but can still be selected.\n  ///\n  /// See also:\n  /// * [FTimeField.picker] - Creates a time field with only a picker.\n  const factory FTimeField({\n    FTimeFieldController? controller,\n    FTimeFieldStyle Function(FTimeFieldStyle style)? style,\n    FTime? initialTime,\n    bool hour24,\n    bool autofocus,\n    FocusNode? focusNode,\n    FFieldBuilder<FTimeFieldStyle> builder,\n    FFieldIconBuilder<FTimeFieldStyle>? prefixBuilder,\n    FFieldIconBuilder<FTimeFieldStyle>? suffixBuilder,\n    TextInputAction? textInputAction,\n    TextAlign textAlign,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    bool expands,\n    VoidCallback? onEditingComplete,\n    ValueChanged<FTime>? onSubmit,\n    MouseCursor? mouseCursor,\n    bool canRequestFocus,\n    Widget? label,\n    Widget? description,\n    bool enabled,\n    ValueChanged<FTime?>? onChange,\n    FormFieldSetter<FTime>? onSaved,\n    VoidCallback? onReset,\n    AutovalidateMode autovalidateMode,\n    String? forceErrorText,\n    Widget Function(BuildContext context, String message) errorBuilder,\n    Key? key,\n  }) = _InputTimeField;\n\n  /// Creates a [FTimeField] that allows a time to be selected using only a picker.\n  ///\n  /// The [format] customizes the appearance of the time in the input field. Defaults to the [DateFormat.Hm] if\n  /// [hour24] is true or [DateFormat.jm] if false.\n  ///\n  /// The [hint] is displayed when the input field is empty. Defaults to the current locale's\n  /// [FLocalizations.timeFieldHint].\n  ///\n  /// The [textAlign] property is used to specify the alignment of the text within the input field.\n  ///\n  /// The [textAlignVertical] property is used to specify the vertical alignment of the text and can be useful when\n  /// used with a prefix or suffix.\n  ///\n  /// The [textDirection] property can be used to specify the directionality of the text input.\n  ///\n  /// If [expands] is true, the input field will expand to fill its parent's height.\n  ///\n  /// The [mouseCursor] can be used to specify the cursor shown when hovering over the input field.\n  ///\n  /// If [canRequestFocus] is false, the input field cannot obtain focus but can still be selected.\n  ///\n  /// The [anchor] and [inputAnchor] control the alignment points for the picker popover positioning.\n  /// Defaults to [Alignment.topLeft] and [Alignment.bottomLeft] respectively.\n  ///\n  /// The [spacing] property controls the spacing between the input field and the picker popover. Defaults to\n  /// `FPortalSpacing(4)`.\n  ///\n  /// The [overflow] function controls how the picker repositions when space is constrained. Defaults to\n  /// [FPortalOverflow.flip].\n  ///\n  /// The [offset] property controls the offset of the picker popover. Defaults to [Offset.zero].\n  ///\n  /// [hideRegion] controls the region that can be tapped to hide the popover. Defaults to\n  /// [FPopoverHideRegion.anywhere].\n  ///\n  /// [hourInterval] and [minuteInterval] control the increment/decrement interval of the hour and minute respectively.\n  /// Default to 1.\n  ///\n  /// See also:\n  /// * [FTimeField.new] - Creates a time field with only an input field.\n  const factory FTimeField.picker({\n    FTimeFieldController? controller,\n    FTimeFieldStyle Function(FTimeFieldStyle style)? style,\n    FTime? initialTime,\n    bool hour24,\n    DateFormat? format,\n    TextAlign textAlign,\n    TextAlignVertical? textAlignVertical,\n    TextDirection? textDirection,\n    bool expands,\n    MouseCursor mouseCursor,\n    bool canRequestFocus,\n    String? hint,\n    bool autofocus,\n    FocusNode? focusNode,\n    Alignment anchor,\n    Alignment inputAnchor,\n    FPortalSpacing spacing,\n    FPortalOverflow overflow,\n    Offset offset,\n    FPopoverHideRegion hideRegion,\n    VoidCallback? onTapHide,\n    int hourInterval,\n    int minuteInterval,\n    FFieldBuilder<FTimeFieldStyle> builder,\n    FFieldIconBuilder<FTimeFieldStyle>? prefixBuilder,\n    FFieldIconBuilder<FTimeFieldStyle>? suffixBuilder,\n    Widget? label,\n    Widget? description,\n    bool enabled,\n    ValueChanged<FTime?>? onChange,\n    FormFieldSetter<FTime>? onSaved,\n    VoidCallback? onReset,\n    AutovalidateMode autovalidateMode,\n    String? forceErrorText,\n    Widget Function(BuildContext context, String message) errorBuilder,\n    Key? key,\n  }) = _PickerTimeField;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('initialTime', initialTime))\n      ..add(FlagProperty('hour24', value: hour24, ifTrue: 'hour24'))\n      ..add(FlagProperty('autofocus', value: autofocus, ifTrue: 'autofocus'))\n      ..add(DiagnosticsProperty('focusNode', focusNode))\n      ..add(ObjectFlagProperty.has('builder', builder))\n      ..add(ObjectFlagProperty.has('prefixBuilder', prefixBuilder))\n      ..add(ObjectFlagProperty.has('suffixBuilder', suffixBuilder))\n      ..add(ObjectFlagProperty.has('errorBuilder', errorBuilder))\n      ..add(FlagProperty('enabled', value: enabled, ifFalse: 'disabled'))\n      ..add(ObjectFlagProperty.has('onChange', onChange))\n      ..add(ObjectFlagProperty.has('onSaved', onSaved))\n      ..add(ObjectFlagProperty.has('onReset', onReset))\n      ..add(EnumProperty('autovalidateMode', autovalidateMode))\n      ..add(StringProperty('forceErrorText', forceErrorText));\n  }\n}\n\nabstract class _FTimeFieldState<T extends FTimeField> extends State<T> with SingleTickerProviderStateMixin {\n  late FTimeFieldController _controller =\n      widget.controller ?? FTimeFieldController(vsync: this, initialTime: widget.initialTime);\n}\n",
      "time_field_style": "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'time_field_style.design.dart';\n\n/// A time field's style.\nclass FTimeFieldStyle with Diagnosticable, _$FTimeFieldStyleFunctions {\n  /// The time field's text field style.\n  @override\n  final FTextFieldStyle textFieldStyle;\n\n  /// The time field picker's popover style.\n  @override\n  final FPopoverStyle popoverStyle;\n\n  /// The time field picker's popover constraints.\n  @override\n  final FPortalConstraints popoverConstraints;\n\n  /// The time field's picker style.\n  @override\n  final FTimePickerStyle pickerStyle;\n\n  /// The time field icon's style.\n  @override\n  final IconThemeData iconStyle;\n\n  /// Creates a [FTimeFieldStyle].\n  const FTimeFieldStyle({\n    required this.textFieldStyle,\n    required this.popoverStyle,\n    required this.pickerStyle,\n    required this.iconStyle,\n    this.popoverConstraints = const FPortalConstraints(maxWidth: 200, maxHeight: 200),\n  });\n\n  /// Creates a [FTimeFieldStyle] that inherits its properties.\n  FTimeFieldStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        textFieldStyle: FTextFieldStyle.inherit(colors: colors, typography: typography, style: style),\n        popoverStyle: FPopoverStyle.inherit(colors: colors, style: style),\n        pickerStyle: FTimePickerStyle.inherit(colors: colors, typography: typography, style: style),\n        iconStyle: IconThemeData(color: colors.mutedForeground, size: 18, weight: 100),\n      );\n}\n"
    },
    "TimePicker": {
      "picker": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:intl/intl.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/localizations/localization.dart';\nimport 'package:forui/src/widgets/time_picker/time_picker_controller.dart';\n\n@internal\nabstract class TimePicker extends StatelessWidget {\n  final FTimePickerController controller;\n  final FTimePickerStyle style;\n  final DateFormat format;\n  final int padding;\n  final EdgeInsetsGeometry start;\n  final EdgeInsetsGeometry end;\n  final int hourInterval;\n  final int minuteInterval;\n\n  TimePicker._({\n    required this.controller,\n    required this.style,\n    required this.format,\n    required this.padding,\n    required this.hourInterval,\n    required this.minuteInterval,\n  }) : start = EdgeInsetsDirectional.only(start: style.padding.start),\n       end = EdgeInsetsDirectional.only(end: style.padding.end);\n\n  factory TimePicker({\n    required FTimePickerController controller,\n    required FTimePickerStyle style,\n    required DateFormat format,\n    required int padding,\n    required int hourInterval,\n    required int minuteInterval,\n  }) =>\n      switch ((scriptNumerals.contains(format.locale), format.pattern!.contains('a'))) {\n        (false, true) => _Western12Picker.new,\n        (false, false) => _Western24Picker.new,\n        (true, true) => _Eastern12Picker.new,\n        (true, false) => _Eastern24Picker.new,\n      }(\n        controller: controller,\n        style: style,\n        format: format,\n        padding: padding,\n        hourInterval: hourInterval,\n        minuteInterval: minuteInterval,\n      );\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('format', format))\n      ..add(IntProperty('padding', padding))\n      ..add(DiagnosticsProperty('start', start))\n      ..add(DiagnosticsProperty('end', end))\n      ..add(IntProperty('hourInterval', hourInterval))\n      ..add(IntProperty('minuteInterval', minuteInterval));\n  }\n}\n\nclass _HourPicker extends StatefulWidget with FPickerWheelMixin {\n  final FTimePickerController controller;\n  final String pattern;\n  final Widget child;\n\n  const _HourPicker({required this.controller, required this.pattern, required this.child});\n\n  @override\n  State<_HourPicker> createState() => _HourPickerState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(StringProperty('pattern', pattern));\n  }\n}\n\nclass _HourPickerState extends State<_HourPicker> {\n  int? _previous;\n\n  @override\n  Widget build(BuildContext context) => NotificationListener<ScrollUpdateNotification>(\n    onNotification: (_) {\n      final picker = widget.controller.picker!;\n      final current = picker.wheels[widget.pattern.startsWith('a') ? 1 : 0].selectedItem % 12;\n      final period = picker.wheels[widget.pattern.startsWith('a') ? 0 : 2];\n      final next = period.selectedItem.isEven ? 1 : 0;\n\n      if (!widget.controller.mutating && ((_previous == 11 && current == 0) || (_previous == 0 && current == 11))) {\n        // Workaround for when the picker's parent listens to changes in the picker.\n        WidgetsBinding.instance.addPostFrameCallback(\n          (_) => period.animateToItem(next, duration: const Duration(milliseconds: 100), curve: Curves.decelerate),\n        );\n      }\n\n      _previous = current;\n      return false;\n    },\n    child: widget.child,\n  );\n}\n\nclass _Western12Picker extends TimePicker {\n  _Western12Picker({\n    required super.controller,\n    required super.style,\n    required super.format,\n    required super.padding,\n    required super.hourInterval,\n    required super.minuteInterval,\n  }) : super._();\n\n  @override\n  Widget build(BuildContext context) {\n    // Do NOT try to separate the date returned by format by whitespace. Locales may use NNBSP or have no separators.\n    // ISTG if there's a locale that inserts the period in the middle of the time...\n    final period = DateFormat('a', format.locale);\n\n    // We cannot insert the padding outside the pickers because the resultant affordance might be too small.\n    final (hourPadding, minutePadding, periodPadding) = switch (format.pattern!.startsWith('a')) {\n      (true) => (EdgeInsets.zero, end, start),\n      (false) => (start, EdgeInsets.zero, end),\n    };\n\n    final periodPicker = FPickerWheel(\n      children: [\n        Padding(padding: periodPadding, child: Text(period.format(DateTime.utc(1970, 1, 1, 1)))),\n        Padding(padding: periodPadding, child: Text(period.format(DateTime.utc(1970, 1, 1, 13)))),\n      ],\n    );\n\n    final pickers = [\n      _HourPicker(\n        controller: controller,\n        pattern: format.pattern!,\n        child: FPickerWheel.builder(\n          builder: (_, index) {\n            final hour = (index * hourInterval) % 12;\n            return Padding(padding: hourPadding, child: Text('${hour == 0 ? 12 : hour}'.padLeft(padding, '0')));\n          },\n        ),\n      ),\n      const Text(':'),\n      FPickerWheel.builder(\n        builder: (_, index) =>\n            Padding(padding: minutePadding, child: Text('${(index * minuteInterval) % 60}'.padLeft(2, '0'))),\n      ),\n    ];\n\n    format.pattern!.startsWith('a') ? pickers.insert(0, periodPicker) : pickers.add(periodPicker);\n\n    return FPicker(controller: controller.picker, style: style, children: pickers);\n  }\n}\n\nclass _Western24Picker extends TimePicker {\n  _Western24Picker({\n    required super.controller,\n    required super.style,\n    required super.format,\n    required super.padding,\n    required super.hourInterval,\n    required super.minuteInterval,\n  }) : super._();\n\n  @override\n  Widget build(BuildContext context) => FPicker(\n    controller: controller.picker,\n    style: style,\n    children: [\n      FPickerWheel.builder(\n        builder: (_, index) =>\n            Padding(padding: start, child: Text('${(index * hourInterval) % 24}'.padLeft(padding, '0'))),\n      ),\n      const Text(':'),\n      FPickerWheel.builder(\n        builder: (_, index) => Padding(padding: end, child: Text('${(index * minuteInterval) % 60}'.padLeft(2, '0'))),\n      ),\n    ],\n  );\n}\n\nclass _Eastern12Picker extends TimePicker {\n  _Eastern12Picker({\n    required super.controller,\n    required super.style,\n    required super.format,\n    required super.padding,\n    required super.hourInterval,\n    required super.minuteInterval,\n  }) : super._();\n\n  @override\n  Widget build(BuildContext context) {\n    // Do NOT try to separate the date returned by format by whitespace. Locales may use NNBSP or have no separators.\n    // ISTG if there's a locale that inserts the period in the middle of the time...\n    final period = DateFormat('a', format.locale);\n\n    // We cannot insert the padding outside the pickers because the resultant affordance might be too small.\n    final (hourPadding, minutePadding, periodPadding) = switch (format.pattern!.startsWith('a')) {\n      (true) => (EdgeInsets.zero, end, start),\n      (false) => (start, EdgeInsets.zero, end),\n    };\n\n    final periodPicker = FPickerWheel(\n      children: [\n        Padding(padding: periodPadding, child: Text(period.format(DateTime.utc(1970, 1, 1, 1)))),\n        Padding(padding: periodPadding, child: Text(period.format(DateTime.utc(1970, 1, 1, 13)))),\n      ],\n    );\n\n    final pickers = [\n      _HourPicker(\n        controller: controller,\n        pattern: format.pattern!,\n        child: FPickerWheel.builder(\n          builder: (_, index) {\n            final time = format.format(DateTime(1970, 1, 1, (index * hourInterval) % 12));\n            return Padding(padding: hourPadding, child: Text(time.split(':').first));\n          },\n        ),\n      ),\n      const Text(':'),\n      FPickerWheel.builder(\n        builder: (_, index) {\n          final time = format.format(DateTime(1970, 1, 1, 0, (index * minuteInterval) % 60));\n          return Padding(padding: minutePadding, child: Text(time.split(':').last.split(' ').first));\n        },\n      ),\n    ];\n\n    format.pattern!.startsWith('a') ? pickers.insert(0, periodPicker) : pickers.add(periodPicker);\n\n    return FPicker(controller: controller.picker, style: style, children: pickers);\n  }\n}\n\nclass _Eastern24Picker extends TimePicker {\n  _Eastern24Picker({\n    required super.controller,\n    required super.style,\n    required super.format,\n    required super.padding,\n    required super.hourInterval,\n    required super.minuteInterval,\n  }) : super._();\n\n  @override\n  Widget build(BuildContext context) => FPicker(\n    controller: controller.picker,\n    style: style,\n    children: [\n      FPickerWheel.builder(\n        builder: (_, index) {\n          final time = format.format(DateTime(1970, 1, 1, (index * hourInterval) % 24));\n          return Padding(padding: start, child: Text(time.split(':').first));\n        },\n      ),\n      const Text(':'),\n      FPickerWheel.builder(\n        builder: (_, index) {\n          final time = format.format(DateTime(1970, 1, 1, (index * minuteInterval) % minuteInterval));\n          return Padding(padding: end, child: Text(time.split(':').last.split(' ').first));\n        },\n      ),\n    ],\n  );\n}\n",
      "time_picker": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:intl/intl.dart';\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/time_picker/picker.dart';\nimport 'package:forui/src/widgets/time_picker/time_picker_controller.dart';\n\npart 'time_picker.design.dart';\n\n/// A time picker that allows a time to be selected.\n///\n/// Recommended for touch devices.\n///\n/// The time picker supports arrow key navigation:\n/// * Up/Down arrows: Increment/decrement selected value\n/// * Left/Right arrows: Move between wheels\n///\n/// See:\n/// * https://forui.dev/docs/form/time-picker for working examples.\n/// * [FTimePickerController] for controlling a time picker.\n/// * [FTimePickerStyle] for customizing a time picker's appearance.\nclass FTimePicker extends StatefulWidget {\n  /// The controller.\n  final FTimePickerController? controller;\n\n  /// The style. If null, the default picker style will be used.\n  ///\n  /// ## CLI\n  /// To generate and customize this style:\n  ///\n  /// ```shell\n  /// dart run forui style create time-picker\n  /// ```\n  final FTimePickerStyle Function(FTimePickerStyle style)? style;\n\n  /// True if the time picker should use the 24-hour format.\n  ///\n  /// Setting this to false will use the locale's default format, which may be 24-hours. Defaults to false.\n  final bool hour24;\n\n  /// The interval between hours in the picker. Defaults to 1.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [hourInterval] < 1.\n  final int hourInterval;\n\n  /// The interval between minutes in the picker. Defaults to 5.\n  ///\n  /// ## Contract\n  /// Throws [AssertionError] if [minuteInterval] < 1.\n  final int minuteInterval;\n\n  /// Handler called when the time picker's time changes.\n  final ValueChanged<FTime>? onChange;\n\n  /// Creates a [FTimePicker].\n  const FTimePicker({\n    this.controller,\n    this.style,\n    this.hour24 = false,\n    this.hourInterval = 1,\n    this.minuteInterval = 1,\n    this.onChange,\n    super.key,\n  }) : assert(0 < hourInterval, 'hourInterval ($hourInterval) must be > 0'),\n       assert(0 < minuteInterval, 'minuteInterval ($minuteInterval) must be > 0');\n\n  @override\n  State<FTimePicker> createState() => _FTimePickerState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', controller))\n      ..add(DiagnosticsProperty('style', style))\n      ..add(FlagProperty('hour24', value: hour24, ifTrue: '24-hour'))\n      ..add(IntProperty('hourInterval', hourInterval))\n      ..add(IntProperty('minuteInterval', minuteInterval))\n      ..add(ObjectFlagProperty.has('onChange', onChange));\n  }\n}\n\nclass _FTimePickerState extends State<FTimePicker> {\n  late FTimePickerController _controller;\n  late DateFormat format;\n  late int padding;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = widget.controller ?? FTimePickerController();\n    _controller.addListener(_onChange);\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _update();\n  }\n\n  @override\n  void didUpdateWidget(covariant FTimePicker old) {\n    super.didUpdateWidget(old);\n    if (widget.controller != old.controller) {\n      if (old.controller == null) {\n        _controller.dispose();\n      } else {\n        old.controller?.removeListener(_onChange);\n      }\n\n      _controller = widget.controller ?? FTimePickerController();\n      _controller.addListener(_onChange);\n    }\n\n    _update();\n  }\n\n  void _onChange() => widget.onChange?.call(_controller.value);\n\n  void _update() {\n    final locale = FLocalizations.of(context) ?? FDefaultLocalizations();\n\n    format = widget.hour24 ? DateFormat.Hm(locale.localeName) : DateFormat.jm(locale.localeName);\n    padding = format.pattern!.contains(RegExp('HH|hh')) ? 2 : 0;\n\n    // This behavior isn't ideal since changing the hour/minute interval causes an unintuitive time to be shown.\n    // It is difficult to fix without FixedExtentScrollController exposing the keepOffset parameter.\n    // See https://github.com/flutter/flutter/issues/162972\n    _controller\n      ..pattern = format.pattern!\n      ..hours24 = !format.pattern!.contains('a')\n      ..hourInterval = widget.hourInterval\n      ..minuteInterval = widget.minuteInterval;\n\n    _controller.picker?.dispose();\n    _controller.picker = FPickerController(initialIndexes: _controller.encode(_controller.value));\n    _controller.picker?.addListener(() => _controller.decode());\n  }\n\n  @override\n  Widget build(BuildContext context) => TimePicker(\n    controller: _controller,\n    style: widget.style?.call(context.theme.timePickerStyle) ?? context.theme.timePickerStyle,\n    format: format,\n    padding: padding,\n    hourInterval: _controller.hourInterval,\n    minuteInterval: _controller.minuteInterval,\n  );\n\n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    } else {\n      _controller.removeListener(_onChange);\n    }\n    super.dispose();\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('controller', _controller))\n      ..add(DiagnosticsProperty('format', format))\n      ..add(IntProperty('padding', padding));\n  }\n}\n\n/// The style of a time picker.\nclass FTimePickerStyle extends FPickerStyle with _$FTimePickerStyleFunctions {\n  /// The padding.\n  @override\n  final EdgeInsetsDirectional padding;\n\n  /// Creates a [FTimePickerStyle].\n  const FTimePickerStyle({\n    required super.textStyle,\n    required super.selectionBorderRadius,\n    required super.selectionColor,\n    required super.focusedOutlineStyle,\n    super.diameterRatio,\n    super.squeeze,\n    super.magnification,\n    super.overAndUnderCenterOpacity,\n    super.spacing = 0,\n    super.textHeightBehavior = const TextHeightBehavior(\n      applyHeightToFirstAscent: false,\n      applyHeightToLastDescent: false,\n    ),\n    super.selectionHeightAdjustment = 5,\n    this.padding = const EdgeInsetsDirectional.only(start: 10, end: 10),\n  });\n\n  /// Creates a [FTimePickerStyle] that inherits its properties.\n  FTimePickerStyle.inherit({required FColors colors, required FStyle style, required FTypography typography})\n    : this(\n        textStyle: typography.base.copyWith(fontWeight: FontWeight.w500),\n        selectionBorderRadius: style.borderRadius,\n        selectionColor: colors.muted,\n        selectionHeightAdjustment: 5,\n        spacing: 2,\n        focusedOutlineStyle: style.focusedOutlineStyle,\n        padding: const EdgeInsetsDirectional.only(start: 10, end: 10),\n      );\n}\n",
      "time_picker_controller": "import 'package:flutter/animation.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\n/// A [FTimePicker]'s controller.\nfinal class FTimePickerController extends FValueNotifier<FTime> {\n  FPickerController? _picker;\n  bool _mutating = false;\n  late String _pattern;\n  late bool _hours24;\n  late int _hourInterval;\n  late int _minuteInterval;\n\n  /// Creates a [FTimePickerController].\n  FTimePickerController({FTime initial = const FTime()}) : super(initial);\n\n  /// Animates the controller to the given [value].\n  Future<void> animateTo(\n    FTime value, {\n    Duration duration = const Duration(milliseconds: 100),\n    Curve curve = Curves.decelerate,\n  }) async {\n    if (value == super.value) {\n      return;\n    }\n\n    final values = [\n      (value.hour / hourInterval).round(),\n      (value.minute / minuteInterval).round(),\n      if (!hours24) value.hour < 12 ? 0 : 1,\n    ];\n\n    try {\n      _mutating = true;\n      await Future.wait([\n        for (final (index, wheel) in (_picker?.wheels ?? []).indexed)\n          wheel.animateToItem(values[index], duration: duration, curve: curve),\n      ]);\n    } finally {\n      _mutating = false;\n    }\n  }\n\n  @override\n  set value(FTime value) {\n    if (value == super.value) {\n      return;\n    }\n\n    try {\n      _mutating = true;\n      super.value = value;\n      _picker?.value = encode(value);\n    } finally {\n      _mutating = false;\n    }\n  }\n\n  // ignore: avoid_setters_without_getters\n  set _value(FTime value) => super.value = value;\n\n  @override\n  void dispose() {\n    _picker?.dispose();\n    super.dispose();\n  }\n}\n\n@internal\nextension FTimePickerControllers on FTimePickerController {\n  /// Encodes the given [value] as picker wheels.\n  List<int> encode(FTime value) {\n    final indexes = [(value.hour / hourInterval).round(), (value.minute / minuteInterval).round()];\n\n    if (!hours24) {\n      final period = value.hour < 12 ? 0 : 1;\n      _pattern.startsWith('a') ? indexes.insert(0, period) : indexes.add(period);\n    }\n\n    return indexes;\n  }\n\n  /// Decodes the current picker wheels as an [FTime].\n  void decode() {\n    final indexes = _picker!.value;\n    final hourIndex = _pattern.startsWith('a') ? 1 : 0;\n    final periodIndex = _pattern.startsWith('a') ? 0 : 2;\n\n    var hour = (indexes[hourIndex] * hourInterval) % (hours24 ? 24 : 12);\n    if (!hours24 && indexes[periodIndex].isOdd) {\n      hour += 12;\n    }\n\n    _value = FTime(hour, (indexes[hourIndex + 1] * minuteInterval) % 60);\n  }\n\n  FPickerController? get picker => _picker;\n\n  set picker(FPickerController? controller) => _picker = controller;\n\n  bool get mutating => _mutating;\n\n  String get pattern => _pattern;\n\n  set pattern(String value) => _pattern = value;\n\n  bool get hours24 => _hours24;\n\n  set hours24(bool value) => _hours24 = value;\n\n  int get hourInterval => _hourInterval;\n\n  set hourInterval(int value) => _hourInterval = value;\n\n  int get minuteInterval => _minuteInterval;\n\n  set minuteInterval(int value) => _minuteInterval = value;\n}\n"
    },
    "Toast": {
      "animated_toast": "import 'dart:async';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:sugar/collection.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/toast/animated_toaster.dart';\nimport 'package:forui/src/widgets/toast/animated_toaster_parent_data.dart';\nimport 'package:forui/src/widgets/toast/toaster_stack.dart';\n\n@internal\nclass AnimatedToast extends StatefulWidget {\n  /// The style.\n  final FToastStyle style;\n\n  /// A unit vector indicating how a toast's protrusion should be aligned to the toast in front of it.\n  ///\n  /// For example, `Offset(0, -1)` indicates that the top-center of this toast's protrusion should be aligned to the\n  /// top-center of the toast in front of it.\n  final Offset alignTransform;\n\n  /// The toast's index starting from the back.\n  final int index;\n\n  /// The total number of toasts.\n  final int length;\n\n  /// The directions which to swipe to dismiss the toast.\n  final List<AxisDirection> swipeToDismiss;\n\n  /// The toast's show duration.\n  final Duration? duration;\n\n  /// The expansion animation, between `[0, 1]`.\n  final double expand;\n\n  /// True if the toast is visible.\n  final bool visible;\n\n  /// True if the toast should be auto dismissed.\n  final bool autoDismiss;\n\n  /// A value that indicates whether a toast is current being swiping.\n  final ValueNotifier<Swipe> swiping;\n\n  /// A value that indicates whether the toast is dismissing.\n  final ValueListenable<bool> dismissing;\n\n  /// A callback that is called when the toast is closed.\n  final VoidCallback onDismiss;\n\n  /// The content.\n  final Widget child;\n\n  const AnimatedToast({\n    required this.style,\n    required this.alignTransform,\n    required this.index,\n    required this.length,\n    required this.swipeToDismiss,\n    required this.duration,\n    required this.expand,\n    required this.visible,\n    required this.autoDismiss,\n    required this.swiping,\n    required this.dismissing,\n    required this.onDismiss,\n    required this.child,\n    super.key,\n  });\n\n  @override\n  State<AnimatedToast> createState() => _AnimatedToastState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('alignTransform', alignTransform))\n      ..add(IntProperty('index', index))\n      ..add(IntProperty('length', length))\n      ..add(IterableProperty('swipeToDismiss', swipeToDismiss))\n      ..add(DiagnosticsProperty('duration', duration))\n      ..add(PercentProperty('expand', expand))\n      ..add(FlagProperty('visible', value: visible, ifTrue: 'visible'))\n      ..add(FlagProperty('autoDismiss', value: autoDismiss, ifTrue: 'autoDismiss'))\n      ..add(DiagnosticsProperty('swiping', swiping))\n      ..add(DiagnosticsProperty('dismissing', dismissing))\n      ..add(ObjectFlagProperty.has('onDismiss', onDismiss));\n  }\n}\n\nclass _AnimatedToastState extends State<AnimatedToast> with TickerProviderStateMixin {\n  static const _horizontal = [AxisDirection.left, AxisDirection.right];\n  static const _vertical = [AxisDirection.up, AxisDirection.down];\n\n  Timer? _timer;\n  late final AnimationController _entranceDismissController;\n  late final AnimationController _transitionController;\n  late final AnimationController _visibleController;\n  late final AnimationController _swipeCompletionController;\n  late CurvedAnimation _curvedEntranceDismiss;\n  late CurvedAnimation _transition;\n  late CurvedAnimation _visible;\n  late CurvedAnimation _swipeCompletion;\n  late Animation<double> _entranceDismiss;\n\n  /// The current offset of the toast when swiping, normalized as a fraction of the toast's height/width. It is always\n  /// in the range [-1, 1].\n  ///\n  /// If the toast is swiped to the left/top, it will be negative, and if it is swiped to the right/bottom, it will be\n  /// positive.\n  Offset _swipeFraction = Offset.zero;\n\n  /// The offset that the toast should be at when the swipe animation is completed.\n  Offset _swipeFractionEnd = Offset.zero;\n\n  /// Used to signal to [RenderAnimatedToaster] that a toast has been updated.\n  int _signal = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.dismissing.addListener(_startDismissing);\n    if (widget.dismissing.value) {\n      _entranceDismissController.value = 1;\n    }\n\n    if (widget.duration case final duration?) {\n      _timer = Timer(duration, _startDismissing);\n    }\n\n    _entranceDismissController =\n        AnimationController(\n            vsync: this,\n            duration: widget.style.motion.entranceDuration,\n            reverseDuration: widget.style.motion.dismissDuration,\n          )\n          ..forward()\n          ..addListener(() => setState(() {}))\n          ..addStatusListener(_dismiss);\n    _transitionController = AnimationController(vsync: this, duration: widget.style.motion.transitionDuration)\n      ..forward()\n      ..addListener(() => setState(() {}));\n    _visibleController =\n        AnimationController(\n            vsync: this,\n            duration: widget.style.motion.reentranceDuration,\n            reverseDuration: widget.style.motion.exitDuration,\n          )\n          ..value = widget.visible ? 1 : 0\n          ..addListener(() => setState(() {}));\n    _swipeCompletionController = AnimationController(vsync: this, duration: widget.style.motion.swipeCompletionDuration)\n      ..addListener(() => setState(() {}))\n      ..addStatusListener(_completeSwipe);\n\n    _curvedEntranceDismiss = CurvedAnimation(\n      parent: _entranceDismissController,\n      curve: widget.style.motion.entranceCurve,\n      reverseCurve: widget.style.motion.dismissCurve,\n    );\n    _transition = CurvedAnimation(parent: _transitionController, curve: widget.style.motion.transitionCurve);\n    _visible = CurvedAnimation(\n      parent: _visibleController,\n      curve: widget.style.motion.reentranceCurve,\n      reverseCurve: widget.style.motion.exitCurve,\n    );\n    _swipeCompletion = CurvedAnimation(\n      parent: _swipeCompletionController,\n      curve: widget.style.motion.swipeCompletionCurve,\n    );\n    _entranceDismiss = widget.style.motion.entranceDismissFadeTween.animate(_curvedEntranceDismiss);\n  }\n\n  @override\n  void didUpdateWidget(AnimatedToast old) {\n    super.didUpdateWidget(old);\n    if (widget.dismissing != old.dismissing) {\n      old.dismissing.removeListener(_startDismissing);\n      widget.dismissing.addListener(_startDismissing);\n    }\n\n    if (widget.style != old.style) {\n      _entranceDismissController\n        ..duration = widget.style.motion.entranceDuration\n        ..reverseDuration = widget.style.motion.dismissDuration;\n      _transitionController\n        ..duration = widget.style.motion.reentranceDuration\n        ..reverseDuration = widget.style.motion.exitDuration;\n\n      _curvedEntranceDismiss = CurvedAnimation(\n        parent: _entranceDismissController,\n        curve: widget.style.motion.entranceCurve,\n        reverseCurve: widget.style.motion.dismissCurve,\n      );\n      _transition = CurvedAnimation(\n        parent: _transitionController,\n        curve: widget.style.motion.reentranceCurve,\n        reverseCurve: widget.style.motion.exitCurve,\n      );\n\n      _entranceDismiss = widget.style.motion.entranceDismissFadeTween.animate(_curvedEntranceDismiss);\n\n      _signal++;\n    }\n\n    if (widget.index != old.index) {\n      _transitionController\n        ..reset()\n        ..forward();\n      _signal++;\n    }\n\n    if (widget.autoDismiss != old.autoDismiss) {\n      if (widget.autoDismiss) {\n        _resumeDismissing(Duration(milliseconds: (widget.length - widget.index - 1) * 300));\n      } else {\n        _timer?.cancel();\n      }\n    }\n\n    if (widget.visible != old.visible) {\n      widget.visible ? _visibleController.forward() : _visibleController.reverse();\n    }\n  }\n\n  void _completeSwipe(AnimationStatus status) {\n    if (status == AnimationStatus.completed) {\n      // Reset the swipe fraction to zero if the swipe was not completed.\n      if (_swipeFractionEnd == Offset.zero) {\n        setState(() {\n          _swipeFraction = Offset.zero;\n          _swipeCompletionController.reset();\n          _resumeDismissing();\n        });\n      } else {\n        // If the swipe was completed, we need to dismiss the toast.\n        widget.onDismiss();\n      }\n    }\n  }\n\n  void _startDismissing() => _entranceDismissController.reverse();\n\n  void _resumeDismissing([Duration stagger = Duration.zero]) {\n    if (widget.duration case final duration?) {\n      _timer?.cancel();\n      _timer = Timer(duration + stagger, _startDismissing);\n    }\n  }\n\n  void _dismiss(AnimationStatus status) {\n    if (status == AnimationStatus.dismissed) {\n      widget.onDismiss();\n    }\n  }\n\n  @override\n  void dispose() {\n    widget.dismissing.removeListener(_startDismissing);\n    _swipeCompletion.dispose();\n    _swipeCompletionController.dispose();\n    _visible.dispose();\n    _visibleController.dispose();\n    _transition.dispose();\n    _transitionController.dispose();\n    _curvedEntranceDismiss.dispose();\n    _entranceDismissController.dispose();\n    _timer?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Slide in & out during entrance & exit.\n    var translation = -widget.alignTransform * (1.0 - _curvedEntranceDismiss.value);\n    // Slide out during swiping to dismiss.\n    translation += Offset.lerp(_swipeFraction, _swipeFractionEnd, _swipeCompletion.value)!;\n\n    // Gradually increase & decrease opacity during entrance & exit.\n    var opacity = _entranceDismiss.value * _visible.value;\n    // Gradually decrease opacity during swiping to dismiss.\n    opacity *= 1 - _swipeFraction.distance.abs();\n\n    return AnimatedToastData(\n      index: widget.index,\n      transition: _transition.value,\n      visible: widget.visible,\n      signal: _signal,\n      child: IgnorePointer(\n        ignoring: !widget.visible,\n        child: ConstrainedBox(\n          constraints: widget.style.constraints,\n          child: MouseRegion(\n            onEnter: (_) => _timer?.cancel(),\n            onExit: (_) {\n              if (widget.autoDismiss) {\n                _resumeDismissing();\n              }\n            },\n            child: GestureDetector(\n              onHorizontalDragStart: (_) {\n                if (!disjoint(widget.swipeToDismiss, _horizontal)) {\n                  _timer?.cancel();\n                  widget.swiping.value = widget.swiping.value.start();\n                }\n              },\n              onHorizontalDragUpdate: (details) {\n                if (widget.swipeToDismiss.contains(AxisDirection.left)) {\n                  setState(() {\n                    final offset = _swipeFraction + Offset(details.primaryDelta! / context.size!.width, 0);\n                    _swipeFraction = Offset(offset.dx.clamp(-1.1, 0.05), offset.dy);\n                  });\n                } else if (widget.swipeToDismiss.contains(AxisDirection.right)) {\n                  setState(() {\n                    final offset = _swipeFraction + Offset(details.primaryDelta! / context.size!.width, 0);\n                    _swipeFraction = Offset(offset.dx.clamp(-0.05, 1.1), offset.dy);\n                  });\n                }\n              },\n              onHorizontalDragEnd: (_) {\n                if (!disjoint(widget.swipeToDismiss, _horizontal)) {\n                  _swipeFractionEnd = switch (_swipeFraction.dx) {\n                    < -0.5 => const Offset(-1, 0),\n                    > 0.5 => const Offset(1, 0),\n                    _ => Offset.zero,\n                  };\n                  _swipeCompletionController.forward();\n                  widget.swiping.value = widget.swiping.value.end();\n                }\n              },\n              onVerticalDragStart: (_) {\n                if (!disjoint(widget.swipeToDismiss, _vertical)) {\n                  _timer?.cancel();\n                  widget.swiping.value = widget.swiping.value.start();\n                }\n              },\n              onVerticalDragUpdate: (details) {\n                if (widget.swipeToDismiss.contains(AxisDirection.up)) {\n                  setState(() {\n                    final offset = _swipeFraction + Offset(0, details.primaryDelta! / context.size!.height);\n                    _swipeFraction = Offset(offset.dx, offset.dy.clamp(-1.1, 0.05));\n                  });\n                } else if (widget.swipeToDismiss.contains(AxisDirection.down)) {\n                  setState(() {\n                    final offset = _swipeFraction + Offset(0, details.primaryDelta! / context.size!.height);\n                    _swipeFraction = Offset(offset.dx, offset.dy.clamp(-0.05, 1.1));\n                  });\n                }\n              },\n              onVerticalDragEnd: (_) {\n                if (!disjoint(widget.swipeToDismiss, _vertical)) {\n                  _swipeFractionEnd = switch (_swipeFraction.dy) {\n                    < -0.5 => const Offset(0, -1),\n                    > 0.5 => const Offset(0, 1),\n                    _ => Offset.zero,\n                  };\n                  _swipeCompletionController.forward();\n                  widget.swiping.value = widget.swiping.value.end();\n                }\n              },\n              child: FractionalTranslation(\n                translation: translation,\n                child: Opacity(opacity: opacity.clamp(0, 1), child: widget.child),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
      "animated_toaster": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/toast/animated_toaster_parent_data.dart';\n\n/// The [AnimatedToaster] that is responsible for coordinating the animation, layout and painting of toasts.\n@internal\nclass AnimatedToaster extends MultiChildRenderObjectWidget {\n  /// The toaster's style.\n  final FToasterStyle style;\n\n  /// A unit vector indicating how a toasts should be aligned to the front-most toast when expanded\n  ///\n  /// For example, `Offset(1, 0)` indicates that all toasts ahould be aligned to the right edge.\n  final Offset expandedAlignTransform;\n\n  /// A unit vector indicating how a toast's protrusion should be aligned to the toast in front of it.\n  ///\n  /// For example, `Offset(0, -1)` indicates that the top-center of this toast's protrusion should be aligned to the\n  /// top-center of the toast in front of it.\n  final Offset collapsedAlignTransform;\n\n  /// The expansion's animation value between `[0, 1]`.\n  final double expand;\n\n  const AnimatedToaster({\n    required this.style,\n    required this.expandedAlignTransform,\n    required this.collapsedAlignTransform,\n    required this.expand,\n    super.children,\n    super.key,\n  });\n\n  @override\n  RenderObject createRenderObject(BuildContext context) => RenderAnimatedToaster(\n    style: style,\n    expandedAlignTransform: expandedAlignTransform,\n    collapsedAlignTransform: collapsedAlignTransform,\n    expand: expand,\n  );\n\n  @override\n  void updateRenderObject(BuildContext context, covariant RenderAnimatedToaster renderObject) => renderObject\n    ..style = style\n    ..expandedAlignTransform = expandedAlignTransform\n    ..collapsedAlignTransform = collapsedAlignTransform\n    ..expand = expand;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('expandedAlignTransform', expandedAlignTransform))\n      ..add(DiagnosticsProperty('collapsedAlignTransform', collapsedAlignTransform))\n      ..add(PercentProperty('expand', expand));\n  }\n}\n\n@internal\nclass RenderAnimatedToaster extends RenderBox\n    with\n        ContainerRenderObjectMixin<RenderBox, AnimatedToasterParentData>,\n        RenderBoxContainerDefaultsMixin<RenderBox, AnimatedToasterParentData> {\n  FToasterStyle _style;\n  Offset _expandedAlignTransform;\n  Offset _collapsedAlignTransform;\n  double _expand;\n\n  /// Creates a [RenderAnimatedToaster].\n  RenderAnimatedToaster({\n    required FToasterStyle style,\n    required Offset expandedAlignTransform,\n    required Offset collapsedAlignTransform,\n    required double expand,\n  }) : _style = style,\n       _expandedAlignTransform = expandedAlignTransform,\n       _collapsedAlignTransform = collapsedAlignTransform,\n       _expand = expand;\n\n  @override\n  void setupParentData(RenderBox child) {\n    if (child.parentData is! AnimatedToasterParentData) {\n      child.parentData = AnimatedToasterParentData();\n    }\n  }\n\n  /// Performs the layout of all toast children, handling both collapsed and expanded states.\n  ///\n  /// Terminology:\n  /// * \"Previous front toast\" - The toast that was at the front before the current front toast.\n  ///\n  /// This method orchestrates a complex two-phase layout process:\n  ///\n  /// **Phase 1: Calculate vertical positioning and spacing**\n  /// - Iterates through toasts from back to front (lastChild to firstChild)\n  /// - Calculates accumulated heights for proper vertical stacking\n  /// - Handles different alignment modes (top-aligned vs bottom-aligned toasts)\n  /// - Computes smooth transitions between collapsed and expanded positions\n  /// - Maintains separate tracking for visible vs all toasts to handle proper spacing\n  ///\n  /// **Phase 2: Calculate final positions and container size**\n  /// - Transitions between previous front toast and current front toast sizes\n  /// - Interpolates between collapsed size (based on front toast) and expanded size (includes all visible toast heights)\n  /// - Applies horizontal alignment transformations (left/center/right positioning)\n  /// - Sets final offsets for each toast child\n  @override\n  void performLayout() {\n    if (childCount == 0) {\n      size = constraints.smallest;\n      return;\n    }\n\n    var current = lastChild;\n    var previousHeight = 0.0;\n\n    // We track the accumulated & visible accumulated heights separately so that the toaster will be displayed correctly\n    // when expanded & the toasts will not occupy more space than available.\n    var accumulated = collapsedAlignTransform.dy * style.expandStartSpacing;\n    var visibleAccumulated = collapsedAlignTransform.dy * style.expandStartSpacing;\n\n    // Phase 1: calculate the offset to move the toasts when expanded, relative to (0, 0).\n    //\n    // This is a simplified implementation that assumes toasts can only be vertically stacked.\n    // I'm not doing this for every possible alignment. You're welcome to open a PR if you want it. >:(\n    while (current != null) {\n      final data = current.parentData! as AnimatedToasterParentData;\n      current.layout(constraints, parentUsesSize: true);\n\n      if (_collapsedAlignTransform.dy < 0) {\n        // Calculate the additional offset to move the current toast when expanded.\n        // Top aligned toasts use the current height as the offset.\n        final iterationHeight = current == lastChild ? 0.0 : -current.size.height;\n        accumulated += iterationHeight;\n        if (data.visible) {\n          visibleAccumulated += iterationHeight;\n        }\n\n        // Top aligned toasts' origins are affected by the previous front toast and not the current front toast. This is\n        // because toasts stack downward from the origin, so each toast's position depends on the height of the toast\n        // above it.\n        final affectingHeight = current == lastChild ? 0.0 : childBefore(lastChild!)!.size.height;\n        final begin = data.shift.begin ??= accumulated + affectingHeight;\n        final end = data.shift.end ??= accumulated;\n        final value = data.shift.value = lerpDouble(begin, end, data.transition)! * expand;\n\n        data.offset = Offset(data.offset.dx, value);\n      } else {\n        // Calculate the additional offset to move the current toast when expanded.\n        // Bottom aligned toasts use the height of the toast in front as the offset.\n        final iterationHeight = previousHeight;\n        accumulated += iterationHeight;\n        if (data.visible) {\n          visibleAccumulated += iterationHeight;\n        }\n\n        final front = current == lastChild ? Size.zero : lastChild!.size;\n        final begin = data.shift.begin ??=\n            accumulated - collapsedAlignTransform.dy * style.expandSpacing - front.height;\n        final end = data.shift.end ??= accumulated;\n        final value = data.shift.value = lerpDouble(begin, end, data.transition)! * expand;\n\n        data.offset = Offset(data.offset.dx, value);\n      }\n\n      accumulated += collapsedAlignTransform.dy * style.expandSpacing;\n      if (data.visible) {\n        visibleAccumulated += collapsedAlignTransform.dy * style.expandSpacing;\n      }\n\n      previousHeight = current.size.height;\n      current = data.previousSibling;\n    }\n\n    // Phase 2:\n    // Transition between previous front and front toast if their sizes are different.\n    final front = lastChild!;\n    final data = front.parentData! as AnimatedToasterParentData;\n\n    final Size previousFrontSize;\n    if (childCount >= 2) {\n      // Save the front toast's size as the previous front toast.\n      // Allows us to properly transition when there is only 1 remaining toast after the front toast is removed.\n      final previous = childBefore(lastChild!)!;\n      previousFrontSize = previous.size;\n      (previous.parentData! as AnimatedToasterParentData).collapsedUntransformedSize = front.size;\n    } else {\n      previousFrontSize = data.collapsedUntransformedSize ?? front.size;\n    }\n\n    // Transition between collapsed and expanded sizes.\n    final collapsedSize = Size.lerp(previousFrontSize, front.size, data.transition)!;\n\n    final baseHeight = collapsedAlignTransform.dy.isNegative ? front.size.height : firstChild!.size.height;\n    final expandedSize = Size(front.size.width, baseHeight + visibleAccumulated.abs());\n\n    size = constraints.constrain(Size.lerp(collapsedSize, expandedSize, expand * data.transition)!);\n\n    final translateY = visibleAccumulated.isNegative ? -visibleAccumulated * data.transition * expand : 0.0;\n    var child = firstChild;\n    while (child != null) {\n      final data = child.parentData! as AnimatedToasterParentData;\n      // Horizontally aligns the toast to the left, center or right based on [expandedAlignTransform].\n      final translateX =\n          data.transition *\n          expand *\n          switch (expandedAlignTransform.dx) {\n            -1 => 0,\n            0 => (size.width - child.size.width) / 2,\n            _ => size.width - child.size.width,\n          };\n\n      data.offset = Offset(translateX, data.offset.dy + translateY);\n\n      child = data.nextSibling;\n    }\n  }\n\n  /// Scales and aligns toasts before painting them.\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    if (childCount == 0) {\n      return;\n    }\n\n    // We assume the toast's size at the front is the target.\n    final front = lastChild!.size;\n\n    var current = firstChild;\n    while (current != null) {\n      final data = current.parentData! as AnimatedToasterParentData;\n      if (current.size.isEmpty) {\n        current = data.nextSibling;\n        continue;\n      }\n\n      // The following section is responsible for scaling the toast to match the size of the frontmost toast.\n\n      // Each consecutive toast should be slightly smaller.\n      final target = data.scale.end ??= front * pow(style.collapsedScale, data.index.current).toDouble();\n\n      // Calculate base scaling factors from current size to target size.\n      final currentSize = data.scale.begin ??= current.size;\n\n      final baseWidth = lerpDouble(currentSize.width, target.width, data.transition)!;\n      final baseHeight = lerpDouble(currentSize.height, target.height, data.transition)!;\n      data.scale.value = Size(baseWidth, baseHeight);\n\n      final baseScaleX = baseWidth / current.size.width;\n      final baseScaleY = baseHeight / current.size.height;\n\n      // Interpolate between the base scale and 1.0 based on expand\n      // When expand is 1.0, we use a scale of 1.0 (no scaling)\n      // When expand is 0.0, we use the base scale calculation\n      final scaleX = lerpDouble(baseScaleX, 1.0, expand)!;\n      final scaleY = lerpDouble(baseScaleY, 1.0, expand)!;\n\n      // The following section is responsible for translating the toast to the correct position.\n\n      // Calculate the reference points (point of alignment).\n      // This is a simplified implementation that assumes toasts are vertically stacked either on top or below another\n      // toast and never purely horizontal.\n      final frontX = front.width * (0.5 + collapsedAlignTransform.dx * 0.5);\n      final frontY = collapsedAlignTransform.dy < 0 ? 0.0 : front.height;\n      final thisX = (current.size.width * scaleX) * (0.5 + collapsedAlignTransform.dx * 0.5);\n      final thisY = collapsedAlignTransform.dy < 0 ? 0.0 : (current.size.height * scaleY);\n\n      final alignmentBegin = data.alignment.begin ??= Offset.zero;\n      // We don't set data.alignment.end as this constantly changes.\n      final alignmentEnd = Offset(frontX - thisX, frontY - thisY);\n      final alignment = data.alignment.value = Offset.lerp(alignmentBegin, alignmentEnd, data.transition)!;\n\n      // Calculate the amount to shift the toast such that it protrudes slightly above the toast in front.\n      final begin = data.protrusion.begin ??= style.collapsedProtrusion * (log(data.index.previous + 1) / log(2));\n      final end = data.protrusion.end ??= style.collapsedProtrusion * (log(data.index.current + 1) / log(2));\n      final protrusion = data.protrusion.value = lerpDouble(begin, end, data.transition)!;\n\n      context.pushTransform(\n        needsCompositing,\n        data.offset + offset + (alignment + collapsedAlignTransform * protrusion) * (1 - expand),\n        Matrix4.diagonal3Values(scaleX, scaleY, 1.0),\n        (context, offset) => context.paintChild(current!, offset),\n      );\n\n      current = data.nextSibling;\n    }\n  }\n\n  @override\n  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) =>\n      defaultHitTestChildren(result, position: position);\n\n  FToasterStyle get style => _style;\n\n  set style(FToasterStyle value) {\n    if (_style == value) {\n      return;\n    }\n\n    _style = value;\n    markNeedsLayout();\n  }\n\n  Offset get expandedAlignTransform => _expandedAlignTransform;\n\n  set expandedAlignTransform(Offset value) {\n    if (_expandedAlignTransform == value) {\n      return;\n    }\n\n    _expandedAlignTransform = value;\n    markNeedsLayout();\n  }\n\n  Offset get collapsedAlignTransform => _collapsedAlignTransform;\n\n  set collapsedAlignTransform(Offset value) {\n    if (_collapsedAlignTransform == value) {\n      return;\n    }\n\n    _collapsedAlignTransform = value;\n    markNeedsLayout();\n  }\n\n  double get expand => _expand;\n\n  set expand(double value) {\n    if (_expand == value) {\n      return;\n    }\n\n    _expand = value;\n    markNeedsLayout();\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DoubleProperty('expand', expand))\n      ..add(DiagnosticsProperty('expandedAlignTransform', expandedAlignTransform))\n      ..add(DiagnosticsProperty('collapsedAlignTransform', collapsedAlignTransform));\n  }\n}\n",
      "animated_toaster_parent_data": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/src/widgets/toast/animated_toaster.dart';\n\n@internal\nclass AnimatedToastData extends ParentDataWidget<AnimatedToasterParentData> {\n  /// The index.\n  final int index;\n\n  /// The transition between different indexes.\n  final double transition;\n\n  /// True if visible.\n  final bool visible;\n\n  /// The signal to indicate that a widget update has occurred.\n  final int signal;\n\n  const AnimatedToastData({\n    required this.index,\n    required this.transition,\n    required this.visible,\n    required this.signal,\n    required super.child,\n    super.key,\n  });\n\n  @override\n  void applyParentData(RenderObject renderObject) {\n    assert(\n      renderObject.parentData is AnimatedToasterParentData,\n      'Parent data must be of type AnimatedToasterParentData',\n    );\n\n    final data = renderObject.parentData! as AnimatedToasterParentData;\n    var needsLayout = false;\n\n    if (data.index.current != index) {\n      data.index = (previous: data.index.current, current: index);\n      needsLayout = true;\n    }\n\n    if (data.transition != transition) {\n      data.transition = transition;\n      needsLayout = true;\n    }\n\n    if (data.visible != visible) {\n      data.visible = visible;\n      needsLayout = true;\n    }\n\n    if (data._signal != signal) {\n      data.signal = signal;\n      needsLayout = true;\n    }\n\n    if (needsLayout) {\n      renderObject.markNeedsLayout();\n    }\n  }\n\n  @override\n  Type get debugTypicalAncestorWidgetClass => AnimatedToaster;\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('index', index.toString()))\n      ..add(DoubleProperty('transition', transition))\n      ..add(DiagnosticsProperty('visible', visible))\n      ..add(IntProperty('signal', signal));\n  }\n}\n\n/// Parent data for use with [RenderAnimatedToaster].\n@internal\nclass AnimatedToasterParentData extends ContainerBoxParentData<RenderBox> {\n  final AnimationTween<Size> scale = AnimationTween.size();\n\n  final AnimationTween<Offset> alignment = AnimationTween.offset();\n\n  final AnimationTween<double> shift = AnimationTween.of();\n\n  final AnimationTween<double> protrusion = AnimationTween.of();\n\n  /// The index of the child.\n  ({int previous, int current}) index = (previous: 0, current: 0);\n\n  Size? collapsedUntransformedSize;\n\n  /// The transition between different indexes.\n  double transition = 0.0;\n\n  /// True if visible.\n  bool visible = true;\n\n  int _signal = 0;\n\n  int get signal => _signal;\n\n  set signal(int value) {\n    _signal = value;\n    scale.mark();\n    alignment.mark();\n    shift.mark();\n    protrusion.mark();\n  }\n}\n\n/// This preserves a widget's animation across rebuilds, preventing an animation from restarting from scratch when an\n/// rebuild occurs mid animation.\n@internal\nclass AnimationTween<T> {\n  static const epsilon = 1e-6;\n\n  static bool _offset(Offset a, Offset b) => (a.dx - b.dx).abs() < epsilon && (a.dy - b.dy).abs() < epsilon;\n\n  static bool _size(Size a, Size b) => (a.width - b.width).abs() < epsilon && (a.height - b.height).abs() < epsilon;\n\n  T? begin;\n  T? end;\n  T? _value;\n  final bool Function(T, T) _equal;\n\n  static AnimationTween<double> of({double? begin, double? end}) =>\n      AnimationTween<double>(equal: (a, b) => (a - b).abs() < epsilon, begin: begin, end: end);\n\n  static AnimationTween<Offset> offset({Offset? begin, Offset? end}) =>\n      AnimationTween<Offset>(equal: _offset, begin: begin, end: end);\n\n  static AnimationTween<Size> size({Size? begin, Size? end}) =>\n      AnimationTween<Size>(equal: _size, begin: begin, end: end);\n\n  AnimationTween({required bool Function(T, T) equal, this.begin, this.end}) : _equal = equal;\n\n  void mark() {\n    begin = value;\n    end = null;\n  }\n\n  T? get value => _value ??= begin;\n\n  set value(T? value) {\n    _value = value;\n    if (value != null && end != null && _equal(value, end as T)) {\n      begin = end;\n      end = null;\n    }\n  }\n}\n",
      "toast": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\n\n/// A toast.\n///\n/// See:\n/// * https://forui.dev/docs/overlay/toast for working examples.\n/// * [showFToast] for displaying a toast.\n/// * [FToasterStyle] for customizing a toaster's appearance.\n/// * [FToastStyle] for customizing a toast's appearance.\nclass FToast extends StatelessWidget {\n  /// The toast's style.\n  final FToastStyle Function(FToastStyle style)? style;\n\n  /// An optional icon aligned to the start of the toast (left in LTR locales).\n  final Widget? icon;\n\n  /// The toast's title. Defaults to a maximum of 100 lines. Set [Text.maxLines] to change this.\n  final Widget title;\n\n  /// The toast's description. Defaults to a maximum of 100 lines. Set [Text.maxLines] to change this.\n  final Widget? description;\n\n  /// An optional widget aligned to the end of the toast (left in LTR locales).\n  final Widget? suffix;\n\n  /// Creates a [FToast].\n  const FToast({required this.title, this.style, this.icon, this.description, this.suffix, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final style = this.style?.call(context.theme.toasterStyle.toastStyle) ?? context.theme.toasterStyle.toastStyle;\n    Widget toast = DecoratedBox(\n      decoration: style.decoration,\n      child: Padding(\n        padding: style.padding,\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            if (icon case final icon?) ...[\n              IconTheme(data: style.iconStyle, child: icon),\n              SizedBox(width: style.iconSpacing),\n            ],\n            Flexible(\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                mainAxisSize: MainAxisSize.min,\n                spacing: style.titleSpacing,\n                children: [\n                  DefaultTextStyle(style: style.titleTextStyle, maxLines: 100, child: title),\n                  if (description case final description?)\n                    DefaultTextStyle(style: style.descriptionTextStyle, maxLines: 100, child: description),\n                ],\n              ),\n            ),\n            if (suffix case final suffix?) ...[SizedBox(width: style.suffixSpacing), suffix],\n          ],\n        ),\n      ),\n    );\n\n    if (style.backgroundFilter case final background?) {\n      toast = Stack(\n        children: [\n          Positioned.fill(\n            child: ClipRect(\n              child: BackdropFilter(filter: background, child: Container()),\n            ),\n          ),\n          toast,\n        ],\n      );\n    }\n\n    return toast;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n",
      "toaster": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/toast/toaster_stack.dart';\n\n/// Displays a [FToast] in a toaster.\n///\n/// [alignment] defaults to [FToasterStyle.toastAlignment].\n///\n/// [swipeToDismiss] represents axes in which to swipe to dismiss a toast. Defaults to horizontally towards the closest\n/// edge of the screen with a left bias. For example, if [alignment] is [FToastAlignment.bottomRight], the default swipe\n/// direction is [AxisDirection.right].\n///\n/// Set [swipeToDismiss] to an empty list to disable swiping to dismiss.\n///\n/// [duration] controls the duration which the toast is shown. Defaults to 5 seconds. Set [duration] to null to disable\n/// auto-dismissing.\n///\n/// ## Contract\n/// Throws [FlutterError] if there is no ancestor [FToaster] in the given [context].\n///\n/// See:\n/// * https://forui.dev/docs/overlay/toast for working examples.\n/// * [showFToast] for displaying a toast in a toaster.\n/// * [FToasterStyle] for customizing a toaster's appearance.\n/// * [FToastStyle] for customizing a toast's appearance.\nFToasterEntry showFToast({\n  required BuildContext context,\n  required Widget title,\n  FToastStyle Function(FToastStyle style)? style,\n  Widget? icon,\n  Widget? description,\n  Widget Function(BuildContext context, FToasterEntry entry)? suffixBuilder,\n  FToastAlignment? alignment,\n  List<AxisDirection>? swipeToDismiss,\n  Duration? duration = const Duration(seconds: 5),\n  VoidCallback? onDismiss,\n}) {\n  final state = context.findAncestorStateOfType<FToasterState>();\n  if (state == null) {\n    throw FlutterError.fromParts([\n      ErrorSummary('showFToast(...) called with a context that does not contain a FToaster/FScaffold.'),\n      ErrorDescription(\n        'No FToaster/FScaffold ancestor could be found starting from the context that was passed to FToaster/FScaffold.of(). '\n        'This usually happens when the context provided is from the same StatefulWidget as that whose build function '\n        'actually creates the FToaster/FScaffold widget being sought.',\n      ),\n      ErrorHint(\n        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\n        'context that is \"under\" the FToaster/FScaffold.',\n      ),\n      context.describeElement('The context used was'),\n    ]);\n  }\n\n  return state.show(\n    context: context,\n    builder: (context, entry) => FToast(\n      style: style,\n      icon: icon,\n      title: title,\n      description: description,\n      suffix: suffixBuilder?.call(context, entry),\n    ),\n    style: style,\n    alignment: alignment,\n    swipeToDismiss: swipeToDismiss,\n    duration: duration,\n    onDismiss: onDismiss,\n  );\n}\n\n/// Displays a raw toast in a toaster.\n///\n/// [alignment] defaults to [FToasterStyle.toastAlignment].\n///\n/// [swipeToDismiss] represents axes in which to swipe to dismiss a toast. Defaults to horizontally towards the closest\n/// edge of the screen with a left bias. For example, if [alignment] is [FToastAlignment.bottomRight], the default swipe\n/// direction is [AxisDirection.right].\n///\n/// Set [swipeToDismiss] to an empty list to disable swiping to dismiss.\n///\n/// [duration] controls the duration which the toast is shown. Defaults to 5 seconds. Set [duration] to null to disable\n/// auto-closing.\n///\n/// ## Contract\n/// Throws [FlutterError] if there is no ancestor [FToaster] in the given [context].\n///\n/// See:\n/// * https://forui.dev/docs/overlay/toast for working examples.\n/// * [showFToast] for displaying a toast in a toaster.\n/// * [FToasterStyle] for customizing a toaster's appearance.\n/// * [FToastStyle] for customizing a toast's appearance.\nFToasterEntry showRawFToast({\n  required BuildContext context,\n  required Widget Function(BuildContext context, FToasterEntry entry) builder,\n  FToastStyle Function(FToastStyle style)? style,\n  FToastAlignment? alignment,\n  List<AxisDirection>? swipeToDismiss,\n  Duration? duration = const Duration(seconds: 5),\n  VoidCallback? onDismiss,\n}) {\n  final state = context.findAncestorStateOfType<FToasterState>();\n  if (state == null) {\n    throw FlutterError.fromParts([\n      ErrorSummary('showRawFToast(...) called with a context that does not contain a FToaster/FScaffold.'),\n      ErrorDescription(\n        'No FToaster/FScaffold ancestor could be found starting from the context that was passed to FToaster/FScaffold.of(). '\n        'This usually happens when the context provided is from the same StatefulWidget as that whose build function '\n        'actually creates the FToaster/FScaffold widget being sought.',\n      ),\n      ErrorHint(\n        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\n        'context that is \"under\" the FToaster/FScaffold.',\n      ),\n      context.describeElement('The context used was'),\n    ]);\n  }\n\n  return state.show(\n    context: context,\n    builder: builder,\n    style: style,\n    alignment: alignment,\n    swipeToDismiss: swipeToDismiss,\n    duration: duration,\n    onDismiss: onDismiss,\n  );\n}\n\n/// The toast's alignment.\nenum FToastAlignment {\n  /// Aligns the toasts to the top start of the screen, depending on the locale's text direction.\n  ///\n  /// Top left in LTR locales, top right in RTL locales.\n  topStart(AlignmentDirectional.topStart, Alignment.bottomCenter),\n\n  /// Aligns the toasts to the start of the screen, depending on the locale's text direction.\n  ///\n  /// Top right in LTR locales, top left in RTL locales.\n  topEnd(AlignmentDirectional.topEnd, Alignment.bottomCenter),\n\n  /// Aligns the toasts to the top left of the screen.\n  topLeft(Alignment.topLeft, Alignment.bottomCenter),\n\n  /// Aligns the toasts to the top right of the screen.\n  topRight(Alignment.topRight, Alignment.bottomCenter),\n\n  /// Aligns the toasts to the top center of the screen.\n  topCenter(Alignment.topCenter, Alignment.bottomCenter),\n\n  /// Aligns the toasts to the bottom start of the screen, depending on the locale's text direction.\n  ///\n  /// Bottom left in LTR locales, bottom right in RTL locales.\n  bottomStart(AlignmentDirectional.bottomStart, Alignment.topCenter),\n\n  /// Aligns the toasts to the bottom end of the screen, depending on the locale's text direction.\n  ///\n  /// Bottom right in LTR locales, bottom right in RTL locales.\n  bottomEnd(AlignmentDirectional.bottomEnd, Alignment.topCenter),\n\n  /// Aligns the toasts to the bottom left of the screen.\n  bottomLeft(Alignment.bottomLeft, Alignment.topCenter),\n\n  /// Aligns the toasts to the bottom right of the screen.\n  bottomRight(Alignment.bottomRight, Alignment.topCenter),\n\n  /// Aligns the toasts to the bottom center of the screen.\n  bottomCenter(Alignment.bottomCenter, Alignment.topCenter);\n\n  final AlignmentGeometry _alignment;\n  final Alignment _toastAlignment;\n\n  const FToastAlignment(this._alignment, this._toastAlignment);\n}\n\n/// An opinionated toast widget.\n///\n/// This widget manages a stack of toasts that can be added to using [showRawFToast]. It should be placed near the root\n/// of the widget tree. It is included in [FScaffold] by default.\n///\n/// See:\n/// * https://forui.dev/docs/overlay/toaster for working examples.\n/// * [showFToast] for displaying a toast in a toaster.\n/// * [showRawFToast] for displaying a raw toast in a toaster.\n/// * [FToasterStyle] for customizing a toaster's appearance.\nclass FToaster extends StatefulWidget {\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  static FToasterState of(BuildContext context) => context.findAncestorStateOfType<FToasterState>()!;\n\n  /// The style.\n  final FToasterStyle Function(FToasterStyle style)? style;\n\n  /// The child.\n  final Widget child;\n\n  /// Creates a [FToaster] widget.\n  const FToaster({required this.child, this.style, super.key});\n\n  @override\n  State<FToaster> createState() => FToasterState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty('style', style));\n  }\n}\n\n/// A [FToaster]'s state.\nclass FToasterState extends State<FToaster> {\n  final Map<Alignment, (Alignment, List<ToasterEntry>)> _entries = {};\n\n  /// Displays a toast in this toaster.\n  ///\n  /// It is generally recommend to use [showFToast] or [showRawFToast] instead.\n  ///\n  /// See [showRawFToast] for more information about the parameters.\n  FToasterEntry show({\n    required Widget Function(BuildContext context, FToasterEntry entry) builder,\n    BuildContext? context,\n    FToastStyle Function(FToastStyle style)? style,\n    FToastAlignment? alignment,\n    List<AxisDirection>? swipeToDismiss,\n    Duration? duration = const Duration(seconds: 5),\n    VoidCallback? onDismiss,\n  }) {\n    context ??= this.context;\n\n    final direction = Directionality.maybeOf(context) ?? TextDirection.ltr;\n    final toasterStyle = widget.style?.call(context.theme.toasterStyle) ?? context.theme.toasterStyle;\n    final resolved = (alignment ?? toasterStyle.toastAlignment)._alignment.resolve(direction);\n    final directions = swipeToDismiss ?? [if (resolved.x < 1) AxisDirection.left else AxisDirection.right];\n\n    final entry = ToasterEntry(\n      style?.call(toasterStyle.toastStyle) ?? toasterStyle.toastStyle,\n      resolved,\n      directions,\n      duration,\n      builder,\n    );\n    entry.onDismiss = () {\n      entry.dismissing.value = true;\n      _remove(entry);\n      onDismiss?.call();\n    };\n\n    if (!mounted) {\n      return entry;\n    }\n\n    setState(() {\n      final (_, entries) = _entries[resolved] ??= ((alignment ?? toasterStyle.toastAlignment)._toastAlignment, []);\n      entries.add(entry);\n    });\n\n    return entry;\n  }\n\n  void _remove(ToasterEntry entry) {\n    if (!mounted) {\n      return;\n    }\n\n    final direction = Directionality.maybeOf(context) ?? TextDirection.ltr;\n    if (_entries[entry.alignment.resolve(direction)]?.$2 case final entries?) {\n      setState(() {\n        entries.remove(entry);\n        entry.dismissing.dispose();\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    for (final MapEntry(value: entries) in _entries.entries) {\n      for (final entry in entries.$2) {\n        entry.dismissing.dispose();\n      }\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final style = widget.style?.call(context.theme.toasterStyle) ?? context.theme.toasterStyle;\n    final children = [widget.child];\n\n    for (final MapEntry(key: alignment, value: (toastAlignment, entries)) in _entries.entries) {\n      children.add(\n        Positioned.fill(\n          child: SafeArea(\n            child: Padding(\n              padding: style.padding,\n              child: Align(\n                alignment: alignment,\n                child: ToasterStack(\n                  style: style,\n                  expandedAlignTransform: Offset(alignment.x, alignment.y),\n                  collapsedAlignTransform: Offset(toastAlignment.x, toastAlignment.y),\n                  entries: entries,\n                ),\n              ),\n            ),\n          ),\n        ),\n      );\n    }\n\n    return Stack(clipBehavior: Clip.none, fit: StackFit.passthrough, children: children);\n  }\n}\n\n/// An entry in a toaster.\nmixin FToasterEntry {\n  /// Dismisses the toast. Does nothing if the toast is already being dismissed or dismissed.\n  void dismiss();\n\n  /// True if the toast is currently displayed and not being dismissed.\n  bool get showing;\n}\n\n@internal\nclass ToasterEntry with FToasterEntry {\n  final GlobalKey key = GlobalKey();\n  final FToastStyle? style;\n  final Alignment alignment;\n  List<AxisDirection> swipeToDismiss;\n  final Duration? duration;\n  final ValueNotifier<bool> dismissing = ValueNotifier(false);\n  final Widget Function(BuildContext context, FToasterEntry entry) builder;\n  VoidCallback? onDismiss;\n\n  ToasterEntry(this.style, this.alignment, this.swipeToDismiss, this.duration, this.builder);\n\n  @override\n  void dismiss() {\n    if (onDismiss == null || dismissing.value) {\n      return;\n    }\n\n    dismissing.value = true;\n  }\n\n  @override\n  bool get showing => onDismiss != null && !dismissing.value;\n}\n",
      "toaster_stack": "import 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:forui/forui.dart';\nimport 'package:forui/src/widgets/toast/animated_toast.dart';\nimport 'package:forui/src/widgets/toast/animated_toaster.dart';\nimport 'package:forui/src/widgets/toast/toaster.dart';\n\n/// A toaster stack is responsible for managing a stack of toasts, including the expanding animations.\n///\n/// The actual positioning of toasts is delegated to [AnimatedToaster].\n@internal\nclass ToasterStack extends StatefulWidget {\n  final FToasterStyle style;\n  final Offset expandedAlignTransform;\n  final Offset collapsedAlignTransform;\n  final List<ToasterEntry> entries;\n\n  const ToasterStack({\n    required this.style,\n    required this.expandedAlignTransform,\n    required this.collapsedAlignTransform,\n    required this.entries,\n    super.key,\n  });\n\n  @override\n  State<ToasterStack> createState() => _ToasterStackState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties\n      ..add(DiagnosticsProperty('style', style))\n      ..add(DiagnosticsProperty('expandedAlignTransform', expandedAlignTransform))\n      ..add(DiagnosticsProperty('collapsedAlignTransform', collapsedAlignTransform))\n      ..add(IterableProperty('entries', entries));\n  }\n}\n\nclass _ToasterStackState extends State<ToasterStack> with SingleTickerProviderStateMixin {\n  final ValueNotifier<Swipe> _swiping = ValueNotifier(const Unswiped());\n  late AnimationController _controller;\n  late CurvedAnimation _expand;\n  bool _autoDismiss = true;\n  bool _hovered = false;\n  int _monotonic = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      vsync: this,\n      duration: widget.style.motion.expandDuration,\n      reverseDuration: widget.style.motion.collapseDuration,\n    )..addListener(() => setState(() {}));\n    _expand = CurvedAnimation(\n      parent: _controller,\n      curve: widget.style.motion.expandCurve,\n      reverseCurve: widget.style.motion.collapseCurve,\n    );\n    _swiping.addListener(_collapseAfterSwipe);\n\n    if (widget.style.expandBehavior == FToasterExpandBehavior.always) {\n      _controller.value = 1;\n    }\n  }\n\n  @override\n  void didUpdateWidget(ToasterStack old) {\n    super.didUpdateWidget(old);\n    if (old.style != widget.style) {\n      _controller\n        ..duration = widget.style.motion.expandDuration\n        ..reverseDuration = widget.style.motion.collapseDuration\n        ..value = 0;\n      _expand\n        ..curve = widget.style.motion.expandCurve\n        ..reverseCurve = widget.style.motion.collapseCurve;\n    }\n\n    if (widget.style.expandBehavior != old.style.expandBehavior) {\n      if (widget.style.expandBehavior == FToasterExpandBehavior.always) {\n        _controller.value = 1;\n      } else if (widget.style.expandBehavior == FToasterExpandBehavior.disabled) {\n        _controller.value = 0;\n      }\n    }\n  }\n\n  // Handles cases where user is using a mouse & moves outside of the toaster's expanded region when swiping to dismiss.\n  void _collapseAfterSwipe() {\n    if (mounted && _swiping.value is ExternalEndSwipe) {\n      setState(() {\n        _autoDismiss = true;\n        _swiping.value = _swiping.value.end();\n      });\n      if (widget.style.expandBehavior == FToasterExpandBehavior.hoverOrPress) {\n        _controller.reverse();\n      }\n    }\n  }\n\n  @override\n  void dispose() {\n    _swiping.dispose();\n    _expand.dispose();\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => MouseRegion(\n    onEnter: (_) => _enter(),\n    onExit: (_) => _exit(),\n    child: GestureDetector(\n      onTap: () {\n        if (!_hovered) {\n          setState(() => _autoDismiss = !_autoDismiss);\n          if (widget.style.expandBehavior == FToasterExpandBehavior.hoverOrPress) {\n            _controller.isForwardOrCompleted ? _controller.reverse() : _controller.forward();\n          }\n        }\n      },\n      child: AnimatedToaster(\n        style: widget.style,\n        expandedAlignTransform: widget.expandedAlignTransform,\n        collapsedAlignTransform: widget.collapsedAlignTransform,\n        expand: _expand.value,\n        children: [\n          for (final (index, entry) in widget.entries.indexed)\n            AnimatedToast(\n              key: entry.key,\n              style: entry.style ?? widget.style.toastStyle,\n              alignTransform: widget.collapsedAlignTransform,\n              index: widget.entries.length - 1 - index,\n              length: widget.entries.length,\n              duration: entry.duration,\n              swipeToDismiss: entry.swipeToDismiss,\n              expand: _expand.value,\n              visible: (widget.entries.length - 1 - index) < (widget.style.max),\n              autoDismiss: _autoDismiss,\n              swiping: _swiping,\n              dismissing: entry.dismissing,\n              onDismiss: () {\n                entry.onDismiss?.call();\n                if (mounted &&\n                    widget.entries.isEmpty &&\n                    widget.style.expandBehavior == FToasterExpandBehavior.hoverOrPress) {\n                  _controller.value = 0;\n                }\n              },\n              child: entry.builder(context, entry),\n            ),\n        ],\n      ),\n    ),\n  );\n\n  Future<void> _enter() async {\n    final fencingToken = ++_monotonic;\n    _hovered = true;\n    _swiping.value = _swiping.value.enter();\n    await Future.delayed(widget.style.expandHoverEnterDuration);\n\n    if (fencingToken == _monotonic && mounted) {\n      setState(() => _autoDismiss = false);\n      if (widget.style.expandBehavior == FToasterExpandBehavior.hoverOrPress) {\n        await _controller.forward();\n      }\n    }\n  }\n\n  Future<void> _exit() async {\n    final fencingToken = ++_monotonic;\n    _hovered = false;\n    _swiping.value = _swiping.value.exit();\n\n    await Future.delayed(widget.style.expandHoverExitDuration);\n\n    if (fencingToken == _monotonic && mounted && _swiping.value is! ExternalSwipe) {\n      setState(() => _autoDismiss = true);\n      if (widget.style.expandBehavior == FToasterExpandBehavior.hoverOrPress) {\n        await _controller.reverse();\n      }\n    }\n  }\n}\n\n/// A state machine which describes a toast's swipe to dismiss state.\n@internal\nsealed class Swipe {\n  const Swipe();\n\n  // ignore: avoid_returning_this\n  Swipe start() => this;\n\n  // ignore: avoid_returning_this\n  Swipe end() => this;\n\n  // ignore: avoid_returning_this\n  Swipe enter() => this;\n\n  // ignore: avoid_returning_this\n  Swipe exit() => this;\n}\n\n/// A toast is not being swiped, initial state.\n@internal\nclass Unswiped extends Swipe {\n  const Unswiped();\n\n  @override\n  Swipe start() => const InternalSwipe();\n}\n\n/// A toast is being swiped internally, i.e. within the toast region.\n@internal\nclass InternalSwipe extends Swipe {\n  const InternalSwipe();\n\n  @override\n  Swipe end() => const Unswiped();\n\n  @override\n  Swipe exit() => const ExternalSwipe();\n}\n\n/// A toast is being swiped externally, i.e. outside the toast region.\n@internal\nclass ExternalSwipe extends Swipe {\n  const ExternalSwipe();\n\n  @override\n  Swipe end() => const ExternalEndSwipe();\n\n  @override\n  Swipe enter() => const InternalSwipe();\n}\n\n/// A toast has been swiped externally, and the swipe has ended outside the toast region.\n@internal\nclass ExternalEndSwipe extends Swipe {\n  const ExternalEndSwipe();\n\n  @override\n  Swipe end() => const Unswiped();\n\n  @override\n  Swipe enter() => this;\n}\n",
      "toaster_style": "import 'dart:ui';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'package:meta/meta.dart';\n\nimport 'package:forui/forui.dart';\n\npart 'toaster_style.design.dart';\n\n/// A toaster's expansion behavior.\nenum FToasterExpandBehavior {\n  /// The toasts are always expanded.\n  always,\n\n  /// The toasts are expanded when the toaster is hovered or pressed.\n  hoverOrPress,\n\n  /// The toasts are never expanded.\n  disabled,\n}\n\n/// [FToaster]'s style.\nclass FToasterStyle with Diagnosticable, _$FToasterStyleFunctions {\n  /// The maximum number of entries shown per [FToastAlignment]. Defaults to to 3.\n  @override\n  final double max;\n\n  /// The toaster's padding. Defaults to `EdgeInsets.symmetric(horizontal: 20, vertical: 15)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The toaster's expansion behavior. Defaults to [FToasterExpandBehavior.hoverOrPress].\n  @override\n  final FToasterExpandBehavior expandBehavior;\n\n  /// The duration to wait after entering the toaster before expanding the toasts. Defaults to 200ms.\n  @override\n  final Duration expandHoverEnterDuration;\n\n  /// The duration to wait after exiting the toaster before collapsing the toasts. Defaults to 200ms.\n  @override\n  final Duration expandHoverExitDuration;\n\n  /// The spacing below or above the toasts when they are expanded. Defaults to 0.\n  @override\n  final double expandStartSpacing;\n\n  /// The spacing between the toasts when they are expanded. Defaults to 10.0.\n  @override\n  final double expandSpacing;\n\n  /// The protrusion of the collapsed toasts behind the front toast. This is scaled by the number of toasts in\n  /// front of the toast.\n  ///\n  /// Defaults to 12.0.\n  @override\n  final double collapsedProtrusion;\n\n  /// The scaling factor pf the collapsed toasts behind the front toast. This is scaled by the number of toasts in\n  /// front of the toast.\n  ///\n  /// Defaults to 0.9.\n  @override\n  final double collapsedScale;\n\n  /// The motion-related properties.\n  @override\n  final FToasterMotion motion;\n\n  /// The toast's alignment relative to a [FToaster]. Defaults to [FToastAlignment.bottomEnd].\n  @override\n  final FToastAlignment toastAlignment;\n\n  /// The contained toasts' style.\n  @override\n  final FToastStyle toastStyle;\n\n  /// Creates a [FToasterStyle].\n  const FToasterStyle({\n    required this.toastStyle,\n    this.max = 3,\n    this.padding = const EdgeInsets.symmetric(horizontal: 20, vertical: 15),\n    this.expandBehavior = FToasterExpandBehavior.hoverOrPress,\n    this.expandHoverEnterDuration = const Duration(milliseconds: 200),\n    this.expandHoverExitDuration = const Duration(milliseconds: 200),\n    this.expandStartSpacing = 0,\n    this.expandSpacing = 10,\n    this.collapsedProtrusion = 12,\n    this.collapsedScale = 0.9,\n    this.motion = const FToasterMotion(),\n    this.toastAlignment = FToastAlignment.bottomEnd,\n  });\n\n  /// Creates a [FToasterStyle] that inherits its properties.\n  FToasterStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        toastStyle: FToastStyle.inherit(colors: colors, typography: typography, style: style),\n      );\n}\n\n/// The motion-related properties for [FToaster] that affect all toasts.\nclass FToasterMotion with Diagnosticable, _$FToasterMotionFunctions {\n  /// The duration of the toasts' expansion. Defaults to 400ms.\n  @override\n  final Duration expandDuration;\n\n  /// The duration of the toasts' collapsing. Defaults to 300ms.\n  @override\n  final Duration collapseDuration;\n\n  /// The animation curve for the toasts' expansion and collapsing. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve expandCurve;\n\n  /// The animation curve for the toasts' collapsing. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve collapseCurve;\n\n  /// Creates a [FToasterMotion].\n  const FToasterMotion({\n    this.expandDuration = const Duration(milliseconds: 400),\n    this.collapseDuration = const Duration(milliseconds: 300),\n    this.expandCurve = Curves.easeOutCubic,\n    this.collapseCurve = Curves.easeOutCubic,\n  });\n}\n\n/// The toast's style.\nclass FToastStyle with Diagnosticable, _$FToastStyleFunctions {\n  /// The toast's constraints. Defaults to `BoxConstraints(maxHeight: 250, maxWidth: 400)`.\n  @override\n  final BoxConstraints constraints;\n\n  /// The toast's decoration.\n  @override\n  final BoxDecoration decoration;\n\n  /// An optional background filter. This only takes effect if the [decoration] has a transparent or translucent\n  /// background color.\n  ///\n  /// This is typically combined with a transparent/translucent background to create a glassmorphic effect.\n  ///\n  /// There will be a flicker after the toast's fade-in entrance when a blur background filter is applied. This is due to\n  /// https://github.com/flutter/flutter/issues/31706.\n  ///\n  /// ## Examples\n  /// ```dart\n  /// // Blurred\n  /// ImageFilter.blur(sigmaX: 5, sigmaY: 5);\n  ///\n  /// // Solid color\n  /// ColorFilter.mode(Colors.white, BlendMode.srcOver);\n  ///\n  /// // Tinted\n  /// ColorFilter.mode(Colors.white.withValues(alpha: 0.5), BlendMode.srcOver);\n  ///\n  /// // Blurred & tinted\n  /// ImageFilter.compose(\n  ///   outer: ImageFilter.blur(sigmaX: 5, sigmaY: 5),\n  ///   inner: ColorFilter.mode(Colors.white.withValues(alpha: 0.5), BlendMode.srcOver),\n  /// );\n  /// ```\n  @override\n  final ImageFilter? backgroundFilter;\n\n  /// The toast content's padding. Defaults to `EdgeInsets.all(16)`.\n  @override\n  final EdgeInsetsGeometry padding;\n\n  /// The style of the toast's prefix icon.\n  @override\n  final IconThemeData iconStyle;\n\n  /// The spacing between the icon and the title. Defaults to 10.0.\n  @override\n  final double iconSpacing;\n\n  /// The title's text style.\n  @override\n  final TextStyle titleTextStyle;\n\n  /// The spacing between the title and description Defaults to 5.0.\n  @override\n  final double titleSpacing;\n\n  /// The description's text style.\n  @override\n  final TextStyle descriptionTextStyle;\n\n  /// The spacing between the icon and the title. Defaults to 12.0.\n  @override\n  final double suffixSpacing;\n\n  /// The motion-related properties.\n  @override\n  final FToastMotion motion;\n\n  /// Creates a [FToastStyle].\n  FToastStyle({\n    required this.decoration,\n    required this.iconStyle,\n    required this.titleTextStyle,\n    required this.descriptionTextStyle,\n    this.constraints = const BoxConstraints(maxHeight: 250, maxWidth: 400),\n    this.padding = const EdgeInsets.all(16),\n    this.backgroundFilter,\n    this.iconSpacing = 10,\n    this.titleSpacing = 1,\n    this.suffixSpacing = 12,\n    this.motion = const FToastMotion(),\n  });\n\n  /// Creates a [FToastStyle] that inherits its properties.\n  FToastStyle.inherit({required FColors colors, required FTypography typography, required FStyle style})\n    : this(\n        decoration: BoxDecoration(\n          border: Border.all(color: colors.border),\n          borderRadius: style.borderRadius,\n          color: colors.background,\n        ),\n        iconStyle: IconThemeData(color: colors.primary, size: 18),\n        titleTextStyle: typography.sm.copyWith(color: colors.primary, fontWeight: FontWeight.w500),\n        titleSpacing: 5,\n        descriptionTextStyle: typography.sm.copyWith(color: colors.mutedForeground, overflow: TextOverflow.ellipsis),\n      );\n}\n\n/// The motion-related properties for [FToaster] that affect individual toasts.\nclass FToastMotion with Diagnosticable, _$FToastMotionFunctions {\n  /// The duration of the toast's entrance when it is initially added to to toaster. Defaults to 400ms.\n  @override\n  final Duration entranceDuration;\n\n  /// The duration of the toast's exit animation when it is dismissed. Defaults to 300ms.\n  @override\n  final Duration dismissDuration;\n\n  /// The duration of the toast's transition between places in the toaster. Defaults to 400ms.\n  @override\n  final Duration transitionDuration;\n\n  /// The duration of the toast's fade-in animation when another toast has been dismissed and this toast re-enters the\n  /// toaster. Defaults to 400ms.\n  @override\n  final Duration reentranceDuration;\n\n  /// The duration of the toast's fade-out animation when the number of toasts in a toaster exceeds the maximum allowed\n  /// and this toast is hidden. Defaults to 400ms.\n  @override\n  final Duration exitDuration;\n\n  /// The toast's swipe completion animation duration. Defaults to 150ms.\n  @override\n  final Duration swipeCompletionDuration;\n\n  /// The toast's initial entrance animation curve. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve entranceCurve;\n\n  /// The toast's exit animation curve. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve dismissCurve;\n\n  /// The toast's transition animation curve. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve transitionCurve;\n\n  /// The curve of the toast's fade-in animation when another toast has been dismissed and this toast re-enters the\n  /// toaster. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve reentranceCurve;\n\n  /// The curve of the toast's fade-out animation when the number of toasts in a toaster exceeds the maximum allowed\n  /// and this toast is hidden. Defaults to [Curves.easeOutCubic].\n  @override\n  final Curve exitCurve;\n\n  /// The toast's swipe completion animation curve. Defaults to [Curves.easeInCubic].\n  @override\n  final Curve swipeCompletionCurve;\n\n  /// The toast's initial entrance's opacity and dismiss's fade tween. Defaults to `[0, 1]`.\n  ///\n  /// Set to `[1, 1]` to disable the fade-in/out effect.\n  @override\n  final Animatable<double> entranceDismissFadeTween;\n\n  /// Creates a [FToastMotion].\n  const FToastMotion({\n    this.entranceDuration = const Duration(milliseconds: 400),\n    this.dismissDuration = const Duration(milliseconds: 300),\n    this.transitionDuration = const Duration(milliseconds: 400),\n    this.reentranceDuration = const Duration(milliseconds: 400),\n    this.exitDuration = const Duration(milliseconds: 400),\n    this.swipeCompletionDuration = const Duration(milliseconds: 150),\n    this.entranceCurve = Curves.easeOutCubic,\n    this.dismissCurve = Curves.easeOutCubic,\n    this.transitionCurve = Curves.easeOutCubic,\n    this.reentranceCurve = Curves.easeOutCubic,\n    this.exitCurve = Curves.easeOutCubic,\n    this.swipeCompletionCurve = Curves.easeInCubic,\n    this.entranceDismissFadeTween = const FImmutableTween(begin: 0.0, end: 1.0),\n  });\n}\n"
    }
  }
}